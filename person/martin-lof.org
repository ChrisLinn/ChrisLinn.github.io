#+title: martin lof

* main papers

*** (1972) [MLTT72] an intuitionistic theory of types

***** intro

***** 1. informal explanation of the basic concepts

******* 1.1 mathematical objects and their types

        - objects are always with their types

        - a type is defined by prescribing
          what we have to do
          in order to construct an object of that type.
          [as Bishop's set]

          - x -
            not necessarily be able to write a predicate
            to decide whether an arbitrary object
            is of that type ?

******* 1.2 propositions and proofs

        - proposition is type
          thus,
          a proposition is defined by prescribing
          how we are allowed to prove it.
          a proposition is true intuitionistically
          if there is a proof of it.

******* 1.3 cartesian product of a family of types

        - dependent arrow

        #+begin_src cicada
        B: (A) -> type
        { (x: A) -> B(x) } : type

        b(x: A) : B(x)
        b(x: A) = ...

        a: A
        --------
        b(a) : B(a)
        #+end_src

******* [note] schema

        - the author use the term schema to specify definition,
          which may be understood as
          general patterns of function body.

        - whenever there are multiple equations in the schema,
          branching in the function body must be used
          for example : (case) (cond) (match)

******* 1.4 disjoint union of a family of types

        - dependent pair

        #+begin_src jojo
        (* (: :x A) :x B)
        (: C (-> (* (: :x A) :x B) -- Type))

        (note
          this C is to demonstrate
          how should we construct the elements of a type
          which dependents on (* (: :x A) :x B))

        (: d (-> (: :x A) (: :y :x B) -- (* :x :y) C))
        (+fun f (-> (* (: :x A) (: :y :x B)) -- (* :x :y) C)
          tuple-spread d)
        (+fun f (-> (: (* :x :y) (* A :x B)) -- (* :x :y) C)
          tuple-spread d)

        (+fun f (-> (* (: :x A) (: :y :x B)) -- (* :x :y) C)
          (* :x :y) {d} E)

        (+fun E (-> (suppose (: :A Type) (: :B (-> :A -- Type)))
                    (* (: :x :A) (: :y :x :B))
                    (: :f (-> (: :x :A) (: :y :x :B) -- (* :x :y) :C))
                 -- (* :x :y) :C)
          tuple-spread :f)

        (+fun p (note left projection)
          (-> (^ (: :A Type) (: :B (-> :A -- Type)))
              (* (: :x :A) (: :y :x :B))
           -- (: :x :A)))

        (+fun q (note right projection)
          (-> (^ (: :A Type) (: :B (-> :A -- Type)))
              (* (: :x :A) (: :y :x :B))
           -- (: :y :x :B)))

        (note example
          R for real number
          (= R [(: :x (-> Z -- Q))
                (-> (: :m :n Z)
                    -- :m :n add :x :m :x sub abs
                    2 :m neg power LT)]))
        #+end_src

******* 1.5 disjoint union of two types

        - disjoint
          thus can not be dependent

        #+begin_src jojo
        (+ A B)
        (: C (-> (+ A B) -- Type))

        (: d (-> (: :x A) -- :x C))
        (: e (-> (: :y B) -- :y C))
        (+fun f (-> (: :z (+ A B)) -- :z C)
          (case :z
            A [:z d]
            B [:z e]))

        (+fun f (-> (: :z (+ A B)) -- :z C)
          :z {d} {e} D)

        (+fun D (-> (: :z (+ A B))
                    (: :d (-> (: :x A) -- :x C))
                    (: :e (-> (: :y B) -- :y C))
                 -- :z C)
          (case :z
            A [:z :d]
            B [:z :e]))
        #+end_src

******* 1.6 Finite types

        #+begin_src jojo
        :n Finite
        3  Finite
        (: C (-> 3 Finite -- Type))

        (: c1 1 C)
        (: c2 2 C)
        (: c3 3 C)
        (+fun f (-> (: :x 3 Finite) -- :x C)
          (cond [:x 1 eq?] c1
                [:x 2 eq?] c2
                [:x 3 eq?] c3))

        (note
          (= [0 Finite] Falsehood)
          (= [1 Finite] Truth))
        #+end_src

******* 1.7 Natural numbers

        #+begin_src jojo
        (+type N : Type
          zero : N
          succ : (-> (. .ante N) -- N))

        (: C (-> N -- Type))

        (: d zero C)
        (: e (-> (: :n N) :n C -- :n succ C))

        (+fun f (-> (: :x N) -- :x C)
          (match :x
            zero d
            succ [:x :x .ante f e]))

        (+fun f (-> (: :x N) -- :x C)
          :x d {e} R)

        (+fun R (-> (: :x N)
                    (: :d zero C)
                    (: :e (-> (: :n N) :n C -- :n succ N))
                 -- :x C)
          (match :x
            zero :d
            succ [:x .ante, :x .ante :d {:e} R, :e]))

        (+fun R (-> zero C
                    (-> (: :n N) :n C -- :n succ N)
                    (: :x N)
                    -- :x C)
          (match :x
            zero [drop]
            succ [tuck :x .ante R swap :x .ante swap apply]))
        #+end_src

******* [note] type constructor

        - x -
          when defining a type-constructor,
          this type-constructor can be used to form dependent arrow,
          the author also shows carefully
          how to construct functions
          whose type is this dependent arrow.

          why ?

******* 1.8 Reflection principle

        - x -
          this section is very important,
          for it shows what the author intend to achieve.

          and it shows that the use of type valued function
          is really flexible.

          and the so called Reflection principle
          is simply a closure principle.

        #+begin_src jojo
        (note
          equality between natural numbers)

        (+fun E (-> [:m :n : N] -- Universe)
          (match [:m :n]
            [zero zero] Truth
            [zero succ] Falsehood
            [succ zero] Falsehood
            [succ succ] [:m .ante :n .ante E]))

        (note
          the Universe seems specially ad hoc here
          because this equality is treated in a better way
          in the published paper)

        :x : N -> :x F

        (+fun F
          : (-> :x : N -- Type)
          (match :x
            zero N
            succ (-> :x.pre F -- N)))

        zero F == N
        zero succ F == (-> N -- N)
        zero succ succ F == (-> (-> N -- N) -- N)
        ...
        #+end_src

******* >< 1.9 Girard's paradox

        #+begin_src jojo

        #+end_src

***** >< 2 formalization of an intuitionistic theory of types

***** >< 3 reduction of some other formal theories to the theory of type

***** >< 4 the normalization theorem and its consequences

*** (1973) [MLTT73] an intuitionistic theory of types: predicative part

***** intro

***** 1. informal explanation of the primitive notions

******* 1.1 mathematical objects and their types

******* 1.2 propositions and proofs

        - proposition and datatype
          are two view of the same construction

          - when view a type as proposition
            we only care whether it is non empty

          - when view a type as datatype
            we also care about what its objects are

******* 1.4 cartesian product of a family of types

        #+begin_src jojo
        (: B (-> A -- Type))
        (-> (: :x A) -- :x B)

        (+fun b (-> (: :x A) -- :x B)
          :x ...
          (note
            the author introduce this
            by so called "explicit definition".
            it would be better be introduce by examples))

        (: a A)
        (: a b a B)
        #+end_src

******* 1.5 disjoint union of a family of types

        #+begin_src jojo
        (* (: :x A) :x B)
        (: C (-> (* (: :x A) :x B) -- Type))

        (note
          this C is to demonstrate
          how should we construct the elements of a type
          which dependents on (* (: :x A) :x B)
          (note
            why this is important ?
            because [:x C] is the general form
            of non trivial propositions ?

            thus C is to demonstrate
            how to prove a proposition
            for objects of type (* (: :x A) :x B)

            it seems that
            to define a type constructor
            it is not sufficent to only prescribe
            how to construct its elements !

            because type constructor is not a type ?))

        (note
          in this version of the paper
          the author does not use general combinators anymore)

        (: g (-> (: :x A) (: :y :x B) -- (* :x :y) C))
        (+fun f (-> (* (: :x A) (: :y :x B)) -- (* :x :y) C)
          tuple-spread g)

        (note
          (= (* (: :x A) (: :y :x B))
             (: (* :x :y) (* A :x B))))

        (+fun p (note left projection)
          (-> (^ (: :A Type) (: :B (-> :A -- Type)))
              (* (: :x :A) (: :y :x :B))
              -- (: :x :A))
          tuple-spread drop)

        (+fun q (note right projection)
          (-> (^ (: :A Type) (: :B (-> :A -- Type)))
              (* (: :x :A) (: :y :x :B))
              -- (: :y :x :B))
          tuple-spread swap drop)

        (note example
          R for real number
          (= R [(: :x (-> Z -- Q))
                (-> (: :m :n Z)
                    -- :m :n add :x :m :x sub abs
                    2 :m neg power LT)])
          here R is defined by Cauchy condition.
          the author is thinking about
          Bishop's constructive analysis.)
        #+end_src

******* 1.3 properties

        - a proposition valued function
          is called a property,
          or, in intuitionistic terminology, a species.

        - thus, we also call
          a type valued function
          a species.

        - if (: B (-> A -- Type))
          then [a B] is the proposition that
          a belongs to the species B.

          we call B 'a species of objects of A'

        - the term 'belongs to' is used here,
          but it is different from ':'.

        - examples :
          3 : N   -- 3 is a natural number
          3 Prime -- 3 is a prime number

        - x -
          classcally 'natural number' and 'prime number'
          seems both are set.
          but, in type theory,
          the different notions of 'belongs to' are explicit.

          - Bishop -
            meaningful distinctions deserve to be maintained.

******* 1.6 disjoint union of two types

        #+begin_src jojo
        (+ A B)
        (: C (-> (+ A B) -- Type))

        (: d (-> (: :x A) -- :x C))
        (: e (-> (: :y B) -- :y C))
        (+fun f (-> (: :z (+ A B)) -- :z C)
          (case :z
            A [:z d]
            B [:z e]))
        #+end_src

******* [note] disjoint union of two types -- broken symmetry

        - x -
          (* ...) is a type-constructor
          and it is also a data-constructor
          if (: a A) (: b B)
          then (: (* a b) (* A B))

          (+ A B) is a type-constructor
          but it is not a data-constructor
          [at least not in current semantic]

          we want to say
          if (: a A) (: b B)
          then (: (+ a b) (+ A B))

          but if we view (+ a b) as one value [object]
          we must introduce non-deterministic

        - k -
          There are several ways
          an algorithm may behave differently
          from run to run.
          1. A concurrent algorithm
             can perform differently on different runs
             due to a race condition.
          2. A probabilistic algorithm's behaviors
             depends on a random number generator.

        - and the nondeterministic algorithms
          are often used to find an approximation to a solution,
          when the exact solution would be too costly
          to obtain using a deterministic one.

        - in nondeterministic programming
          at certain points in the program (called "choice points"),
          various alternatives for program flow.
          Unlike an if-then statement,
          the method of choice between these alternatives
          is not directly specified by the programmer;
          the program must decide at run time
          between the alternatives,
          via some general method applied to all choice points.

        - some alternatives may "fail,"
          backtracking might be used.

******* 1.7 identity

        #+begin_src jojo
        (: I (-> (: :x :y :A) -- Type))
        (: refl (-> (: :x :A) -- :x :x I))

        (: C (-> (: :x :y :A) :x :y I -- Type))

        (: g (-> (: :x :A) -- :x :x :x refl C))
        (+fun f (-> (: :x :y :A) (: :z :x :y I) -- :x :y :z C)
          :x g)

        (+fun f (-> [:x :y] : :A, :z : :x :y I -- :x :y :z C)
          :x g)
        #+end_src

******* 1.8 Finite types

        #+begin_src jojo

        #+end_src

******* 1.9 Natural numbers

        - x -
          this section shows why the author uses 'C'.
          it means
          whenever we defined a type-constructor or a type,
          we also need to prescribe how can we proof
          'for all objects of such type, property C holds'
          (-> :x : [...] -- :x C)

          this is an implicit specification [or implicit aim]
          of the design of any prover,
          i.e. be able to capture mathematical induction.

        - k -
          and such type-constructors
          can be introduced un-conditionally.

          why ?

          and what is the meaning of those data-constructors
          of a type-constructor ?

        - x -
          can we reduce such user defined type-constructors
          to other fixed type-constructors ?

          I sense broken symmetry here.

          if we view (-> ... -- ...) as type-constructor
          it will be so special.

        #+begin_src jojo
        (+type N : Type
          zero : N
          succ : (-> (. .ante N) -- N))

        (: C (-> N -- Type))

        (: c zero C)
        (: g (-> :n : N, :n C -- :n succ C))

        (+fun f (-> :x : N -- :x C)
          (match :x
            zero c
            succ [:x .ante dup f g]))
        #+end_src

******* 1.10 Universes

        - the abstractions described so far
          still do not allow us to types and type valued functions.

        #+begin_src jojo
        (note
          the type of finie sequence of natural numbers)

        (* :x : N, :x F)

        (+fun F (-> :x : N -- Universe)
          (match :x
            zero N1
            succ (* :x .ante F, N)))

        (note
          transfinite type)

        (-> :x : N -- :x G)

        (+fun G (-> :x : N -- Universe)
          (match :x
            zero N
            succ (-> :x .ante G -- N)))

        (note
          if we use Universe to type
          the return value of above functions
          Universe must be close under type-constructors
          such as (* ...) and (-> ... -- ...))

        (note
          although Universe is closed under many type-constructors
          but we can not have (: Universe Universe))
        #+end_src

******* [note] the use of Universe

        - x -
          the use of Universe seems un-natural to me.
          because the function body here contain so much informations
          but all these informations are lost.

        - k -
          the goal is 'every type is also an object of some type'

        - x -
          we should get rid of those type valued function
          the type of whose return value is Universe.

          because all informations are sunk into this Universe.

******* 1.11 definitional equality

        - x -
          this means during unification
          we can and should do function call.

          or before pure unification
          we must try to reduce the term.

        - k -
          although it is called 'definitional equality'
          the basic relation is actually directed.

        - principle -

        #+begin_src jojo
        a : A, A = B
        --------------
        a : B
        #+end_src

******* [note] lambda of type

        - x -
          we do not have lambda of type
          we can not do definition inductively without naming.

***** 2 formalization of an intuitionistic theory of types

******* 2.1 terms and type symbols

        - the formal system we shell setup
          consists of a certain number of mechanical rules
          for deriving symbolic expressions of forms :
          1. a : A
          2. a conv b -- 'conv' denotes 'converts to'
             i.e. term reduce, computation.

        - thus we also have two kinds of rules,
          classified by conclusion type :
          1. term formation
          2. c

******* 2.2 variables

******* 2.3 constants

******* 2.4 rules for Pi -- dependent arrow

******* 2.5 rules for Sigma -- dependent product

******* 2.6 rules for Plus -- sum type

******* 2.7 rules for I

******* 2.8 rules for Nn

******* 2.9 rules for N

******* ><

***** >< 3 the model of closed normal terms

      - the normalization theorem (for closed terms) and its consequences

*** (1979) [MLTT79] constructive mathematics and computer programming

***** intro

      - the whole conceptual apparatus of programming
        mirrors that of modern mathematics
        (set theory, that is, not geometry)
        and yet is supposed to be different from it.
        How come?
        The reason for this curious situation is, I think,
        that the mathematical notions have
        gradually received an interpretation,
        the interpretation which we refer to as classical,
        which makes them unusable for programming.

      - it is clear that

        if a function is defined as a binary relation
        satisfying the usual existence and unicity conditions,
        whereby classical reasoning is allowed in the existence proof,
        or a set of ordered pairs
        satisfying the corresponding conditions,
        then a function cannot be the same kind of thing
        as a computer program.

        similarly,
        if a set is understood in Zermelo’s way
        as a member of the cumulative hierarchy,
        then a set cannot be the same kind of thing as a data type.

***** expressions

      - The expressions of the theory of types
        are formed out of variables,
        by means of various forms of expression.

      - a expression can be evaluated to get a value.

      - I shall call an expression, in whatever notation,
        canonical [or normal]
        if it is already fully evaluated,
        which is the same as to say that
        it has itself as value.
        thus, evaluation is idempotent.

      - x -
        the reason that
        - we can not only have value,
          we also need to have expression.
        is because we uses variables.
        variables are not value.

      - x -
        the notion of canonical and non-canonical expressions,
        is to capture
        the notion of data and program form [code].

      - x -
        the author uses lazy-eval,
        and outside-first eval order.

        while in sequent1,
        I used eager-eval,
        and postfix notation.

        the notion of 'not-yet-determined object'
        made lazy-eval not necessary.

      - x -
        to define the theory of type,
        we must specify
        what canonical and non-canonical expressions
        we already have.

      - table of the primitive forms of expression :

        | canonical type     |               | non-canonical      |
        |--------------------+---------------+--------------------|
        | type               | intro         | elim               |
        |--------------------+---------------+--------------------|
        | (Pi (: :x A) B)    | (Lambda :x B) | (c a)              |
        | (Sigma (: :x A) B) | (* a b)       | (E [:x :y] c d)    |
        | (+ A B)            | (i a) (j b)   | (D [:x :y] c d e)  |
        | (I A a b)          | refl          | (J c d)            |
        | N0                 |               | (R0 c)             |
        | N1 0_1             |               | (R1 c c0)          |
        | N2 0_2 1_2         |               | (R2 c c0 c1)       |
        | ...                |               | ...                |
        | N 0 a'             |               | (R [:x :y] c d e)  |
        | (W (: :x A) B)     | (sup a b)     | (T [:x :y :z] c d) |
        | Universe0          |               |                    |
        | Universe1          |               |                    |
        | ...                |               |                    |

***** judgements

      - four forms of judgements in type theory :
        1. A is a type -- (: A Type)
        2. A and B are equal types -- (= A B)
        3. a is an object of type A -- (: a A)
        4. a and b are equal objects of type A -- (= a b : A)

      - three forms of judgements in predicate logic :
        [whether classical or intuitionistic]
        1. A is a formula.
        2. A is true.
        3. a is an individual term.

      - A canonical type A is defined by prescribing :
        1. how a canonical object of type A is formed.
        2. how two equal canonical objects of type A are formed.

        For noncanonical A,
        a judgment of the form (: A Type)
        means A has a canonical type as value.

        There is no limitation on this prescription
        except that the relation of equality
        which it defines between canonical objects of type A
        must be reflexive, symmetricand transitive.

      - Bishop -
        A set is not an entity which has an ideal existence.
        A set exists only when it has been defined.
        To define a set we prescribe, at least implicitly,
        1. what we (the constructing intelligence) must do
           in order to construct an element of the set,
        2. and what we must do to show that
           two elements of the set are equal.

      - If the rules for forming canonical objects
        as well as equal canonical objects of a certain type
        are called the introduction rules for that type,
        we may thus say with Gentzen that
        a canonical type (proposition)
        is defined by its introduction rules.

      - Two canonical types A and B are equal
        if a canonical object of type A
        is also a canonical object of type B
        and, moreover, equal canonical objects of type A
        are also equal canonical objects of type B,
        and vice versa.

        - x -
          very strong [hard to prove] property.

        For arbitrary types A and B,
        [not necessarily canonical]
        a judgment of the form (= A B) means that
        A and B have equal canonical types as values.

      - x -
        about implementation of type and equality.
        1. we use induction to define type,
           which provides us data-constructors
           to construct elements of the type.
        2. we use structural equality as basic equality,
           we can derive from this basic equality by quotient
           to form quotient-type.

      - x -
        by the definition of type
        we must be able to implement predicates for judgments :
        (3) a is an object of type A -- (: a A)
        (4) a and b are equal objects of type A -- (= a b : A)

        - note how the use of not-yet-determined objects
          will impact the semantics of (3) and (4)

        - and not how unification is different from equality.

***** >< inference

      - natural deduction :
        ><><><

      - x -
        can we make variable substitution better in the rules ?

      - x -
        in sequent1
        inference rule should also be expressed by arrow type.

*** (1984) [Bibliopolis] intuitionistic type theory

***** introductory remarks

***** propositions and judgements

***** explanations of the forms of judgement

******* A : Set

******* A = B : Set

******* a : A

******* a = b : A

***** propositions

      - Classically, a proposition is nothing but a truth value,
        that is, an element of the set of truth values,
        whose two elements are the true and the false.

      - Because of the difficulties of justifying the rules
        for forming propositions
        by means of quantification over infinite domains,
        when a proposition is understood as a truth value,
        this explanation is rejected by the intuitionists
        and replaced by saying that,

        - a proposition is defined
          by laying down what counts as a proof of the proposition,

        - and that, a proposition is true if it has a proof,
          that is, if a proof of it can be given.

***** rules of equality

***** hypothetical judgements and substitution rules

******* B : (-> :x : A -- Set)

******* (-> :x : A -- :x B = :x D)

******* (-> :x : A -- :x b : :x B)

******* (-> :x : A -- :x b = :x d)

***** judgements with more than one assumption and contexts

***** sets and categories

      - A category is defined by explaining
        what an object of the category is
        and when two such objects are equal.

      - A category need not be a set,
        since we can grasp what it means
        to be an object of a given category
        even without exhaustive rules for forming its objects.

      - examples :
        #+begin_src jojo
        Set
        A
        (-> :x : A -- Set)
        (-> :x : A -- :x B)
        (* :x : A, :y : :x B)
        (-> :x : A, :y : :x B -- :x :y C)
        #+end_src

      - We will say 'object' of a category
        but 'element' of a set,
        which reflects the difference between categories and sets.

      - To define a category
        it is not necessary to prescribe
        how its objects are formed,
        but just to grasp what an (arbitrary) object
        of the category is.

      - Each set determines a category,
        namely the category of elements of the set,
        but not conversely :

        - for instance,
          the category of sets
          and the category of propositions are not sets,
          since we cannot describe
          how all their elements are formed.

      - We can now say that
        a judgement is a statement to the effect that
        something is an object of a category,
        or that two objects of a category are equal.

      - x -
        the author said (-> :x : A -- :x B)
        is a not set but a category,
        and (-> A -- B) is a set.

        which is not consistent.

        it would be better to only view
        inductively defined type as set.

***** general remarks on the rules

      - We now start to give the rules
        for the different symbols we use.
        We will follow a common pattern in giving them.
        For each operation we have four rules :
        1. set formation
        2. introduction
        3. elimination
        4. equality

      - The formation rule says that
        we can form a certain set (proposition)
        from certain other sets (propositions)
        or families of sets (propositional functions).

      - The introduction rules say
        what are the canonical elements
        (and equal canonical elements) of the set,
        thus giving its meaning.

      - The elimination rule shows
        how we may define functions
        on the set defined by the introduction rules.

      - The equality rules
        relate the introduction and elimination rules
        by showing how a function defined
        by means of the elimination rule
        operates on the canonical elements of the set
        which are generated by the introduction rules.

***** cartesian product of a family of sets

      #+begin_src jojo
      (-> :x : A -- :x B)
      #+end_src

***** definitional equality

      - type alias

***** applications of the cartesian product

***** disjoint union of a family of sets

***** applications of the disjointunion

***** the axiom of choice

      #+begin_src jojo
      (+proof axiom-of-choice
        (-> :h : (-> :x : A -- :y : :x B, :x :y C)
         -- :f : (-> :x : A -- :x B)
            (-> :x : A -- :x :x :f C))
        {:h drop}
        {:h swap drop})

      (+proof axiom-of-choice
        (-> :h : (-> :x : A -- :y : :x B, :x :y C)
         -- :f : (-> :x0 : A -- :x0 B)
            (-> :x1 : A -- :x1 :x1 :f C))
        {:h drop}
        {:h swap drop})
      #+end_src

***** the notion of such that

***** disjoint union of two sets

***** propositional equality

      - I(A,a,b) is an internal form of =.

      - x -
        one equality is the unification
        used in the implementation of the type system,
        while another equality is the unification
        exposed to the language been implemented.

***** finite sets

***** consistency

***** natural numbers

***** lists

***** well orderings

***** universes

* (1972) infinite terms and a system of natural deduction

* (1975) about models for intuitionistic type theories and the notion of definitional equality

*** 1 models

* (1975) syntax and semantics of the language of primitive recursive functions

* (1976) a note to michael dummett

* >< (1983) on the meanings of the logical constants and the justification of logical laws

* (1983) notes on the domain interpretation of type theory

* (1987) the logic of judgements

  - [the hand writing is too hard to read]

* (1987) truth of a proposition, evidence of a judgment, validity of a proof

* (1990) mathematics of infinity

* (1990) a path from logic to metaphysics

* (1992) substitution calculus (notes from a lecture given in göteborg)

* (1994) analytic and synthetic judgements in type theory

  - 指出 brouwer 受 kant 影響

* (1998) truth and knowability: on the principles c and k of michael dummett

* >< (2008) hilbert brouwer controversy resolved ?

* (2009) one hundred years of zermelo's axiom of choice. what was the problem with it?

* (2013) verificationism then and now

* (2014) making sense of normalization by evaluation

* others

*** [note] predicate vs type-constructor

***** observation 1

      - 'even?' can be defined as a predicate on type <nat>
        (: even? (-> <nat> -- <bool>))

      - while it can also be defined as a type-constructor
        #+begin_src jojo
        (+type <even> (-> (. .num <nat>) -- <<type>>)
          zero (-> -- zero <even>)
          plus-two (-> (. .pre :m <even>)
                    -- :m succ succ <even>))

        (proof (-> -- zero succ succ <even>)
          zero plus-two)
        #+end_src

      - <nat> is so simple,
        we do not really have to define <even>
        we can simply write 'even?'

      - we can view 'even?' as generating a proof for each {:n <even>}
        or even better, it can generate a negation of {:n <even>}

        - although in normal implementation of 'even?'
          it output a <bool> instead of a proof.

***** observation 2

      - 'add-associative' is defined as
        #+begin_src jojo
        (+proof add-associative
          (-> (: :x :y :z <nat>)
           -- :x :y add :z add
              :x :y :z add add <eq>)
          (match :z
            zero refl
            succ [:x :y :z.pre recur {succ} eq-apply]))
        #+end_src

      - it can be viewed as equivalence between two functions
        {2-1-sawp add add} == {add add}

      - while 'add-commutative' can be viewed as
        {sawp add} == {add}

      - the space of functions like (-> <nat> <nat> -- <nat>)
        is so complicated,

        we do not have a basic predicate for equivalence
        between functions in such space.

        we have to prove each instance of equivalence.
        for example, 'add-commutative' proves {swap add} == {add}

***** observation 3

      - computation can happen during type-checking.
        applying a predicate is a computation.

        is it meaningful to use predicate in type ?

***** >< LTEQ

      - just like EVEN

***** >< LT

      - x -
        基本等词 与 unification 不同
        基本等词 是唯一允许的 predicate
        基本等词 可以用来做否定

      - k -
        如果基本等词是 predicate
        那么为何不允许别的 predicate 呢 ?

      - x -
        在 coq 中找例子

*** programming in martin lof's type theory

*** intuitionistic type theory -- from plato.stanford.edu

***** info

      - at https://plato.stanford.edu/entries/type-theory-intuitionistic/

      - by Peter Dybjer
        and Erik Palmgren

***** intro

      - an overview of the most important aspects of intuitionistic type theory
        a kind of “extended abstract”
        It is meant for a reader who is already somewhat familiar with the theory

      - Section 2 on the other hand,
        is meant for a reader who is new to intuitionistic type theory
        but familiar with traditional logic,
        including propositional and predicate logic,
        arithmetic, and set theory.
        Here we informally introduce several aspects
        which distinguishes intuitionistic type theory
        from these traditional theories.

      - In Section 3 we present a basic version of the theory,
        close to Martin-Löf’s first published version from 1972.
        The reader who was intrigued by the informality of Section 2
        will now see in detail how the theory is built up.

      - Section 4 then presents a number of important extensions of the basic theory.
        In particular, it emphasizes the central role of
        inductive (and inductive-recursive) definitions.

      - Section 5 introduces the underlying philosophical ideas
        including the theory of meaning developed by Martin-Löf.

      - While Section 5 is about philosophy and foundations,
        Section 6 gives an overview of mathematical models of the theory.

      - In Section 7 finally,
        we describe several important variations
        of the core Martin-Löf “intensional” theory described in Section 3 and 4.

***** 1. Overview

      - not only about how should we play [by constructive proof]
        but also about what should we play with [constructive mathematical objects]
        thus it is more than math
        it is philosophy

***** 2. Propositions as Types

******* 2.1 Intuitionistic Type Theory: a New Way of Looking at Logic?

        - Intuitionistic type theory
          offers a new way of analyzing logic,
          mainly through its introduction of
          *explicit proof objects*.

********* 2.1.1 A Type Theory

          - This provides
            a direct computational interpretation of logic,
            since there are computation rules for proof objects.

********* 2.1.2 An intuitionstic logic with proof-objects

          - example :
            #+begin_src jojo
            (-> (: :m :n <nat>) :m zero <gt>
             -- (: :q :r <nat>) :m :q mul :r add :n <eq>)

            (-> (: :m :n N) :m zero GT
             -- (: :q :r N) :m :q mul :r add :n I)

            (note
              where GT is defined as type alias :
              (: :x :y GT)
              (: :y :z add inc :x I))
            #+end_src

********* 2.1.3 An extension of first-order predicate logic

          - x -
            in predicate logic (first-order or higher)
            the domain of predicate can be viewed as set.

            [suppose we use set theory
            to specify the denotational semantics
            of the logic system.]

            cartesian product will be the main way
            of constructing new sets.
            (new domain of predicate)

            function is defined as special relation (predicate)
            equivalence is defined special relation
            - which is wrong, because
              "meaningful distinctions deserve to be maintained."

          - difference from predicate logic :
            in intuitionistic type theory
            we can introduce unspecified family symbols.
            [type-constructor]

********* 2.1.4 A logic with several forms of judgment

          - the type system of intuitionistic type theory is very expressive.
            1. well-formedness of a type
            2. well-typedness of a term with respect to a type
            3. equality judgments for types and terms

          - while predicate logic focus on the sole judgment
            expressing the truth of a proposition.

********* 2.1.5 Semantics

          - Semantics of predicate logic
            can be established by Tarski's model theory.

          - In intuitionistic type theory,
            Semantics is BHK-interpretation of logic.

          - Tarski semantics is usually presented meta-mathematically,
            and assumes set theory.

          - Martin-Löf’s meaning theory of intuitionistic type theory
            should be understood directly and "pre-mathematically",
            that is, without assuming a meta-language such as set theory.

********* 2.1.6 A functional programming language

          - different from normal functional programming language :
            1. it has dependent types
            2. all typable programs terminate

******* 2.2 The Curry-Howard Correspondence

******* 2.3 Sets of Proof-Objects

        - x -
          proof theory.
          program is record of deduction steps i.e. proof.

******* 2.4 Dependent Types

******* 2.4 Propositions as Types in Intuitionistic Type Theory

        - With propositions as types,
          predicates become dependent types.
          For example, the predicate Prime(x)
          becomes the type of proofs that x is prime.

        - example :
          #+begin_src jojo
          (-> (: :m N) -- (: :n N) :m :n LT, :n Prime)
          #+end_src

        - x -
          in my sequent calculus :
          #+begin_src jojo
          [∀ m : N, ∃ n : N ...]
          (-> (: :m N)
           -- (: :n N) ...)

          [∃ n : N ...]
          (->
           -- (: :n N) ...)

          [∀ m : N, ∃ n : N, ∀ p : N ...]
          (-> (: :m N)
           -- (: :n N)
              (-> (: :p N)
               -- ...))

          [∀ m : N, ∃ n : N, ∀ p : N, ∃ q : N ...]
          (-> (: :m N)
           -- (: :n N)
              (-> (: :p N)
               -- (: :q N) ...))
          #+end_src

***** 3. Basic Intuitionistic Type Theory

******* 3.1 Judgments

        - In Martin-Löf (1996)
          a general philosophy of logic is presented
          where the traditional notion of judgment
          is expanded and given a central position.
          A judgment is no longer just an affirmation
          or denial of a proposition,
          but a general act of knowledge.

******* 3.2 Judgment Forms

        - four forms of judgment :
          1. A : type   -- A is a well-formed type
          2. a : A      -- a has type A
          3. A = A'     -- A and A' are equal types
          4. a = a' : A -- a and a' are equal elements of type A

******* 3.3 Inference Rules

        - rules about type formers [type-constructors]
          are classified as :
          1. formation
          2. introduction
          3. elimination
          4. equality

******* 3.4 Intuitionistic Predicate Logic

        - take Π as an example :

          - formation

          - introduction

          - elimination
            #+begin_src jojo
            (: f (-> (: x A) -- B)) (: a A)
            ----------------------------------------
            (: a f B [x := a])
            #+end_src

            - x -
              in (: f (-> (: x A) -- B))
              B is not a type but only a syntactic form
              x might occurs in B
              this is why those rules are not good

          - equality

******* 3.5 Natural Numbers
******* 3.6 The Universe of Small Types
******* 3.7 Propositional Identity
******* 3.8 The Axiom of Choice is a Theorem

***** 4. Extensions

******* 4.1 The Logical Framework
******* 4.2 A General Identity Type Former
******* 4.3 Well-Founded Trees
******* 4.4 Iterative Sets and CZF
******* 4.5 Inductive Definitions
******* 4.6 Inductive-Recursive Definitions

***** 5. Meaning Explanations

******* 5.1 Computation to Canonical Form
******* 5.2 The Meaning of Categorical Judgments
******* 5.3 The Meaning of Hypothetical Judgments

***** 6. Mathematical Models

******* 6.1 Categorical Models
******* 6.2 Set-Theoretic Model
******* 6.3 Realizability Models
******* 6.4 Model of Normal Forms and Type-Checking

***** 7. Variants of the Theory

******* 7.1 Extensional Type Theory
******* 7.2 Univalent Foundations and Homotopy Type Theory
******* 7.3 Partial and Non-Standard Type Theory
******* 7.4 Impredicative Type Theory
******* 7.5 Proof Assistants

*** intuitionistic type theory -- from wikipedia

***** MLTT71

      - was the first of type theories created by Per Martin-Löf.
        It appeared in a preprint in 1971.
        It had one universe
        but this universe had a name in itself,
        i.e. it was a type theory with,
        as it is called today, "Type in Type".

      - Jean-Yves Girard has shown that
        this system was inconsistent
        and the preprint was never published.

***** MLTT72

      - was presented in a 1972 preprint
        that has now been published.

        - Per Martin-Löf,
          An intuitionistic theory of types,
          Twenty-five years of constructive type theory
          (Venice,1995),
          Oxford Logic Guides, v. 36, pp. 127--172,
          Oxford Univ. Press, New York, 1998

      - That theory had one universe V and no identity types.
        The universe was "predicative" in the sense that
        the dependent product of a family of objects
        from V over an object that was not in V
        such as, for example, V itself,
        was not assumed to be in V.

      - The universe was a-la Russell,
        i.e., one would write directly "T∈V" and "t∈T"
        (Martin-Löf uses the sign "∈" instead of modern ":")
        without the additional constructor such as "El".

***** MLTT73

      - It was the first definition of a type theory
        that Per Martin-Löf published.

        - Per Martin-Löf,
          An intuitionistic theory of types: predicative part,
          Logic Colloquium '73 (Bristol, 1973), 73--118.
          Studies in Logic and the Foundations of Mathematics,
          Vol. 80, North-Holland, Amsterdam,1975

      - There are identity types which he calls "propositions"
        but since no real distinction
        between propositions and the rest of the types is introduced
        the meaning of this is unclear.

      - There is what later acquires the name of J-eliminator
        but yet without a name (see pp. 94–95).

      - There is in this theory an infinite sequence of universes
        V0, ..., Vn, ...
        The universes are predicative, a-la Russell
        and non-cumulative!
        In fact, Corollary 3.10 on p. 115 says that
        if A ∈ Vm and B ∈ Vn are such that
        A and B are convertible then m = n.
        This means, for example, that
        it would be difficult to formulate univalence in this theory,
        there are contractible types in each of the Vi
        but it is unclear how to declare them to be equal
        since there are no identity types
        connecting Vi and Vj for i≠j.

***** MLTT79

      - It was presented in 1979 and published in 1982.

        - Per Martin-Löf,
          Constructive mathematics and computer programming,
          Logic, methodology and philosophy of science, VI
          (Hannover, 1979), Stud.
          Logic Found. Math., v. 104, pp. 153--175, North-Holland,
          Amsterdam, 1982

      - This is a very important and interesting paper.
        In it Martin-Löf introduced the four basic types of judgement
        for the dependent type theory
        that has since became fundamental
        in the study of the meta-theory of such systems.

      - He also introduced contexts as a separate concept in it
        (see p. 161).
        There are identity types with the J-eliminator
        (which already appeared in MLTT73
        but did not have this name there)
        but also with the rule that makes the theory "extensional"
        (p. 169).
        There are W-types.
        There is an infinite sequence of predicative universes
        that are cumulative.

***** Bibliopolis

      - There is a discussion of a type theory
        in the Bibliopolis book from 1984

        - Per Martin-Löf,
          Intuitionistic type theory, Studies in Proof Theory.
          Lecture Notes, v. 1, Notes by Giovanni Sambin, pp. iv+91, 1984

      - but it is somewhat open-ended
        and does not seem to represent a particular set of choices
        and so there is no specific type theory associated with it.

*** Girard's paradox

    #+begin_src jojo

    #+end_src
