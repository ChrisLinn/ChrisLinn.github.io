* a useful language first

  - change sequent0 form an interpreter to a compiler

  - compile-time type-check needs run-time

* form an interpreter to a compiler

  - x ::
       我們需要設計一個 vm
       然後編譯到這個 vm 的 byte code
       難點在於 嵌套的函數體中的 uni-id
       現在的處理方式是
       name 下保存的是 pre-jojo 等等
       [用 jojo 泛指 jojo arrow lambda 等等 可嵌套者]
       call 一個 name 時
       uni-copy 遍歷 pre-jojo 以生成 jojo

  - k ::
       這裏語言的解釋性非常明顯
       因爲 處理 jojo 時
       有很多 runtime-dispatching
       做 dispatch 的是 explainer
       這樣做的效果是
       一個 name 下的 jojo 可以被不同的 explainer 做不同的處理

  - x ::
       但是我們知道這種看似靈活的方式 可能其實是不需要的
       在編譯時 就可以完全決定生成碼的函數體中
       是要調用那個函數 作用於哪些參數

  - k ::
       我們可以看一下別的語言是如何處理這些 uni-id 的
       可能都是在編譯時被編譯成了對棧的 peek 和 put
       [pop push peek put]
       甚至編譯成了 native code 而能夠分配寄存器

  - x ::
       我們可以把所有的 stack 都用 list 實現
       當需要的時候再優化爲 array
       前幾個版本中 antecedent 可以實現爲 jojo
       讓它在運行時動態生成數據
       [而不用編譯時 生成 antecedent 之數據]

  - k ::
       可以先爲帶有 gc 的語言寫 vm
       首先是 scheme 然後是 js

  - x ::
       沒錯
       這樣初期的版本就可以很快

* interpreter

  - x ::
       我覺得上面的想法還是太難了
       我們應該接着在日本寫的 scheme 版的 sequent0
       把這個解釋器寫完 看看效果如何
       看看這種

  - k ::
