#+title: homology-note

* note

   - pattern match is about reverse and reversible function
     we need to learn more about reverse and dual

   - ><><><
     in a practical langauge
     beside algebraic datatype
     there is also record
     which is used as the named product type
     some interface functions can be generated by these names
     - I need to designed syntax for this too
       maybe {} should be used for them

   - if type can be generated
     then we have many ways to define a type
     - thus how a type is defined
       should be part of the metadata of a type
     - thus how a function is defined
       should also be part of the metadata of a function

   - meta programming is about macro
     when we are able to write macro
     how should we type macro

   - to be constructive
     a quotient space should be defined by a natural-projection
     maybe fiber bundle should also be defined by projection

   - ><><><
     the gluing of adjunction is the same as
     that of the gluing of fibers ?

* ----------------------------------
* the extension problem

  #+begin_src scheme
  (define inclusion
    (lambda (-> [(: :a type) (: :x type)
                 (< :a :x) drop]
                (-> :a :x))
      (-> [:a :x]
          (lambda (-> :a :x)
            (-> :v :v)))))

  ;; in the view of sze-tsen-hu
  ;; extension problem is the main kind of general problem of topology

  ;; to solve the extension problem
  ;; is to solve an equation in the continuous function space
  ;; is to find x for given condition

  (define g
    (lambda (-> [(< A X) drop A]
                Y)
      ...))

  (define f
    (lambda (-> X
                [Y (== [g]
                       [A X inclusion @ f])])
      ...))
  #+end_src

* the method of algebraic topology

  - to induce algebraic equation from continuous equation
    is the method of algebraic topology

  #+begin_src scheme
  (define H/induce
    (lambda (-> []
                [])
      (-> []
          [])))

  ;; should act like the following
  ;;   this means the language must be powerful enough
  ;;   to handle function have type (-> [...] [...])
  ;;   it is serious meta programming

  (define g
    (lambda (-> [{< A X} A]
                Y)
      ...))

  (define f
    (lambda (-> X
                [Y (== [g]
                       [A X inclusion @ f])])
      ...))

  (define [g H/induce]
    (lambda (-> [{< A X} A empty-space :m H]
                [Y empty-space :m H])
      ...))

  (define [f H/induce]
    (lambda (-> [X empty-space :m H]
                [Y empty-space :m H
                   (== [g H/induce]
                       [A X inclusion @ H/induce f H/induce])]))
    ...)

  ;; many styles pf homology theory
  ;;   which is the best for implementation

  ;; without serious meta programming power
  ;;   we can try the following limited definition of homology theory

  (define H
    (lambda (-> [(: :X space) (< :A :X) int]
                abelian-group)
      ...))

  (define H/induce
    (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                (-> [:X :A :q H] [:Y :B :q H])))
    (note H 作用於空間本身
          還需要一個 H* 作用於空間中的元素)
    (note 可能需要一個選擇函數
          來從 由 H* 得到的 abelian-group 中的元素
          選擇一個原來 space 中的元素
          這樣 實現 H/induce 就簡單了))

  (define boundary
    (lambda (-> [:X :A :q H]
                [:X empty-space :q 1 sub H])
      ...))
  #+end_src

* retraction

  #+begin_src scheme
  (define r
    (lambda (-> X
                [A (== [A id] [A X inclusion @ r])])
      ...))

  (define [r H/induce]
    (lambda (-> [X empty-space :m H]
                [A empty-space :m H
                   (== [A empty-space :m H id]
                       [A X inclusion @ H/induce r H/induce])])
      ...))
  #+end_src

* note quotient space

  - to define a quotient space
    is to lessen the equality

  - the construction of quotient space
    is also called topological identification

  - there are many patterns by which we can re-implement equality of a type

  - when one is trying to formalize a concept in math
    he should try to use all the implementation tech
    and all the language paradigms

  - but it seems we have a basic uniformed equality in the term-lattice
    re-implement of equality is to be built on top of it

* quotient/natural-projection

  - which can always be done by natural-projection

  #+begin_src scheme
  (define quotient/natural-projection
    (lambda (-> [(: :x type) (-> :x :y)]
                (: :z type))
      (-> [:x :p]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        [:a :p @ :b :p @ :y.eq @])}
           :z])))

  (define npj
    (lambda (-> [(: :x type) (: :z type) {/ :x :z}]
                (-> :x :z))
      (-> [:x :z]
          (lambda (-> :x :z)
            (-> :v :v)))))
  #+end_src

* quotient/acting-group

  #+begin_src scheme
  (define quotient/acting-group
    (lambda (-> [(: :x type) (< :g (-> :x :x))]
                (: :z type))
      (-> [:x :g]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        [{= :e (search :g)} :a :e @ :b :x.eq @])}
           :z])))
  #+end_src

* quotient/identity-element

  - by enlarging zero (or one) in algebraic structure

  #+begin_src scheme
  (define quotient/identity-set
    (lambda (-> [(: :x type) {with-interface sub :x} (< :x0 :x)]
                (: :z type))
      (-> [:x :x0]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        {: [:a :b sub] :x0})}
           :z])))
  #+end_src

* ><><>< adjunction space

  #+begin_src scheme
  (define adjoin
    (lambda (-> [(: :x type) (: :y type) (-> [:a {< :a :x}] :y)]
                (: :z type))
      (-> [:x :y :g]
          [{= :z (derive (+ :x :y))}
           {= :z.eq (lambda (-> [:z :z] bool)
                      (-> [:a :b]
                          [{} ><><><]))}
           :z])))
  #+end_src

* >< extension equal to retraction of adjunction

  #+begin_src scheme
  (~ g : ((A < X) -> Y))

  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion @ r)))
  (~ f : (X -> Y
            (g = A X inclusion @ f))
     (:x -> :x p r))

  (~ f : (X -> Y
            (g = A X inclusion @ f)))
  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion @ r))
     ><><><)
  #+end_src

* >< mapping cylinder

  #+begin_src scheme
  (define f (lambda (-> X Y) ...))

  (define mapping-cylinder/p
    (lambda (-> (+ (X I) Y) [f mapping-cylinder])
      (-> [:x 1] [:x f])
      (-> [:x :i] [:x :i])
      (-> :y :y)))
  #+end_src

* ----------------------------------
* >< from chain-complex to homology

* >< the cat of top

  - for the cat of top
    a top constructor is defined by
    specifying set-level construction
    and specifying the open set or closed set

* >< cell-complex

  - CW-complex
    C for closure-finite
    W for weak-topology

* ----------------------------------
* note fiber space

* covering homotopy property

  #+begin_src scheme
  p : E -> B
  project : total-space -> base-space

  (define f (lambda (-> X B) ...))

  (~ f/homotopy : (X -> B))

  ;; cover is defined by abstract interface
  (~ cover )
  (~ f p cover : (X -> E
                    (p f p cover = f)))
  #+end_src

* ----------------------------------
* note continuous

  - to say a map is continuous
    is to allow it to be used in the language

* set

*** note set theory vs type theory

    - ><
      what is this vs ?

    - class (in oo) is encoded by a list of interface functions
      type-class (in haskell) is encoded by a list of abstract interface functions
      which all seem like the dual of the poset structure of set as cat

    - the methods of set theory have no fault
      the fault is to not to view them with implementation in mind

*** the encoding of type

    #+begin_src scheme
    (define-type T
      T.C = [(c1 : (* -> T))
             (c2 : (* -> T))]
      T.G = [(g1 : (term -> bool))
             (g2 : (term -> bool))]
      T.I = [(i1 : (T -> *))
             (i2 : (T -> *))
             (note
               interface functions are implemented by term rewriting)
             (note
               interface can be limited by type-cless)])

    (T1 < T2 :=
        T1.C < T2.C
        T1.G > T2.G)

    (note
      T1.I < T2.I
      T1 is a quotient space of T2)

    (note
      comparing can only be done by comparing list of names
      or declared relation between names
      (naming itself is also a declaration))

    (note
      names are made as unique as possible
      this labor can be easied by a module-system or infer-system)

    (note
      constructor can be shared by different types
      thus can not infer a unique type from a constructor
      thus cut needs to do search and backtracing)

    ;; in the view of
    ;; function as proof and type as theorem and space

    (note
      union of two types as a list of glue operations
      intersection in the two types will intro new connection
      continuous is all about levels of glues
      maybe the main formal law of continuous condition is hidden in the union)

    (define-function union)
    (define-function intersection)

    (note
      the formalization of gluing
      must be with detailed info about the the gluing is done
      if i view union as gluing
      the info will be denoted by the global-naming-as-mark
      two types with the same constructor can still be seprated or not ?)

    (note
      to define a named type
      is to intro a named level structure over the space of terms)
    #+end_src

*** image and inverse-image of function

    #+begin_src scheme
    (~ f : (X -> Y))
    (+ A < X)
    (+ B < Y)
    (+ B inverse f = ((:x : X) {:x f : B}))
    (+ A f = ({:x : A} (:x f : Y)))
    #+end_src

*** >< cartesian product

    - cartesian product of two type is a special case of
      general cartesian product
      which is the space of section of fiber bundle
      (i.e. dependent function space)
      (not the total space)

    - actually we can see
      the dependent function space is not about fiber bundle
      but only about general cartesian product
      to get fiber bundle we need more info

* >< topology

*** note

    - ><
      how this would improve my understanding of
      the formalization of continuous function in my language

    - how the concept of continuous is formalized by abstract axioms of topology
      not only by open set but by the union and intersection functions

*** >< abstract axioms of topology structure

* ----------------------------------
* homology

*** definition

    #+begin_src scheme
    (define H
      (lambda (-> [(: :X space) (< :A :X) int]
                  abelian-group)
        ...))
    (define H/induce
      (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                  (-> [:X :A :q H] [:Y :B :q H])))
      ...)
    (define boundary
      (lambda (-> [:X :A :q H]
                  [:X empty-space :q 1 sub H])
        ...))

    (define co-H
      (lambda (-> [(: :X space) (< :A :X) int]
                  abelian-group)
        ...))
    (define co-H/induce
      (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                  (-> [:Y :B q co-H] [:X :A q co-H]))
        ...))
    (define co-boundary
      (lambda (-> [:X empty-space :q 1 sub co-H]
                  [:X :A :q co-H])
        ...))
    #+end_src

*** >< axioms

    #+begin_src scheme
    (define H/identity
      (lambda (-> [{: :id (-> [:X :A] [:X :A])} :id space/iso {: :q int}]
                  [:id :q H/induce abelian-group/iso])
        ...))

    (define H/compose
      (note
        this is always true
        for H/induce is recursively defined over function composition))
    #+end_src

* ----------------------------------
