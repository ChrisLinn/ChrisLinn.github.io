#+title: algebraic-topology-1 holding

* leaning path

  - fiber-space -> hopf-fibration ->
    cutting-and-regluing -> dehn-surgery -> lens-space ->
    thurston's teach -> hyperbolic geometry -> projective geometry

  - hopf-fibration -> GA and SO(3) -> matrix group

* about classical construction

  - There are many ways to do classical constructions in algebraic topology.
    One who wishes to design a formal language for algebraic topology,
    must choose carefully which to implement,
    which concept to include in, and which concept to hold still,
    while waiting for a better understanding of
    how constructive the concept is.

* immersion and embedding

  - map of type (-> A B)
    is an immersion of A in B.

  - with the 'no self-intersection' condition,
    the map is an embedding,
    B is the ambient space.

  - If the embedding is to be expressed at all,
    the sphere-3 defined as with no non-trivial path
    will be not enough for embedding.

  - Thus distinction between constructions of the same space
    must be maintained.

  - Or we must be able to intro subdivision locally.
    for example, to intro a path in a surface,
    which connects two point on the boundary of the surface.

* hopf fibration

  - The dependent product of sphere-1 and a circle in sphere-2
    is a torus fibered as a circle of sphere-1 linked together
    as hopf links.

    | base-space (S2) | total-space (S3) |
    |-----------------+------------------|
    | a point         | a circle         |
    | two points      | two hopf links   |
    | a path          | a hopf band      |
    | a circle        | a torus (*)      |
    | half S2         | a solid torus    |

  - A hopf band is a surface whose boundary are hopf links,
    in hopf fibration, there are full of such surfaces.

  - The torus with (*) in the table
    might be useful for the construction of hopf-fibration of S3
    by Dehn surgery.

  - Can I construct the solid torus first by half S2 ?

  - I must be able to express the facts above in my language.

  #+begin_src scheme
  (def I
    (type space
      i0 i1 (-1 <>)
      i01 (0 i0 i1)))

  (def sphere-1
    (type (-> space)
      b1 (-> (-1 <>))
      loop (-> (0 b1 b1))))

  (* sphere-1 I)
  (* b1 i0)    : (-1 (* sphere-1 I))
  (* b1 i1)    : (-1 (* sphere-1 I))
  (* b1 i01)   : (* b1 (0 i0 i1))
  -->            (0 (* b1 i0) (* b1 i1))
  (* loop i0)  : (* (0 b1 b1) i0)
  -->            (0 (* b1 i0) (* b1 i0))
  (* loop i1)  : (* (0 b1 b1) i1)
  -->            (0 (* b1 i1) (* b1 i1))
  (* loop i01) : (+ (* loop (0 i0 i1)) (* (0 b1 b1) i01))
  -->            (+ (1 (* loop i0) (* loop i1) rev)
                    (1 (* b1 i01) (* b1 i01) rev))
  -->            (1 (* loop i0) (* b1 i01)
                    (* loop i1) rev (* b1 i01) rev)

  (? sphere-1 I)
  (? b1 i0)    : (-1 (? sphere-1 I))
  (? b1 i1)    : (-1 (? sphere-1 I))
  (? b1 i01)   : (? b1 (0 i0 i1))
  -->            (0 (? b1 i0) (? b1 i1))
  (? loop i0)  : (? (0 b1 b1) i0)
  -->            (0 (? b1 i0) (? b1 i1))
  (? loop i1)  : (? (0 b1 b1) i1)
  -->            (0 (? b1 i1) (? b1 i0))
  (? loop i01) : (1 (? loop i0)
                    (? loop i1))

  (def sphere-1
    (type (-> space)
      b1 (-> (-1 <>))
      loop (-> (0 b1 b1))))

  (def sphere-2
    (type (-> space)
      b2 (-> (-1 <>))
      surf (-> (1 b2 refl))))

  (* sphere-2 sphere-1)
  (* b2 b1)     : (-1 (* sphere-2 sphere-1))
  (* b2 loop)   : (* b2 (0 b1 b1))
  -->             (0 (* b2 b1) (* b2 b1))
  (* surf b1)   : (* (1 b2 refl) b1)
  -->             (1 (* b2 b1) refl)
  (* surf loop) : (+ (* surf (0 b1 b1))
                     (* (1 b2 refl) loop))
  -->             (+ (2 (* surf b1) (* surf b1))
                     (2 (1 (* b2 loop)) refl))
  -->             (2 (* surf b1) (* surf b1)
                     (1 (* b2 loop)) refl)

  (? sphere-2 sphere-1)
  (? b2 b1)     : (-1 (? sphere-2 sphere-1))
  (? b2 loop)   : (? b2 (0 b1 b1))
  -->             (0 (? b2 b1) (? b2 b1))
  (? surf b1)   : (? (1 b2 refl) b1)
  -->             (1 (? b2 loop))
  (? surf loop) : (+ (? surf (0 b1 b1))
                     (? (1 b2 refl) loop))
  #+end_src

* lens-space

  - how can we do a cutting-and-regluing
    to cut (* sphere-1 sphere-2)
    and to reglue it to sphere-3

  - is this the same as hopf fibration

  - what lens-space are equal to ?

  - different ways to construct lens-space
    - dehn-surgery
      - note that, we have a change of dim here
    - ><><><

* the plan

  - Inspired by Bishop's plan
    and the treatment of algebraic-topology by sze-tsen-hu.

  - A concept is defined once we explain how to implement it in our language.
    - Just like in physics, a concept is operationally defined,
      once we explain how to measure it.

  - To define property of object
    by the solvability of problem fromed around the object.

* same-position-self-gluing, cancel or not cancel ?

  - same-position-self-gluing
    [for example: p * p^{-1}]

  - non-same-position-self-gluing
    can only happen,
    when there is at least one part of the boundary is repeating.
    [for example: p * p]

  - [cancel or not cancel ?]
    when building a cylinder,
    the boundary of the surface must be a circle,
    thus part of the same-position-self-gluing of a path
    can not be canceled !

* geometry

  - How to intro geometry back to a language for AT ?
    by giving path a length ? surface an area ?
    or by a general structure for all the measurement ?

* adjunction-space

  - 是否在 at1 中引入 adjunction-space ?
    作爲一種構造新空間的方式 ?

  - 注意
    cell-complex 中的 characteristic-map 就是 adjunction-space

* local-subdivision

  - With the syntax for local-subdivision,
    maybe we can prove the mapping-class-group of cell is trivial.

  - 可以利用 local-subdivision 來恢復 topology structure 嗎 ?

* dehn 的方法

  - x -
    dehn 的方法在於
    在曲面上給出一個座標系
    使得密布曲面的嵌入曲線得以代數表示
    因爲曲線是密布曲面的
    所以這個代數結構的變換羣就是曲面的映射類羣

* 映射類羣

  - x -
    disk[cell] is special,
    for its mapping-class-group is trivial.
    is this the reason why cell-complex is built by cells ?

  - k -
    首先我們需要知道如何在 at1 中定義映射類羣
    並且要知道我們的定義是良好的

  - x -
    也就是說 我們必須給我們的形式語言以古典基礎
    - 古典的定義是開端 它們定義了研究對象
      爲了探究這些對象的某些性質
      我們發現略去古典定義中的大部分信息
      就可以簡化我們所使用的語言
    - 我們想要直接使用這個更簡的語言
      但是這需要辯護
      我們需要證明這個更簡的語言是對原語言的有效簡化
      而不會有不一致的地方
    - 我們並不棄幾何而只看拓撲
      也不棄拓撲而只看代數
      我們要明確這些不同的語言之間的關係
      作爲語言的設計者和理論的提出者
      我們還要不斷地對比不同語言 就解決問題而言之優劣

  - k -
    古典定義之所以爲 '古典'
    是因爲人們已經如此習以爲常
    以至於略去了這些概念的啓發性例子
    和這些概念之形成的歷史語境

* 如何處理同倫中維數的變化

  - x -
    認爲路的寬度不是零而是無窮小何如

  - k -
    我想在 at1 中維度的變化主要體現在 refl 這個操作上

  - x -
    我們先來總結一些現象吧
    (1)
    首先 (x refl) 可以被理解爲單位元 [也就是說可以隨時消去和引入]
    並且 (x refl boundary boundary) = 0
    因爲 (x refl boundary) = (+ x x rev)
    (2)
    其次 計算 cylinder 的 mapping-class-group 時
    所給出的扭轉
    在 at1 中看起來是把一部分面積給擠壓掉了
    可能需要用無窮小量來理解這種映射

* 非標準分析

  - x -
    我們開始學習 非標準分析
    嘗試用它來解決 形式化的同倫論中的維數變化問題

  - k -
    並且 要知道
    非標準分析 也是爲古典的領域設計新語言的一個例子

  - x -
    我想 看看古典的著作中作者是如何依直覺使用無窮小量的
    也許會有益於我們的學習

  - k -
