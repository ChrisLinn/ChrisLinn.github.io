#+title: algebraic-topology-1 holding

* todo

  - to develop a homotopy thoery in AT1

  - fix the syntax of homotopy group and relative-homotopy group

  - cylinder torus and MCG of dehn

* leaning path

  - fiber-space -> hopf-fibration

  - hopf-fibration -> cutting-and-regluing -> dehn-surgery -> lens-space ->
    thurston-s-teaching -> hyperbolic geometry -> projective geometry

  - hopf-fibration -> GA and SO(3) -> matrix group

  - classical-background -> cobordism

  - classical-background -> dimension-down

  - dimension-down -> infinitesimal -> non-standard-analysis

  - infinitesimal -> leibniz euler newton

  - hopf-fibration -> H-space -> hopf-invariant -> hopf-algebra

* about classical construction

  - There are many ways to do classical constructions in algebraic topology.
    One who wishes to design a formal language for algebraic topology,
    must choose carefully which to implement,
    which concept to include in, and which concept to hold still,
    while waiting for a better understanding of
    how constructive the concept is.

* immersion and embedding

  - map of type (-> A B)
    is an immersion of A in B.

  - with the 'no self-intersection' condition,
    the map is an embedding,
    B is the ambient space.

  - If the embedding is to be expressed at all,
    the sphere-3 defined as with no non-trivial path
    will be not enough for embedding.

  - Thus distinction between constructions of the same space
    must be maintained.

  - Or we must be able to intro subdivision locally.
    for example, to intro a path in a surface,
    which connects two point on the boundary of the surface.

* the plan

  - Inspired by Bishop's plan
    and the treatment of algebraic-topology by sze-tsen-hu.

  - A concept is defined once we explain how to implement it in our language.
    - Just like in physics, a concept is operationally defined,
      once we explain how to measure it.

  - To define property of object
    by the solvability of problem fromed around the object.

* same-position-self-gluing, cancel or not cancel ?

  - same-position-self-gluing
    [for example: p * p^{-1}]

  - non-same-position-self-gluing
    can only happen,
    when there is at least one part of the boundary is repeating.
    [for example: p * p]

  - [cancel or not cancel ?]
    when building a cylinder,
    the boundary of the surface must be a circle,
    thus part of the same-position-self-gluing of a path
    can not be canceled !

* geometry

  - How to intro geometry back to a language for AT ?
    by giving path a length ? surface an area ?
    or by a general structure for all the measurement ?

* classical mechanics

  - 引入幾何的同時
    可否像利用微分流形來處理經典力學一樣
    利用 cell-complex-structure 來處理經典力學 ?
    利用 cell-complex-structure 描述空間的同時
    還要描述空間中的運動

  - 如何在 cell-complex-structure 上引入座標系 ?
    是否應該引入座標系 ?
    這對描述運動而言是否是必要的

* adjunction-space

  - 是否在 at1 中引入 adjunction-space ?
    作爲一種構造新空間的方式 ?

  - 注意
    cell-complex 中的 characteristic-map 就是 adjunction-space

* local-subdivision

  - With the syntax for local-subdivision,
    maybe we can prove the mapping-class-group of cell is trivial.

  - 可以利用 local-subdivision 來恢復 topology structure 嗎 ?

  - continuum 的一個直觀特徵是
    可以被潛在無限地細分
    local-subdivision 就是爲了捕捉這個特徵

  - they may be divided anywhere,
    though they cannot be divided everywhere at the same time.

* dehn 的方法

  - x -
    dehn 的方法在於
    在曲面上給出一個座標系
    使得密布曲面的嵌入曲線得以代數表示
    因爲曲線是密布曲面的
    所以這個代數結構的變換羣就是曲面的映射類羣

* 映射類羣

  - x -
    disk[cell] is special,
    for its mapping-class-group is trivial.
    is this the reason why cell-complex is built by cells ?

  - k -
    首先我們需要知道如何在 at1 中定義映射類羣
    並且要知道我們的定義是良好的

  - x -
    也就是說 我們必須給我們的形式語言以古典基礎
    - 古典的定義是開端 它們定義了研究對象
      爲了探究這些對象的某些性質
      我們發現略去古典定義中的大部分信息
      就可以簡化我們所使用的語言
    - 我們想要直接使用這個更簡的語言
      但是這需要辯護
      我們需要證明這個更簡的語言是對原語言的有效簡化
      而不會有不一致的地方
    - 我們並不棄幾何而只看拓撲
      也不棄拓撲而只看代數
      我們要明確這些不同的語言之間的關係
      作爲語言的設計者和理論的提出者
      我們還要不斷地對比不同語言 就解決問題而言之優劣

  - k -
    古典定義之所以爲 '古典'
    是因爲人們已經如此習以爲常
    以至於略去了這些概念的啓發性例子
    和這些概念之形成的歷史語境

* 如何處理同倫中維數的變化

  - x -
    認爲路的寬度不是零而是無窮小何如

  - k -
    我想在 at1 中維度的變化主要體現在 refl 這個操作上

  - x -
    我們先來總結一些現象吧
    (1)
    首先 (x refl) 可以被理解爲單位元 [也就是說可以隨時消去和引入]
    並且 (x refl boundary boundary) = 0
    因爲 (x refl boundary) = (+ x x rev)
    (2)
    其次 計算 cylinder 的 mapping-class-group 時
    所給出的扭轉
    在 at1 中看起來是把一部分面積給擠壓掉了
    可能需要用無窮小量來理解這種映射

* 非標準分析

  - x -
    我們開始學習 非標準分析
    嘗試用它來解決 形式化的同倫論中的維數變化問題

  - k -
    並且 要知道
    非標準分析 也是爲古典的領域設計新語言的一個例子

  - x -
    我想 看看古典的著作中作者是如何依直覺使用無窮小量的
    也許會有益於我們的學習

* embedding 與 homotopy

  - x -
    MCG 中的映射是 X 到自身的 embedding
    但是 把面积挤压到邊界的映射並非 embedding
    但是我必須要允許這種映射
    因爲在我的形式化語言中 我想象不出別的選擇

  - k -
    這個被擠壓的映射 與某個不被擠壓的映射同倫
    因此只有 在 homotopy 下 我們才能完成形式化

* refl

  - x -
    可以想象 refl 所生成的空間不在原空間內

* 關於邊界

  - x -
    同一個拼接起來的形狀
    可能有多種不同的 描述其邊界的方式
    比如
    cylinder 的 mapping-class-group 涉及到了同一個 space 的不同邊界描述

* homology

  - x -
    也許需要先在 at1 中發展出 homology theory
    畢竟 homology 更簡單

* the use of fibration in homotopy group

  - x -
    這應該是被優先考慮的
    畢竟 fiber-space 的形式處理 一定要能夠捕捉這種應用

* classical view

*** cell-complex 的映射

    - cell-complex 之間的映射是一次指定一個 cell 的
      因爲在 homotopy equivalent 下
      固定邊界後 cell 之間的映射只能有一種情況

* >< how to define function in synthetic geometry ?

* a new plan

  - a synthetic homotopy theory with axioms;
    and a implementation as its model.

  - calculation of many different types of (co)homotopy and (co)homology,
    might be done in an intrinsic way.

  - to calculate
    mapping-class-group
    homotopy-group
    homology-group
    dRham-co-homology-group

* x 對數學的奇怪印象

  - x -
    數學本應該是最清晰的藝術於學科
    在以綜合法學習歐氏幾何或者射影幾何的時候
    我能感受到這一點
    甚至在用無窮小分析來研究物理現象的時候
    我也能感受到這一點
    但是爲什麼在學習現代數學的時候
    我確恰恰有相反的印象呢 ?
    爲什麼我總覺得所學到的前人的著述如此晦澀
    以至學來無樂呢 ?

  - k -
    欲究其因
    方向有二
    其一在己
    其二在乎他人

  - x -
    於己 可謂不勤乎
    置之且不論
    於他人之著述
    其有別於先賢者甚矣
    先賢之著 以公理爲本 實例豐富
    每舉例者 必察簡單圖形之有趣性質
    由簡至繁 引人入勝
    而今人所著者
    仿先賢之公理方法 而鮮舉實例
    其法尚一 而不辨細節

  - k -
    對於想要設計的 AT1 來說
    我們能給出良好的類似歐式幾何的 '原本' 嗎 ?

  - x -
    首先 我們有簡單的圖形 即 cell-complex
    其次 我們要找出一些有趣的關係
    最簡單的關係是 映射之間的同倫
    其次是 空間之間的同倫等價
    在這個模型下
    我們可以形成一些定理 來以綜合的方式證明 這兩個關係
    而不用再用定義驗證
    注意 對這些關係的證明都是構造性的
    一個具有一般性的命題 其實就是一個函數
    所謂 綜合的證明 就是用舊的函數構造新的函數

  - k -
    我想首先我們需要
    證明我們的理論是對經典的 CW-complex 理論的有效簡化[公理化]

  - x -
    在這之前 我也可以先發展關於 bundle-space 於 fiber-space 的理論
    並且大致想清楚如何計算 homology-group

* cell-structure of mapping-space

  - mapping-space might not be reduced to [be viewed as] simple-space,
    because a path can not be mapped to a point.

    but we do not need to,
    for the structure of simple-space
    is to make us be able to check continuity of function.

* about equality

  - equality between two elements (: [x0, x1] X),
    is established by a extension-problem
    #+begin_src scheme
    (lambda (-> I X)
      (extend-from
        (lambda (-> (list i0 i1) X)
          (-> i0 x0)
          (-> i1 x1)))
      ...)
    #+end_src

  - equality between two elements (: [f, g] (-> A X)),
    is established by a extension-problem
    #+begin_src scheme
    (lambda (-> (* A I) X)
      (extend-from
        (lambda (-> (* A (list i0 i1)) X)
          (-> (* :a i0) [:a f g])
          (-> (* :a i1) :a)))
      ...)
    #+end_src

  - we know the equality between two spaces (~~ A B)
    #+begin_src scheme
    (: f (-> A B))
    (: g (-> B A))
    (~ [f g] [A id])
    (~ [g f] [B id])

    (lambda (-> (* A I) A)
      (extend-from
        (lambda (-> (* A (list i0 i1)) A)
          (-> (* :a i0) [:a f g])
          (-> (* :a i1) :a)))
      ...)

    (lambda (-> (* B I) B)
      (extend-from
        (lambda (-> (* B (list i0 i1)) B)
          (-> (* :b i0) [:b g f])
          (-> (* :b i1) :b)))
      ...)
    #+end_src

  - but how about equality between two mapping-spaces
    (~~ (-> A X) (-> B Y)) ?

  - the algebraic structure of (-> I X) is given by a function of type
    #+begin_src scheme
    (-> [(-> I X) (-> I X)] (-> I X))
    #+end_src
    what is the equality between algebraic structures ?

  - first, we know that the definition of (~~ A B)
    is to make sure that
    homotopy(n) (A, a0) = homotopy(n) (B, b0)
    [for every definition, we must ask why we intro it this way.]
    thus, the definition of (~~ (-> A X) (-> B Y))
    must also make sure that
    homotopy(n) ((-> A X), a0) = homotopy(n) ((-> B Y), b0)
    there (: a0 (-> A X)) and (: b0 (-> B Y))

  - 子曰
    視其所以
    觀其所由
    察其所安
    人焉廋哉
    人焉廋哉

  - let's see why (~~ A B) implies
    homotopy(n) (A, a0) = homotopy(n) (B, b0)
    we know that
    #+begin_src scheme
    homotopy(n) (A, a0) :=
    (lambda (-> I A)
      (extend-from
        (lambda (-> (list i0 i1) A)
          (-> i0 a0)
          (-> i1 a0)))
      ...)
    ;; and
    homotopy(n) (B, b0) :=
    (lambda (-> I B)
      (extend-from
        (lambda (-> (list i0 i1) B)
          (-> i0 b0)
          (-> i1 b0)))
      ...)
    #+end_src
    and the equality between elements of the group
    is defined as the equality between functions.

  - if we have
    #+begin_src scheme
    (: f (-> A B))
    (: g (-> B A))
    (~ [f g] [A id])
    (~ [g f] [B id])

    (lambda (-> (* A I) A)
      (extend-from
        (lambda (-> (* A (list i0 i1)) A)
          (-> (* :a i0) [:a f g])
          (-> (* :a i1) :a)))
      ...)

    (lambda (-> (* B I) B)
      (extend-from
        (lambda (-> (* B (list i0 i1)) B)
          (-> (* :b i0) [:b g f])
          (-> (* :b i1) :b)))
      ...)
    #+end_src

  - then we can use (: f (-> A B)) to map
    elements in (-> I A) to elements in (-> I B)
    and use (: g (-> B A)) to map
    elements in (-> I B) to elements in (-> I A)

  - we must then prove these two maps
    1. are well defined w.r.t. the equality of the group.
       [this can be proved by homotopy-extension-property]
    2. respect the group production.
       [this can be proved by ><><><]
    3. are revers of each other as group homomorphism.
       #+begin_src scheme
       (: [x, x f g] (-> I A))
       (: (~ x [x f g]) (-> (* I I) A))

       ;; ------------

       (define f
         (lambda (-> A B)
           ...))

       (define g
         (lambda (-> B A)
           ...))

       ;; (~ [f g] (identity-map-of A))
       (define h
         (lambda (-> (* A I) A)
           (extend-from
             (lambda (-> (* A (list i0 i1)) A)
               (-> (* :a i0) [:a f g])
               (-> (* :a i1) :a)))
           (with (-> (* (-1 A) (-1 I)) (-1 A))
             ...)
           (with (-> (* (-1 A) %:a (0 i0 i1))
                     (0 (* :a i0) <>
                        (* :a i1) <>))
             (-> (* a0 (1 i01))
                 (:> (0 (* a0 i0) <>
                        (* a0 i1) <>)
                     (0 a0 f g
                        a0)))
             ...)
           ...))

       ;; (~ [g f] (identity-map-of B))
       (define k
        (lambda (-> (* B I) B)
          (extend-from
            (lambda (-> (* B (list i0 i1)) B)
              (-> (* :b i0) [:b g f])
              (-> (* :b i1) :b)))
          ...))

       (define x
         (lambda (-> I A)
           (extend-from
             (lambda (-> (list i0 i1) A)
               (-> i0 a0)
               (-> i1 a0)))
           ...))

       (define (~ [x f g] x)
         (lambda (-> (* I I) A)
           ;; (extend-from
           ;;   (lambda (-> (* I I) A)
           ;;     (with (-> (* (-1 I) (-1 I)) (-1 A))
           ;;       (-> (* i0 i0) [i0 x f g])
           ;;       (-> (* i1 i0) [i1 x f g])
           ;;       (-> (* i1 i1) [i1 x])
           ;;       (-> (* i0 i1) [i0 x]))
           ;;     (with (-> (* (0 i0 i1) (-1 I) %:i)
           ;;               (0 (* i0 :i) <>
           ;;                  (* i1 :i) <>))
           ;;       (-> (* (1 i01) i0) [(1 i01) x f g])
           ;;       (-> (* (1 i01) i1) [(1 i01) x]))))
           (extend-from
             (lambda (-> (* I (list i0 i1)) A)
               (-> (* :i i0) [:i x f g])
               (-> (* :i i1) [:i x])))
           (with (-> (* (-1 I) %:i (0 i0 i1))
                     (0 (* :i i0) <>
                        (* :i i1) <>))
             (-> (* i0 (1 i01))
                 [(* [i0 x] (1 i01)) h] (=> [(* a0 (1 i01)) h])
                 (:> (0 i0 x f g
                        i0 x)
                     (0 a0 f g
                        a0)))
             ;; how can an element of the above type
             ;; be given by 'h' and 'k' ?
             (-> (* i1 (1 i01))
                 [(* [i1 x] (1 i01)) h] (=> [(* a0 (1 i01)) h])
                 (:> (0 i1 x f g
                        i1 x)
                     (0 a0 f g
                        a0))))
           (with (-> (* (0 i0 i1) %:p0
                        (0 i0 i1) %:p1)
                     (1 (* (1 :p0) i0) <>
                        (* i1 (1 :p1)) <>
                        (* (1 :p0) i1) <> rev
                        (* i0 (1 :p1)) <> rev))
             (-> (* (1 i01) (1 i01))
                 [(* [(1 i01) x] (1 i01)) h]
                 (:> (1 (1 i01) x f g
                        (* i1 (1 i01)) <>
                        (1 i01) x rev
                        (* i0 (1 i01)) <> rev)
                     (1 (1 i01) x f g
                        (* [i1 x] (1 i01)) h
                        (1 i01) x rev
                        (* [i0 x] (1 i01)) h rev))))))

       (define (~ [x f g] x)
         (lambda (-> (* I I) A)
           (extend-from
             (lambda (-> (* I (list i0 i1)) A)
               (-> (* :i i0) [:i x f g])
               (-> (* :i i1) [:i x])))
           (with (-> (* (-1 I) %:i (0 i0 i1))
                     (0 (* :i i0) <>
                        (* :i i1) <>))
             (-> (* i0 (1 i01))
                 [(* [i0 x] (1 i01)) h])
             (-> (* i1 (1 i01))
                 [(* [i1 x] (1 i01)) h] ))
           (with (-> (* (0 i0 i1) %:p0
                        (0 i0 i1) %:p1)
                     (1 (* (1 :p0) i0) <>
                        (* i1 (1 :p1)) <>
                        (* (1 :p0) i1) <> rev
                        (* i0 (1 :p1)) <> rev))
             (-> (* (1 i01) (1 i01))
                 [(* [(1 i01) x] (1 i01)) h]))))
       #+end_src

  - for (~~ (-> A X) (-> B Y))
    1.
    2.
    3.

* to develop a homotopy thoery in AT1

  - x -
    不要着急把這些理論和語法固定下來
    我們還有時間

* about dim

  - (* A B) dim = A dim B dim add

    (-> A X) dim = X dim A dim sub

    (* A B) dim = (-> (* A B)) dim

    (-> (-> A B) C) dim
    = C dim (-> A B) dim sub
    = C dim B dim A dim sub sub
    = C dim A dim add B dim sub
    = (-> B (* A C)) dim

  -

* erlangen program

  - x -
    從 erlangen program 的角度來看
    就一個 cell-complex 而言
    我們考慮的只能是那些在空間自身的連續變換下不變的性質
    連續映射的類型爲 (-> X X) 並且要是滿射
    而空間自身的連續變化 甚至可以改變其部分的維度
    高維元素可以映射到低維元素
    反過來 低維元素是不是也應該可以映射到高維元素 ?

* sad fact

  - x -
    我發現想要拋棄 topological structure
    就必須要先非常熟悉它
    而我對它的學習是爲了讓後人不再學習它
    讓它在我這裏終止

* begin

  - x -
    I begin here.
    And I won't begin in the way
    in which I can ensure to you I won't fall to error.
    I just begin.

* 解決問題

  - x -
    人們被謎題所吸引
    謎題引人思考
    當大家聲稱一個問題被解決了
    人們就不在乎當初人們爲什麼提出這個問題
    也很少在乎解決這個問題的人的動機與方式
    而只在乎這個問題已經被給以了否定或肯定的答案

  - k -
    那麼 AT1 的目的是什麼呢 ?
    不是爲了解決代數拓撲中的問題嗎 ?

  - x -
    我要提供一種新的語言來解釋這些問題
    解決與否並不重要
    最好的情況是 把舊的問題用更好的方式描述來吸引更多人思考
    我想 薩繆里安 說的非常對
    如果 歐幾里得 不是用這種給以每個問題以確切證明的方式來呈現一個幾何學
    而是把這些問題寫成一本有趣的謎題書
    則更好
    因爲當神祕的面紗被揭開
    人們不再思考這些幾何問題的根源了
    除了考試與訓練之外 不再在乎這些問題了
    通過以這種方式揭開面紗
    歐幾里得 抹殺了遊戲的一切快樂
    它使得人們如此懶於思考
    以至於一千多年之後人們才確切地發現非歐幾何之可爲

* 真理

  - x -
    我相信某些東西是對的
    我相信它們果真如此
    我對這種信仰有無比的熱情
    但是同時
    我也相信這些東西有錯的可能
    這些東西可能是假的

  - k -
    這看來並不矛盾
    甚至沒有矛盾的可能
    因爲這並非一個確切的判斷或命題

  - x -
    沒錯
    說 '我相信'
    就代表了這些真理是就我而言的
    說 '可能' 就更模糊了判斷
    使得矛盾成爲不可能了
    如果說
    我相信這隻矛可能是世界上最鋒利的矛 它能戳破一切的盾
    我相信這隻盾可能是世界上最堅固的頓 它能抵擋一切的矛
    而不是說
    這隻矛是世界上最鋒利的矛 它能戳破一切的盾
    這隻盾是世界上最堅固的頓 它能抵擋一切的矛
    那矛盾就讓它矛盾去吧
    只要試試到底誰厲害
    我就馬上改信新的事實
    不相信事實不是愚蠢的嗎

  - k -
    形成理論 但是隨時依照新的經驗來更改理論

  - x -
    沒錯
    我甚至不能否定這種態度
    因爲 當有新的經驗時
    其只所以 稱爲 '新的經驗'
    可能就意味着
    我要利用這些新的經驗來重寫我的理論了

* 辯證法的濫用

  - x -
    對話與辯證法只能用來真誠地討論未知的問題
    而不能就某個問題來自問自答

* topological structure of mapping space

* 對行動力的反思

  - x -
    我的主要活動與思考都是就數學而言的
    當有所得或有所思 而大致知道前進的方向時
    我反而會止步
    這種心理狀態可能正是因爲我受到現代數學方法的荼毒

  - k -
    要知道這些論點是可以利用實驗來驗證的
    你可以嘗試在更古的數學行爲中找找對行動的不同解釋
    但是爲什麼說現代的行動會導致你止步呢

  - x -
    因爲它使得人總是停下來問原因
    總是停下來問抽象的結構
    而不觀察具體的對象

* 代數結構 與 空間之間的同倫等價

  - x -
    首先我總結 AT1 中可能出現代數結構

    (1)
    空間本身作爲高維代數結構
    特點是乘法是沿着公共邊界的 粘合
    高維的元素就是低維元素之間的關係

    (2)
    mapping-space such as
    loop-space and path-space
    作爲代數結構

    (3)
    空間之間的變換作爲代數結構
    空間本身爲元素
    空間之間的同倫等價就是元素之間的相等

    問題是
    如果依我之前所說
    空間之間的同倫等價之定義
    是爲了使得 相互等價的空間有 相互同構的 同倫羣
    那麼別的代數結構
    比如 mapping-class-group 與 同調羣
    如何呢

  - k -
    (1) 是否可以劃歸爲 (2)
    如果有此種劃歸
    那麼 (1) 中高維代數的特點如何表現在 (2) 中呢

  - x -
    可是說 如果做了這樣的劃歸
    那麼 (1) 中多種乘法的特點就被消除了
    假設我有 (: f (-> X A)) 與 (: g (-> Y A))
    我知道 X f bdry 與 Y f bdry 有重合的部分
    考慮這個重合的部分如何把 X Y 粘合成 Z
    我們就得到了 (: j (-> Z A))
    loop-space 中的乘法就是如此獲得的

  - k -
    可否說
    (2) 中處理元素乘法的方式
    是把 (1) 中的某些乘法模式 固定下來了
    並給以了命名

  - x -
    如若如此
    (1) 中所描述的空間之元素高維狂野乘法就是一切的基礎
    而空間的等價正是 (1) 中 元素關係的體現
    注意
    在 (1) 中
    高維元素就是低維元素的關係

  - k -
    如果如此
    也可以說是
    (1) 給出了空間的 groupoid 結構
    而 (2) 給出了描述這個 groupoid 的性質的語言
    那麼
    爲什麼我們需要用 (2) 來定義 同倫羣
    而不能直接在 (1) 所描述的 groupoid 中研究同倫羣呢

  - x -
    利用 (2) 我們描述的是
    groupoid 的 各階 sub-group
    whitehead 的定理就是說
    各階 sub-group 之等價 等同於 groupoid 本身的等價

  - k -
    沒錯

  - x -
    我們現在想要明瞭的是
    目前定義空間同倫等價的方式是否 '正確'
    這個定義是否是 infi-groupoid 之間的同構 ?

  - k -
    whitehead 的定理是說
    (a)
    空間的等價 => 各階同倫羣等價
    就算是這一點我們都沒有搞清楚
    我們之前的形式討論只是說明了
    空間的等價 => 一階同倫羣等價
    對於高階的情況 我們的語言還沒有確定下來
    (b)
    各階同倫羣等價 => 空間的等價
    就這個方向而言
    我們更是要檢驗當前的
    空間之同倫等價 的定義的 '正確' 性

  - x -
    mapping-space 想要有代數結構
    就必須如同 loop-space 一樣特殊
    如果如此
    假設 現在對空間同倫等價的定義是 '正確' 的
    我們現在的語言已經足夠描述 whitehead 的定理了

  - k -
    但是還不足以明確什麼是一般的 mapping-space 之間的同倫等價

  - x -
    沒錯

  - k -
    那我們先看看 infi-groupoid 之間的自然的等價應該如何定義

  - x -
    就是推廣一下 group 的表示 之間的同構的定義 不是嗎 ?

  - k -
    一個連續函數就是一個同態

  - x -
    但是 目前對空間同倫等價的定義看似要比 infi-groupoid 之間的同構要弱
    我們要看看這是否是真的弱
    還是 檢驗 infi-groupoid 之間同構的一個弱化了的準則
    以便檢查起來更方便

  - k -
    首先要知道 (1) 是
    combinatorial infi-groupoid theory
    正如 combinatorial group theory
    我們通過 group 的 generator 和 relation 來研究 group
    在 combinatorial infi-groupoid theory 中
    我們有高階的 relation

  - x -
    我們之間所證明的
    (~~ A B) => (~~ (-> I A) (-> I B))
    只不過是說 在 (-> ... ...) 中
    等價可以替換等價
    但是不同 arrow 形式的空間 不能等價
    比如 (~~ A (-> I B))
    但是我發現 可以把 (~~ A (-> I B)) 定義爲
    A 和 (-> I B) 的所有同倫羣等價
    這樣不同 arrow 形式的空間也能等價了
    也就是說
    定義的序列是
    (a)
    同一個函數空間中元素的等價
    (: [f, g] (-> X A))
    (: (~ f g) (-> (* X I) A))
    特殊地 我們得到了空間之間元素的等價
    (: [f, g] A)
    (: (~ f g) (-> I A))
    (b)
    空間之間的等價
    (: (~~ A B) (and (-> (* A I) A) (-> (* B I) B)))
    (c)
    空間之間的等價 <=> 所有同論羣的等價
    (d)
    利用 所有同論羣的等價 來把空間之間的等價關係從 simple-space
    擴展到 任意 mapping-space

  - k -
    這種定義序列是可行的
    但是這是 '正確的' 嗎

  - x -
    如果我們能證明
    對 simple-space 或這 mapping-space 的同倫羣的定義
    與古典定義相重合
    那麼這就是正確的

  - k -
    回到 combinatorial infi-groupoid theory
    我們首先要證明 空間之間的同倫等價 是 infi-groupoid 之間的同構

  - x -
    首先我們考慮 combinatorial group theory 如何是
    特殊的 combinatorial infi-groupoid theory
    注意
    infi-groupoid theory 可能能夠被劃歸到 infi-group theory
    因爲每個 complex 都可以化爲只有一個點的 complex

  - k -
    infi-groupoid 中乘法之狂野
    是否也能通過這種劃歸來簡化呢

  - x -
    我們先複習 combinatorial group theory

* combinatorial group theory

  - x -
    我們要考慮 algebraic-topology 中的概念
    如何能夠體現在 combinatorial group theory 中
    然後再推廣回 groupoid
    algebraic-topology 中的概念有
    - 同倫等價
    - 同論羣
    - 同調羣
    - 映射類羣
    等等

* 高維代數結構中的乘法

  - 對於高維的乘法 (n ...)
    既然乘法是 '可交換的'
    爲什麼我們還需要相乘的序
    因爲 序 給出指明乘合體中位置的方式

* cutting-and-regluing

  - 用空間 B F 製作 bundle-space 時
    cutting-and-regluing 用
    (-> (*  B' fiber) fiber)
    中的元素完成
    其中 B' 是 B 的低一維子空間
    沿着 B' 要能夠切開 B

* lens-space

  - what lens-space are equal to ?

  - different ways to construct lens-space
    - dehn-surgery

* hopf fibration

  - The dependent product of sphere-1 and a circle in sphere-2
    is a torus fibered as a circle of sphere-1 linked together
    as hopf links.

    | base-space (S2) | total-space (S3) |
    |-----------------+------------------|
    | a point         | a circle         |
    | two points      | two hopf links   |
    | a path          | a hopf band      |
    | a circle        | a torus (*)      |
    | half S2         | a solid torus    |

  - A hopf band is a surface whose boundary are hopf links,
    in hopf fibration, there are full of such surfaces.

  - The torus with (*) in the table
    might be useful for the construction of hopf-fibration of S3
    by Dehn surgery.

  - Can I construct the solid torus first by half S2 ?

  - I must be able to express the facts above in my language.

  #+begin_src scheme
  (define I
    (type space
      i0 i1 (-1 <>)
      i01 (0 i0 i1)))

  (define sphere-1
    (type (-> space)
      b1 (-> (-1 <>))
      loop (-> (0 b1 b1))))

  (* sphere-1 I)
  (* b1 i0)    : (-1 (* sphere-1 I))
  (* b1 i1)    : (-1 (* sphere-1 I))
  (* b1 i01)   : (* b1 (0 i0 i1))
  -->            (0 (* b1 i0) (* b1 i1))
  (* loop i0)  : (* (0 b1 b1) i0)
  -->            (0 (* b1 i0) (* b1 i0))
  (* loop i1)  : (* (0 b1 b1) i1)
  -->            (0 (* b1 i1) (* b1 i1))
  (* loop i01) : (+ (* loop (0 i0 i1)) (* (0 b1 b1) i01))
  -->            (+ (1 (* loop i0) (* loop i1) rev)
                    (1 (* b1 i01) (* b1 i01) rev))
  -->            (1 (* loop i0) (* b1 i01)
                    (* loop i1) rev (* b1 i01) rev)

  (? sphere-1 I)
  (? b1 i0)    : (-1 (? sphere-1 I))
  (? b1 i1)    : (-1 (? sphere-1 I))
  (? b1 i01)   : (? b1 (0 i0 i1))
  -->            (0 (? b1 i0) (? b1 i1))
  (? loop i0)  : (? (0 b1 b1) i0)
  -->            (0 (? b1 i0) (? b1 i1))
  (? loop i1)  : (? (0 b1 b1) i1)
  -->            (0 (? b1 i1) (? b1 i0))
  (? loop i01) : (1 (? loop i0)
                    (? loop i1))

  (define sphere-1
    (type (-> space)
      b1 (-> (-1 <>))
      loop (-> (0 b1 b1))))

  (define sphere-2
    (type (-> space)
      b2 (-> (-1 <>))
      surf (-> (1 b2 refl))))

  (* sphere-2 sphere-1)
  (* b2 b1)     : (-1 (* sphere-2 sphere-1))
  (* b2 loop)   : (* b2 (0 b1 b1))
  -->             (0 (* b2 b1) (* b2 b1))
  (* surf b1)   : (* (1 b2 refl) b1)
  -->             (1 (* b2 b1) refl)
  (* surf loop) : (+ (* surf (0 b1 b1))
                     (* (1 b2 refl) loop))
  -->             (+ (2 (* surf b1) (* surf b1))
                     (2 (1 (* b2 loop)) refl))
  -->             (2 (* surf b1) (* surf b1)
                     (1 (* b2 loop)) refl)

  (? sphere-2 sphere-1)
  (? b2 b1)     : (-1 (? sphere-2 sphere-1))
  (? b2 loop)   : (? b2 (0 b1 b1))
  -->             (0 (? b2 b1) (? b2 b1))
  (? surf b1)   : (? (1 b2 refl) b1)
  -->             (1 (? b2 loop))
  (? surf loop) : (+ (? surf (0 b1 b1))
                     (? (1 b2 refl) loop))
  #+end_src
