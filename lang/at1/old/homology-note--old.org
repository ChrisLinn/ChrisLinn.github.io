#+title: homology-note--old

* ----------------------------------
* todo

  - to be constructive
    a quotient space should be defined by a natural-projection
    maybe fiber bundle should also be defined by projection

  - ><
    the gluing of adjunction is the same as
    that of the gluing of fibers ?

* ----------------------------------
* note continuous

  - to say a map is continuous
    is to allow it to be used in the language

* set

*** note set theory vs type theory

    - ><
      what is this vs ?

    - class (in oo) is encoded by a list of interface functions
      type-class (in haskell) is encoded by a list of abstract interface functions
      which all seem like the dual of the poset structure of set as cat

    - the methods of set theory have no fault
      the fault is to not to view them with implementation in mind

*** the encoding of type

    #+begin_src scheme
    (define-type T
      T.C = [(c1 : (* -> T))
             (c2 : (* -> T))]
      T.G = [(g1 : (term -> bool))
             (g2 : (term -> bool))]
      T.I = [(i1 : (T -> *))
             (i2 : (T -> *))
             (note
               interface functions are implemented by term rewriting)
             (note
               interface can be limited by type-cless)])

    (T1 < T2 :=
        T1.C < T2.C
        T1.G > T2.G)

    (note
      T1.I < T2.I
      T1 is a quotient space of T2)

    (note
      comparing can only be done by comparing list of names
      or declared relation between names
      (naming itself is also a declaration))

    (note
      names are made as unique as possible
      this labor can be easied by a module-system or infer-system)

    (note
      constructor can be shared by different types
      thus can not infer a unique type from a constructor
      thus cut needs to do search and backtracing)

    ;; in the view of
    ;; function as proof and type as theorem and space

    (note
      union of two types as a list of glue operations
      intersection in the two types will intro new connection
      continuous is all about levels of glues
      maybe the main formal law of continuous condition is hidden in the union)

    (define-function union)
    (define-function intersection)

    (note
      the formalization of gluing
      must be with detailed info about the the gluing is done
      if i view union as gluing
      the info will be denoted by the global-naming-as-mark
      two types with the same constructor can still be seprated or not ?)

    (note
      to define a named type
      is to intro a named level structure over the space of terms)
    #+end_src

*** image and inverse-image of function

    #+begin_src scheme
    (~ f : (X -> Y))
    (+ A < X)
    (+ B < Y)
    (+ B inverse f = ((:x : X) {:x f : B}))
    (+ A f = ({:x : A} (:x f : Y)))
    #+end_src

*** >< cartesian product

    - cartesian product of two type is a special case of
      general cartesian product
      which is the space of section of fiber bundle
      (i.e. dependent function space)
      (not the total space)

    - actually we can see
      the dependent function space is not about fiber bundle
      but only about general cartesian product
      to get fiber bundle we need more info

* >< topology

*** note

    - ><
      how this would improve my understanding of
      the formalization of continuous function in my language

    - how the concept of continuous is formalized by abstract axioms of topology
      not only by open set but by the union and intersection functions

*** >< abstract axioms of topology structure

* ----------------------------------
* homology

*** definition

    #+begin_src scheme
    (~ H (-> [(: :X space) (< :A :X) int]
             abelian-group))
    (~ H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                    (-> [:X :A :q H] [:Y :B :q H])))
    (~ boundary (-> [:X :A :q H]
                    [:X empty-space :q 1 sub H]))

    (~ co-H (-> [(: :X space) (< :A :X) int]
                abelian-group))
    (~ co-H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                       (-> [:Y :B q co-H] [:X :A q co-H])))
    (~ co-boundary (-> [:X empty-space :q 1 sub co-H]
                       [:X :A :q co-H]))
    #+end_src

*** >< axioms

    #+begin_src scheme
    (~ H/identity : ({:id : (:X :A -> :X :A)} :id space/iso {:q : int} ->
                     :id :q H/induce abelian-group/iso))

    (~ H/compose : ()
       (note
         this is always true
         for H/induce is recursively defined over function composition))

    (~ >< : ())
    #+end_src

* ----------------------------------
* the extension problem

  - in the view of sze-tsen-hu
    extension problem is the main kind of general problem of topology

  - to solve the extension problem
    is to solve an equation in the continuous function space

  #+begin_src scheme
  (~ inclusion ;; maybe we should built it in
     (-> [(< :a :x) (: :x type)]
         (-> :a :x))
     [(-> [:a :x]
          (lambda (-> :a :x) [(-> :v :v)]))])

  (~ g (-> [{< A X} A]
           Y))
  (~ f (-> X
           [Y (== [g]
                  [A X inclusion f])]))

  ;; to solve the extension problem
  ;; is to find a f for given g
  #+end_src

* the method of algebraic topology

  - to induce algebraic equation from continuous equation
    is the method of algebraic topology

  #+begin_src scheme
  (~ g H/induce : ({A < X} A empty-space :m H -> Y empty-space :m H))
  (~ f H/induce : (X empty-space :m H -> Y empty-space :m H
                   (g H/induce = A X inclusion H/induce f H/induce)))
  #+end_src

* retraction

  #+begin_src scheme
  (~ r : (X -> A
          (A id = A X inclusion r)))

  (~ r H/induce : (X empty-space :m H -> A empty-space :m H
                     (A empty-space :m H id =
                      A X inclusion H/induce r H/induce)))
  #+end_src

* note quotient space

  - to define a quotient space
    is to lessen the equality

  - the construction of quotient space
    is also called topological identification

  - there are many patterns by which we can re-implement equality of a type

  - when one is trying to formalize a concept in math
    he should try to use all the implementation tech
    and all the language paradigms

  - but it seems we have a basic uniformed equality in the term-lattice
    re-implement of equality is to be built on top of it

* quotient/natural-projection

  - which can always be done by natural-projection

  #+begin_src scheme
  (define-function quotient/natural-projection
    : ({:y : type}
       (:x : type) (:x -> :y) -> (:z : type))
    (:x :p ->
        {:z = (dr-from :x)}
        {:z.== = (:a :b -> :a :p @ :b :p @ :y.== @)}
        :z))
  #+end_src

* quotient/acting-group

  #+begin_src scheme
  (~ quotient/acting-group
     : ((:x : type) (:g < (:x -> :x))  -> (:z : type))
     (:x :g ->
         {:z = (dr-from :x)}
         {:z.== = (:a :b -> {search :e : :g} :a :e @ :b :x.== @)}
         :z))
  #+end_src

* quotient/identity-element

  - by enlarging zero (or one) in algebraic structure

  #+begin_src scheme
  (~ quotient/identity-set
     : ((:x : type) {:x with sub}
        (:x0 < :x)  -> (:z : type))
     (:x :x0 ->
         {:z = (dr-from :x)}
         {:z.== = (:a :b -> {:a :b sub : :x0})}
         :z))
  #+end_src

* >< adjunction space

  - note that
    g is directed
    X and Y are not 對稱

  #+begin_src scheme
  ;; adjoining X to Y by (~ g : (A -> Y))
  (~ X Y g adjoin : {A < X} (+ X Y))

  ;; instead of adding more equal tests
  ;; we specify a natural-projection
  (~ adjunction/p : ((+ X Y) -> (X Y g adjoin))
     ({:x : A} :x -> :x g)
     ({:x : (+ X Y)} :x -> :x))
  #+end_src

* >< extension equal to retraction of adjunction

  #+begin_src scheme
  (~ g : ((A < X) -> Y))

  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion r)))
  (~ f : (X -> Y
            (g = A X inclusion f))
     (:x -> :x p r))

  (~ f : (X -> Y
            (g = A X inclusion f)))
  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion r))
     ><><><)
  #+end_src

* >< mapping cylinder

  #+begin_src scheme
  (~ f : (X -> Y))
  (~ mapping-cylinder/p : ((+ (X I) Y) -> f mapping-cylinder)
     (:x 1 -> :x f)
     (:x :i -> :x :i)
     (:y -> :y))
  #+end_src

* ----------------------------------
* >< from chain-complex to homology

* >< the cat of top

  - for the cat of top
    a top constructor is defined by
    specifying set-level construction
    and specifying the open set or closed set

* >< cell-complex

  - CW-complex
    C for closure-finite
    W for weak-topology

* ----------------------------------
* note fiber space

* covering homotopy property

  #+begin_src scheme
  p : E -> B
  project : total-space -> base-space

  (~ f : (X -> B))

  (~ f/homotopy : (X -> B))

  ;; cover is defined by abstract interface
  (~ cover )
  (~ f p cover : (X -> E
                    (p f p cover = f)))
  #+end_src

* ----------------------------------
* another constructivist manifesto

*** talk

    - x ::
         如 bishop 所說
         他本應先發展出意義
         然後再把他的 假設與操作 構建在意義的根基上

    - k ::
         對我們而言
         先發展出某意義
         就是先考慮如何用程序語言實現某

    - x ::
         如 bishop 所說
         在每個新的發展中
         尋求萃取出最多的意義
         數學對現實的表達
         並不降級爲一個遊戲
         尋求理解數學在當代社會中的意義

    - k ::
         我想 一個可以被廣泛實現的 抽象接口
         就是有很多意義
         語言的表達能力很強
         也是有很多意義

    - x ::
         我們可否要求
         在遇到每個數學概念的時候
         都要 設計其語法 並 明確其實現
         以此爲宣言

    - k ::
         隨難 嘗試之

    - x ::
         還有一個問題是
         是否轉寫 古典的數學語法爲 後綴表達式

    - k ::
         我想應該如此
         目前的難處只是在於我們的後綴語法不完備
         只要增強我們後綴語法的能力
         就並不會有什麼阻力

    - x ::
         這樣可使我們不用作紙質的筆記

* ----------------------------------
