#+title: sze-tsen-hu--homotopy-theory

* todo

*** the rule about syntax

    - how to describe them ?
      how to design them so that you can add or change what already in them ?

* note

*** subtype

    - a type is encoded by its dc,
      a subtype of it is encoded by a subset of its dc.

* retraction-problem & extension-problem

  - if the retraction-problem
    #+begin_src scheme
    (lambda (type (-> [X] [X0])
              (part on X0)))
    #+end_src
    is solvable by 'r',
    then every extension-problem
    #+begin_src scheme
    (lambda (-> [X] [Y]) (part on X0))
    #+end_src
    is solvable by 'e'.

* the proof of (f0 ~ f1)

  - to proof (f0 ~ f1)
    is to form a special extension-problem.
    with (f0, f1 : A -> B)
    we need to extend a partial-map of type (-> [A I] [B])
    #+begin_src scheme
    (let ([f0 (lambda (-> [A] [B]) ...)]
          [f1 (lambda (-> [A] [B]) ...)])
      (lambda (-> [A I] [B])
        (extend-from
          (lambda (-> [A (0 I)] [B])
            (-> [:a i0] [:a f0])
            (-> [:a i1] [:a f1])))))
    #+end_src

  - the corresponding retraction-problem is
    #+begin_src scheme
    (lambda (-> [A I] [A (0 I)])
      (extend-from
        (identity-map-of [A (0 I)])))

    (lambda (-> [A I] [A (0 I)])
      (extend-from
        (lambda (->  [A (0 I)]  [A (0 I)])
          (-> [:a i0] [:a f0])
          (-> [:a i1] [:a f1]))))
    #+end_src
    if this retraction-problem is solvable
    then for all (f0, f1 : A -> B)
    we have (f0 ~ f1)

* the proof of (A == B)

  - to proof (A == B)
    is to form find (f : A -> B) and (g : B -> A)
    and to proof (f g ~ A id) and (g f ~ B id)
    #+begin_src scheme
    (lambda (-> [A I] [A])
      (extend-from
        (lambda (-> [A (0 I)] [A])
          (-> [:a i0] [:a f g])
          (-> [:a i1] [:a]))))

    (lambda (-> [B I] [B])
      (extend-from
        (lambda (-> [B (0 I)] [B])
          (-> [:b i0] [:b g f])
          (-> [:b i1] [:b]))))
    #+end_src

  - the corresponding retraction-problem is
    #+begin_src scheme
    (lambda (-> [A I] [A (0 I)])
      (extend-from
        (identity-map-of [A (0 I)])))

    (lambda (-> [A I] [A (0 I)])
      (extend-from
        (lambda (-> [A (0 I)] [A (0 I)])
          (-> [:a i0] [:a i0])
          (-> [:a i1] [:a i1]))))

    (note the-same-for B)
    #+end_src

  - it is to say
    if the above retraction-problem is solvable
    then to proof (A == B)
    it is suffice to proof (A -> B) and (B -> A)
    [i.e. to find two functions of such types]
