* the use of prefix notation <2016-11-01 Tue>

  - use prefix notation for syntax keyword
    '->' ':' '='
    just as '~' '+'

  - replace () by {} change explicate to implicate
    thus a keyword
    1. has side-effect -- can use {}
       and has return value -- can use ()
    2. has side-effect -- can use {}
       does not have return value -- can not use ()

  - [] for a list of (any kind of) things
    [x] can be written as x

  - example about the change

    #+begin_src scheme
    (~ H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ H/induce : ((:X :A -> :Y :B) (:q : int) ->
                   (:X :A :q H -> :Y :B :q H)))
    (~ boundary : (:X :A :q H -> :X empty-space :q 1 sub H))

    (~ co-H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ co-H/induce : ((:X :A -> :Y :B) (:q : int) ->
                      (:Y :B q co-H -> :X :A q co-H)))
    (~ co-boundary : (:X empty-space :q 1 sub co-H -> :X :A :q co-H))


    (~ H (-> [(: :X space) (< :A :X) int]
             abelian-group))
    (~ H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                    (-> [:X :A :q H] [:Y :B :q H])))
    (~ boundary (-> [:X :A :q H]
                    [:X empty-space :q 1 sub H]))

    (~ co-H (-> [(: :X space) (< :A :X) int]
                abelian-group))
    (~ co-H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                       (-> [:Y :B q co-H] [:X :A q co-H])))
    (~ co-boundary (-> [:X empty-space :q 1 sub co-H]
                       [:X :A :q co-H]))
    #+end_src

  - 如是
    就區分了 中綴表達式中的 (-> nat) 與 nat
    即 (-> [] [nat]) 與 [nat]
    只不過爲 (-> [] [nat nat]) 與 [nat nat]
    否則 (-> nat nat) 與 nat nat
    這後面的 nat nat 在語境中可能有歧義

  - more example

    #+begin_src scheme
    (+ (~ natural type)
       (~ zero natural)
       (~ succ (-> natural natural)))

    (~ add
       (-> [natural natural]
           natural)
       [(-> [:m zero]
            :m)
        (-> [:m :n succ]
            [:m :n add succ])])

    (~ quotient/natural-projection
       (-> [{: :y type}
            (: :x type) (-> :x :y)]
           [(: :z type)])
       [(-> [:x :p]
            [{= :z (derive :x)}
             {= :z.== (-> [:a :b]
                          [:a :p @ :b :p @ :y.== @])}
             :z])])
    #+end_src

  - rationale
    在設計語法過程中
    經常需要 border-fix notation
    用中綴表達式 (* -> *) 來實現 border-fix notation
    固然簡介
    但是 如此就佔用了 () 這個 structural lexicon
    解放出這個 ()
    模仿古典 lisp
    以靈活處理 border-fix notation

  - 注意
    如此產生的 keyword 之 返回值後置
    比如 ':' 與 '<'
    (: :x type) 是說 此位返回值 類型爲 type 名爲 :x
    (< :a :x) 是說 此位返回值 類型爲 :x 的 subtype 名爲 :a

* keyword 之 返回值後置 <2016-11-16 Wed>

  - x ::
       keyword 用前綴表達式
       之後我發現
       我們語言設計的重要特點就是偏向 explicit
       而我可以觀察到
       目前的設計中 (: :t type) 就是典型的 implicit

  - k ::
       我想我們可以總結一下當前設計中的 implicit 之處
       要知道 implicit 就是 語法優化
       我們之後要看看這些優化是否必要

  - x ::
       首先需要考察的就是 (: :t type)
       例如
       #+begin_src scheme
       (define nat
         (data type
           (: zero nat)
           (: succ (-> nat nat))))

       (define nat-induction
         (lambda (-> [(: :p (-> nat type))
                      zero :p @
                      (-> [(: :k nat) :k :p @]
                          [:k succ :p @])
                      (: :x nat)]
                     [:x :p @])
           (-> [:q :q/z :q/s zero] :q/z)
           (-> [:q :q/z :q/s :n succ]
               [:n
                :q :q/z :q/s :n nat-induction
                :q/s @])))
       #+end_src
       如此看來
       它出現在不同的地方意義是不同的
       我想我們所說的 explicit 與 正規性
       就是要儘量減少這種情況
       即 減少語法關鍵詞對上下文的依賴

  - k ::
       如若換成
       #+begin_src scheme
       (define nat
         (data type
           zero nat
           succ (-> nat nat)))
       #+end_src
       就可以說 data 把它 body 中的 list 當作 alist 來處理了

  - x ::
       這樣就算是解決了 這個語法關鍵詞 依賴上下文的問題
       還有就是他本身的意義問題
       我有了一個好想法
       就是說
       每個語法關鍵詞也是有類型的
       [每次都去考慮類型]
       之前想要區分 (: :t type) 與 {: :t type}
       所想要區分的是
       前者 在局部的副作用之外 返回一個值到棧中
       後者 只有局部的副作用
       我們應該用系統的方式來處理這種對差異的需求

  - k ::
       還有就是命名問題
       或者說 lexicon 問題
       比如
       以 (: :x type) 記 之前之 (: :x type)
       以 (:- :x type) 記 之前之 {: :x type}
       我們要讓 lexicon 之間的形式關係
       體現出 lexicon 之間的語義關係
       這有些類似與 孤立語 黏着語

  - x ::
       我們可以製作一個表格如下
       | 返回值到棧中 | 不返回值到棧中     | 對比語言學中的分類 |
       |--------------+--------------------+--------------------|
       | (: :t type)  | {: :t type}        | 特殊               |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (:- :t type)       | 動詞變位           |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (# (: :t type))    | 前綴黏着           |
       |              | (hide (: :t type)) |                    |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (: :t type) drop   | 後綴黏着           |

  - k ::
       我們應該想想自然語言中 爲什麼有這種需要
       而程序語言中的這種設計 在類比中又意謂如何

* 對比自然語言中的 '設計' <2016-11-18 Fri>

  - x ::
       自然語言之 分析 綜合 之分
       看來主要是區分是否依賴語序

  - k ::
       我們來熟悉一些術語
       | 語素     | morpheme       | 意義最小單位     |
       | 詞       | word           | 可使用的最小單位 |
       | 詞序     | word order     |                  |
       | 自由語素 | free morpheme  | 可獨立使用       |
       | 粘著語素 | bound morpheme | 不可獨立使用     |

  - x ::
       看來 曲折 指 詞根詞綴 詞綴詞綴 之間的區分不明
       而導致詞形多不規則變化 (拉丁語)

  - k ::
       好像 語法範疇 這個概念就是我們需要的
    1. 名詞
       性 (gender)
       數 (number)
       格 (case)
    2. 動詞
       限定性 (finiteness)
       時 (tense)
       體 (aspect)
       態 (voice)
       式 (mood)
       人稱 (person)
    3. 形容詞 副詞
       級 (degree)

  - x ::
       格 (case) 用於處理多名詞句子
       我們可以想象在一個線性的 jojo 中
       利用不同的 call 來區分對同一個詞的不同使用方式
       拉丁語為例
       | 主格 | nominative case | 主語               |
       | 屬格 | genitive case   | 表示領屬關係的定語 |
       | 與格 | dative case     | 間接賓語           |
       | 賓格 | accusative case | 直接賓語           |
       | 呼格 | vocative case   | 呼語               |
       | 奪格 | ablative case   | 表示某些意義的狀語 |
       不用變格來區分多名詞句子中不同名詞的使用方式
       就需要用語序來區分之了

  - k ::
       一個句子 動詞之間是有時間上相互關聯
       比如 完成體 (perfect aspect)
       一個動詞本身也有進行中或已經完成之分
       比如 完全體 (perfective aspect)
       形式上記錄這些關係的就是語法
       [屈折語用 動詞變位]
       類似 名詞變格 處理多名詞句子
       很多語言也有一種處理 多動詞句子 的獨特策略
       即 限定性 (finiteness)
       就是把動詞區分為 限定 和 非限定 兩種形式
       | 限定動詞   | 句子(或分句)之 謂語     |
       | 非限定動詞 | 句子(或分句)之 其他成分 |
       由於一句 只有一謂語
       所以一個簡單分句最多只有一個 限定動詞
       [除非使用 並列連詞 (coordinator)
       把多個 限定動詞 組成 並列謂語]

  - x ::
       一句一謂語 這個規則
       看來也能體現在程序語言的語法設計之中
       不論是 前綴中綴還是後綴
       都只有一個函數作用於多個參數

  - x ::
       我還發現了程序語言設計中一個有趣的事實
       程序語言需以無歧義的形式語法
       描述如何完成(how)一段計算(一段變化)
       而在形式語言之外
       我們一定也能用自然語言描述這種計算
       只不過所做的描述不足夠形式 而不易被機器處理

  - k ::
       這樣 在對比自然語言與程序語言之間的關係的時候
       我們就可以總結一下
       自然語言 是如何描述 如何進行一段計算的

  - x ::
       等等
       在總結之前
       我還發現了這篇文章的方法
       首先 西語之語法學主要在於 名詞變格 動詞變位
       再 總結這些語法現象的功能
       然後 在漢語中尋找完成類似功能的(與之完全不同的)語法現象
       我們可以試着構擬這些 '語法' 之產生

* emergent grammar & grammaticalization

  - x ::
       emergent grammar 不想語言的語法是現設計完備的
       而說 語言沿 grammaticalization 演化 而產生語法

  - k ::
       也就是說我們要找
       自然語言的 grammaticalization 在程序語言中的類比

  - x ::
       grammar emerges through interaction among participants
       who are constantly reusing and modifying prior utterances
       to achieve current interactive goals

  - k ::
       比如
       使用一個 sequent 法形式很多次 而把它定義爲新的 function
       使用一種語法形式很多次 而把它做成 macro

  - x ::
       但是其實我們不能說 定義一個 macro 是 grammaticalization
       因爲 定義 macro 與 定義 function 重在定義之命名過程
       命名似用典

* 一些新的 語法設計 與 語言實現 原則 <2016-11-19 Sat>

  - x ::
       我想出了一些新的語法設計原則
       有三條
       一
       爲定義過的名做 派
       比如 計算 與 類型檢查
       分派兩個不同的函數體來作用
       二
       以 珠珠 爲函數語義之核心
       用圓括號作爲直接數據之語法
       三
       要知道
       不論是如何分派
       不論是計算或類型檢查
       最終都是對機器狀態的變化
       而我們常常用棧來記錄這些狀態

  - k ::
       其中第三點尤爲重要
       看似是常識 可是總是被忘記
       下面就是要明確應該如何踐行這些新的原則

  - x ::
       既然機器的狀態纔是最重要的
       我們就要設計彙編語言來分解 jojo 與 arrow-list 之計算 還有類型檢查
       彙編語言本身是不經過類型檢查的

  - k ::
       但是我發現了一個問題
       如果我們寫解釋器的話
       有些機器的狀態是依賴宿主語言的

  - x ::
       這沒有關係
       只要我們小心地明確這些依賴就行了

* 以 珠珠 爲函數語義之核心 用圓括號作爲直接數據之語法

  - x ::
       我想這種設計對於目前的需求來說是夠用的
       這樣我們就要用 (: :t type) drop 這種語法了

  - k ::
       我們可以把 key 區分爲兩種
       一種是 top 如 define
       一種是 lit 如 lambda -> : <

  - x ::
       我想又找到了一個新的原則
       就是說 對於每個這樣的 詞 不論是 key 也好 還是 function 或 macro 也好
       我們都應該嘗試給其以類型
       畢竟它們被編譯或解釋的效果都是對機器之狀態的變化

  - k ::
       首先
       這些語法關鍵詞的特點是
       他們的參數不光是棧中的數據
       還可能是圓括號中所包含的 lit

  - x ::
       我們看一些例子
       (: :t type) 不能只在副作用之後返回 type 這個數據
       而要 返回 bind
       這就是之前所說的 信息不丟失
       之所以需要這樣來避免信息丟失
       是因爲 var 的 level

  - k ::
       我們來仔細分析一下
       首先 var 是爲了 bind
       bind 是爲了 unify
       而 var 的 level
       是爲了 (type-of jo)
       不能直接返回 level-1 的數據
       而要返回 bind 是因爲
       之後 arrow 的 (type-of antecedent) 需要與它做 unify

  - x ::
       我們在這裏之所以需要新增一個 bind 數據類型
       也許是因爲我們沒能設計好 type-check 的過程
       這裏就回到了第三條原則
       要知道 type-check 是對機器的狀態的變化而已

  - k ::
       幾遍如此 我們也很難拋棄 新增的這個 bind 數據類型
       因爲想要避免 bind 作爲數據類型
       唯一的辦法看來就是用帶有兩層數據的 data-stack
       這看來是不合理的
       爲了更好的實現 unify
       我們可以在 data-stack 的接口上加一層 pointer
       來改變數據的輸出方向等等
       但是這些看來都有點複雜了

  - x ::
       也許 這種返回新數據類型的效果是需要的
       比如 (: :t type) (< :a :x) 這些東西
       我們隨時可能增加這類東西
       這時就需要使用類似 oo 的效果了
       需要使用消息傳遞的實現方式

  - k ::
       也就是說 在這個層次實現的數據類型 需要有自己的方法
       這樣就避免了用 pattern 來 dispatch
       回顧之前的 dispatch 表格
       | jo      | data    | double data |
       |---------+---------+-------------|
       | compose | bs/deep | cover       |
       | cut     |         | unify       |
       所能接受的信息至少包括這些
       其中 double data 使得 oo 中主次參數之分也有意義了

  - x ::
       就具體實現而言
       我們還是需要 typed-racket
       因爲即便是實現 oo 的 method
       我們還是需要類型系統

  - k ::
       但是這就要求我們在 typed-racket 中自己實現一個 oo 機制

  - x ::
       這並不困難

* 關於 oo 與 functional

  - x ::
       增減代碼的方式有別
       導致
       oo 中可以動態地新增新的數據類型
       而 functional 中可以動態地生成新的函數

* 語言標準

  - x ::
       we can design new way to add new things
       but the way always must be limited in some way

* 實用的實現 與 爲理論而做的原型實現

  - x ::
    1. 爲理論而實現原型需要使用實用的語言
    2. 實用的語言的語法設計新需求來自爲理論而作的原型

  - k ::
       可否二者兼顧呢

* >< 彙編

  - x ::
       用更底層的一層語言來描述 : 與 < 之實現細節
       難點在於
       這種低一層的語言如何融合到 sequent0 當前的實現方式中

  - k ::
       我想這並不重要
       因爲
       不論用什麼語言
       我們總有能力把這種類似彙編語言的中間層在實現中表達出來

  - x ::
       那麼就具體的 : 與 < 而言
       #+begin_src scheme
       (: :data :type)
       (:bind (level 1 :data) (level 0 :type))
       (:return a new data which will mainly be treated as type)
       (::)

       (< :subtype :type)
       (:bind (level 1 :data) (level 0 :type))
       #+end_src

  - k ::
       我發現正如我們第一次嘗試爲每個名字區分 compute 與 type-check 兩種方法時
       '類型安全' 這個概念在那個語言中是靈活可變的
       這裏 類似 (: :data :type) 這種 具有返回值 且帶有副作用的表達式
       也可以出現在 jojo 中

  - x ::
       之前的想法是
       遇一名時 可能是爲了 compute 也可能是爲了 type-check
       (: :data :type) 是一個數據
       正如遇到別的數據時需要改變 ds 的狀態
       遇到 (: :data :type) 時
       之所以說它有副作用
       是因爲在改變 ds 的狀態之外
       它還會改變 bind 的狀態
       gs 之於 bs
       正如 rs 之於 ds
       既然 這些都是 stack
       那麼 給它們加類型 就是描述他們對 stack 的狀態之改變了

  - k ::
       看來 類型系統的核心想法 就是這種兩層計算
       計算有兩層 兩層都是計算

* >< homology 與 homtopy 的語言

  - x ::
       既然目的是實現 at1
       而且又知道 對語法和語義的新需求都來源於 at
       那麼就以新需求爲引導吧

  - k ::
       那麼我們努力嘗試表達 homology 與 homtopy 中所遇到的所有構造細節

* >< 總結 自然語言對算法的描述

* >< 關於 oo

  - 術語
    | 消息 | 數據 |
    | 方法 | 對象 |
  - 一個數據可能有很多域
    不同的域可能是爲了不同的方法所準備的
    - 比如 lambda 的 type 域 爲 type-check 這個方法而準備
      比如 lambda 的 data 域 爲 compute 這個方法而準備

  - 定義每個數據時
    也要定義它的一系列方法
    一個數據的方法可以在之後定義
    一個方法以這種數據類型爲主要參數
    它可能要做一些控制結構
    並且查看某些域並向這些域中的數據發送消息
    - 比如 lambda 的 compute 要遍歷其 data 域
      並向其中數據[遞歸地]發送 compute 消息
      比如 lmabda 的 type-check 要遍歷其 type 域
      並向其中數據[遞歸地]發送 type-check 消息

  - 方法的效果都是改變機器的狀態

  - 注意 實現層 和 被實現層 兩層語言

  - 被完全展開的語法 要能夠清晰簡單地描述如何定義數據
