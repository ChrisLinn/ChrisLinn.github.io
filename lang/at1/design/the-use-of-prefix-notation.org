* todo

  - 使用編譯到 js 的實現方式
    在編譯的過程中考慮元編程能力

  - 在語言沒有被實現的前提下
    嘗試用新語法實現 sequent0 中的核心部分
    是爲 '自上而下的' 編程

* the use of prefix notation <2016-11-01 Tue>

  - use prefix notation for syntax keyword
    '->' ':' '='
    just as '~' '+'

  - replace () by {} change explicate to implicate
    thus a keyword
    1. has side-effect -- can use {}
       and has return value -- can use ()
    2. has side-effect -- can use {}
       does not have return value -- can not use ()

  - [] for a list of (any kind of) things
    [x] can be written as x

  - example about the change

    #+begin_src scheme
    (~ H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ H/induce : ((:X :A -> :Y :B) (:q : int) ->
                   (:X :A :q H -> :Y :B :q H)))
    (~ boundary : (:X :A :q H -> :X empty-space :q 1 sub H))

    (~ co-H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ co-H/induce : ((:X :A -> :Y :B) (:q : int) ->
                      (:Y :B q co-H -> :X :A q co-H)))
    (~ co-boundary : (:X empty-space :q 1 sub co-H -> :X :A :q co-H))


    (~ H (-> [(: :X space) (< :A :X) int]
             abelian-group))
    (~ H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                    (-> [:X :A :q H] [:Y :B :q H])))
    (~ boundary (-> [:X :A :q H]
                    [:X empty-space :q 1 sub H]))

    (~ co-H (-> [(: :X space) (< :A :X) int]
                abelian-group))
    (~ co-H/induce (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                       (-> [:Y :B q co-H] [:X :A q co-H])))
    (~ co-boundary (-> [:X empty-space :q 1 sub co-H]
                       [:X :A :q co-H]))
    #+end_src

  - 如是
    就區分了 中綴表達式中的 (-> nat) 與 nat
    即 (-> [] [nat]) 與 [nat]
    只不過爲 (-> [] [nat nat]) 與 [nat nat]
    否則 (-> nat nat) 與 nat nat
    這後面的 nat nat 在語境中可能有歧義

  - more example

    #+begin_src scheme
    (+ (~ natural type)
       (~ zero natural)
       (~ succ (-> natural natural)))

    (~ add
       (-> [natural natural]
           natural)
       [(-> [:m zero]
            :m)
        (-> [:m :n succ]
            [:m :n add succ])])

    (~ quotient/natural-projection
       (-> [{: :y type}
            (: :x type) (-> :x :y)]
           [(: :z type)])
       [(-> [:x :p]
            [{= :z (derive :x)}
             {= :z.== (-> [:a :b]
                          [:a :p @ :b :p @ :y.== @])}
             :z])])
    #+end_src

  - rationale
    在設計語法過程中
    經常需要 border-fix notation
    用中綴表達式 (* -> *) 來實現 border-fix notation
    固然簡介
    但是 如此就佔用了 () 這個 structural lexicon
    解放出這個 ()
    模仿古典 lisp
    以靈活處理 border-fix notation

  - 注意
    如此產生的 keyword 之 返回值後置
    比如 ':' 與 '<'
    (: :x type) 是說 此位返回值 類型爲 type 名爲 :x
    (< :a :x) 是說 此位返回值 類型爲 :x 的 subtype 名爲 :a

* keyword 之 返回值後置 <2016-11-16 Wed>

  - x ::
       keyword 用前綴表達式
       之後我發現
       我們語言設計的重要特點就是偏向 explicit
       而我可以觀察到
       目前的設計中 (: :t type) 就是典型的 implicit

  - k ::
       我想我們可以總結一下當前設計中的 implicit 之處
       要知道 implicit 就是 語法優化
       我們之後要看看這些優化是否必要

  - x ::
       首先需要考察的就是 (: :t type)
       例如
       #+begin_src scheme
       (define nat
         (data type
           (: zero nat)
           (: succ (-> nat nat))))

       (define nat-induction
         (lambda (-> [(: :p (-> nat type))
                      zero :p @
                      (-> [(: :k nat) :k :p @]
                          [:k succ :p @])
                      (: :x nat)]
                     [:x :p @])
           (-> [:q :q/z :q/s zero] :q/z)
           (-> [:q :q/z :q/s :n succ]
               [:n
                :q :q/z :q/s :n nat-induction
                :q/s @])))
       #+end_src
       如此看來
       它出現在不同的地方意義是不同的
       我想我們所說的 explicit 與 正規性
       就是要儘量減少這種情況
       即 減少語法關鍵詞對上下文的依賴

  - k ::
       如若換成
       #+begin_src scheme
       (define nat
         (data type
           zero nat
           succ (-> nat nat)))
       #+end_src
       就可以說 data 把它 body 中的 list 當作 alist 來處理了

  - x ::
       這樣就算是解決了 這個語法關鍵詞 依賴上下文的問題
       還有就是他本身的意義問題
       我有了一個好想法
       就是說
       每個語法關鍵詞也是有類型的
       [每次都去考慮類型]
       之前想要區分 (: :t type) 與 {: :t type}
       所想要區分的是
       前者 在局部的副作用之外 返回一個值到棧中
       後者 只有局部的副作用
       我們應該用系統的方式來處理這種對差異的需求

  - k ::
       還有就是命名問題
       或者說 lexicon 問題
       比如
       以 (: :x type) 記 之前之 (: :x type)
       以 (:- :x type) 記 之前之 {: :x type}
       我們要讓 lexicon 之間的形式關係
       體現出 lexicon 之間的語義關係
       這有些類似與 孤立語 黏着語

  - x ::
       我們可以製作一個表格如下
       | 返回值到棧中 | 不返回值到棧中     | 對比語言學中的分類 |
       |--------------+--------------------+--------------------|
       | (: :t type)  | {: :t type}        | 特殊               |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (:- :t type)       | 動詞變位           |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (# (: :t type))    | 前綴黏着           |
       |              | (hide (: :t type)) |                    |
       |--------------+--------------------+--------------------|
       | (: :t type)  | (: :t type) drop   | 後綴黏着           |

  - k ::
       我們應該想想自然語言中 爲什麼有這種需要
       而程序語言中的這種設計 在類比中又意謂如何

* 對比自然語言中的 '設計' <2016-11-18 Fri>

  - x ::
       自然語言之 分析 綜合 之分
       看來主要是區分是否依賴語序

  - k ::
       我們來熟悉一些術語
       | 語素     | morpheme       | 意義最小單位     |
       | 詞       | word           | 可使用的最小單位 |
       | 詞序     | word order     |                  |
       | 自由語素 | free morpheme  | 可獨立使用       |
       | 粘著語素 | bound morpheme | 不可獨立使用     |

  - x ::
       看來 曲折 指 詞根詞綴 詞綴詞綴 之間的區分不明
       而導致詞形多不規則變化 (拉丁語)

  - k ::
       好像 語法範疇 這個概念就是我們需要的
    1. 名詞
       性 (gender)
       數 (number)
       格 (case)
    2. 動詞
       限定性 (finiteness)
       時 (tense)
       體 (aspect)
       態 (voice)
       式 (mood)
       人稱 (person)
    3. 形容詞 副詞
       級 (degree)

  - x ::
       格 (case) 用於處理多名詞句子
       我們可以想象在一個線性的 jojo 中
       利用不同的 call 來區分對同一個詞的不同使用方式
       拉丁語為例
       | 主格 | nominative case | 主語               |
       | 屬格 | genitive case   | 表示領屬關係的定語 |
       | 與格 | dative case     | 間接賓語           |
       | 賓格 | accusative case | 直接賓語           |
       | 呼格 | vocative case   | 呼語               |
       | 奪格 | ablative case   | 表示某些意義的狀語 |
       不用變格來區分多名詞句子中不同名詞的使用方式
       就需要用語序來區分之了

  - k ::
       一個句子 動詞之間是有時間上相互關聯
       比如 完成體 (perfect aspect)
       一個動詞本身也有進行中或已經完成之分
       比如 完全體 (perfective aspect)
       形式上記錄這些關係的就是語法
       [屈折語用 動詞變位]
       類似 名詞變格 處理多名詞句子
       很多語言也有一種處理 多動詞句子 的獨特策略
       即 限定性 (finiteness)
       就是把動詞區分為 限定 和 非限定 兩種形式
       | 限定動詞   | 句子(或分句)之 謂語     |
       | 非限定動詞 | 句子(或分句)之 其他成分 |
       由於一句 只有一謂語
       所以一個簡單分句最多只有一個 限定動詞
       [除非使用 並列連詞 (coordinator)
       把多個 限定動詞 組成 並列謂語]

  - x ::
       一句一謂語 這個規則
       看來也能體現在程序語言的語法設計之中
       不論是 前綴中綴還是後綴
       都只有一個函數作用於多個參數

  - x ::
       我還發現了程序語言設計中一個有趣的事實
       程序語言需以無歧義的形式語法
       描述如何完成(how)一段計算(一段變化)
       而在形式語言之外
       我們一定也能用自然語言描述這種計算
       只不過所做的描述不足夠形式 而不易被機器處理

  - k ::
       這樣 在對比自然語言與程序語言之間的關係的時候
       我們就可以總結一下
       自然語言 是如何描述 如何進行一段計算的

  - x ::
       等等
       在總結之前
       我還發現了這篇文章的方法
       首先 西語之語法學主要在於 名詞變格 動詞變位
       再 總結這些語法現象的功能
       然後 在漢語中尋找完成類似功能的(與之完全不同的)語法現象
       我們可以試着構擬這些 '語法' 之產生

* emergent grammar & grammaticalization

  - x ::
       emergent grammar 不想語言的語法是現設計完備的
       而說 語言沿 grammaticalization 演化 而產生語法

  - k ::
       也就是說我們要找
       自然語言的 grammaticalization 在程序語言中的類比

  - x ::
       grammar emerges through interaction among participants
       who are constantly reusing and modifying prior utterances
       to achieve current interactive goals

  - k ::
       比如
       使用一個 sequent 法形式很多次 而把它定義爲新的 function
       使用一種語法形式很多次 而把它做成 macro

  - x ::
       但是其實我們不能說 定義一個 macro 是 grammaticalization
       因爲 定義 macro 與 定義 function 重在定義之命名過程
       命名似用典

* 一些新的 語法設計 與 語言實現 原則 <2016-11-19 Sat>

  - x ::
       我想出了一些新的語法設計原則
       有三條
       一
       爲定義過的名做 派
       比如 計算 與 類型檢查
       分派兩個不同的函數體來作用
       二
       以 珠珠 爲函數語義之核心
       用圓括號作爲直接數據之語法
       三
       要知道
       不論是如何分派
       不論是計算或類型檢查
       最終都是對機器狀態的變化
       而我們常常用棧來記錄這些狀態

  - k ::
       其中第三點尤爲重要
       看似是常識 可是總是被忘記
       下面就是要明確應該如何踐行這些新的原則

  - x ::
       既然機器的狀態纔是最重要的
       我們就要設計彙編語言來分解 jojo 與 arrow-list 之計算 還有類型檢查
       彙編語言本身是不經過類型檢查的

  - k ::
       但是我發現了一個問題
       如果我們寫解釋器的話
       有些機器的狀態是依賴宿主語言的

  - x ::
       這沒有關係
       只要我們小心地明確這些依賴就行了

* 以 珠珠 爲函數語義之核心 用圓括號作爲直接數據之語法

  - x ::
       我想這種設計對於目前的需求來說是夠用的
       這樣我們就要用 (: :t type) drop 這種語法了

  - k ::
       我們可以把 key 區分爲兩種
       一種是 top 如 define
       一種是 lit 如 lambda -> : <

  - x ::
       我想又找到了一個新的原則
       就是說 對於每個這樣的 詞 不論是 key 也好 還是 function 或 macro 也好
       我們都應該嘗試給其以類型
       畢竟它們被編譯或解釋的效果都是對機器之狀態的變化

  - k ::
       首先
       這些語法關鍵詞的特點是
       他們的參數不光是棧中的數據
       還可能是圓括號中所包含的 lit

  - x ::
       我們看一些例子
       (: :t type) 不能只在副作用之後返回 type 這個數據
       而要 返回 bind
       這就是之前所說的 信息不丟失
       之所以需要這樣來避免信息丟失
       是因爲 var 的 level

  - k ::
       我們來仔細分析一下
       首先 var 是爲了 bind
       bind 是爲了 unify
       而 var 的 level
       是爲了 (type-of jo)
       不能直接返回 level-1 的數據
       而要返回 bind 是因爲
       之後 arrow 的 (type-of antecedent) 需要與它做 unify

  - x ::
       我們在這裏之所以需要新增一個 bind 數據類型
       也許是因爲我們沒能設計好 type-check 的過程
       這裏就回到了第三條原則
       要知道 type-check 是對機器的狀態的變化而已

  - k ::
       幾遍如此 我們也很難拋棄 新增的這個 bind 數據類型
       因爲想要避免 bind 作爲數據類型
       唯一的辦法看來就是用帶有兩層數據的 data-stack
       這看來是不合理的
       爲了更好的實現 unify
       我們可以在 data-stack 的接口上加一層 pointer
       來改變數據的輸出方向等等
       但是這些看來都有點複雜了

  - x ::
       也許 這種返回新數據類型的效果是需要的
       比如 (: :t type) (< :a :x) 這些東西
       我們隨時可能增加這類東西
       這時就需要使用類似 oo 的效果了
       需要使用消息傳遞的實現方式

  - k ::
       也就是說 在這個層次實現的數據類型 需要有自己的方法
       這樣就避免了用 pattern 來 dispatch
       回顧之前的 dispatch 表格
       | jo      | data    | double data |
       |---------+---------+-------------|
       | compose | bs/deep | cover       |
       | cut     |         | unify       |
       所能接受的信息至少包括這些
       其中 double data 使得 oo 中主次參數之分也有意義了

  - x ::
       就具體實現而言
       我們還是需要 typed-racket
       因爲即便是實現 oo 的 method
       我們還是需要類型系統

  - k ::
       但是這就要求我們在 typed-racket 中自己實現一個 oo 機制

  - x ::
       這並不困難

* 關於 oo 與 functional

  - x ::
       增減代碼的方式有別
       導致
       oo 中可以動態地新增新的數據類型
       而 functional 中可以動態地生成新的函數

* 語言標準

  - x ::
       we can design new way to add new things
       but the way always must be limited in some way

* 實用的實現 與 爲理論而做的原型實現

  - x ::
    1. 爲理論而實現原型需要使用實用的語言
    2. 實用的語言的語法設計新需求來自爲理論而作的原型

  - k ::
       可否二者兼顧呢

* >< 彙編

  - x ::
       用更底層的一層語言來描述 : 與 < 之實現細節
       難點在於
       這種低一層的語言如何融合到 sequent0 當前的實現方式中

  - k ::
       我想這並不重要
       因爲
       不論用什麼語言
       我們總有能力把這種類似彙編語言的中間層在實現中表達出來

  - x ::
       那麼就具體的 : 與 < 而言
       #+begin_src scheme
       (: :data :type)
       (:bind (level 1 :data) (level 0 :type))
       (:return a new data which will mainly be treated as type)
       (::)

       (< :subtype :type)
       (:bind (level 1 :data) (level 0 :type))
       #+end_src

  - k ::
       我發現正如我們第一次嘗試爲每個名字區分 compute 與 type-check 兩種方法時
       '類型安全' 這個概念在那個語言中是靈活可變的
       這裏 類似 (: :data :type) 這種 具有返回值 且帶有副作用的表達式
       也可以出現在 jojo 中

  - x ::
       之前的想法是
       遇一名時 可能是爲了 compute 也可能是爲了 type-check
       (: :data :type) 是一個數據
       正如遇到別的數據時需要改變 ds 的狀態
       遇到 (: :data :type) 時
       之所以說它有副作用
       是因爲在改變 ds 的狀態之外
       它還會改變 bind 的狀態
       gs 之於 bs
       正如 rs 之於 ds
       既然 這些都是 stack
       那麼 給它們加類型 就是描述他們對 stack 的狀態之改變了

  - k ::
       看來 類型系統的核心想法 就是這種兩層計算
       計算有兩層 兩層都是計算

* >< homology 與 homtopy 的語言

  - x ::
       既然目的是實現 at1
       而且又知道 對語法和語義的新需求都來源於 at
       那麼就以新需求爲引導吧

  - k ::
       那麼我們努力嘗試表達 homology 與 homtopy 中所遇到的所有構造細節

* 關於 oo

  - 術語
    | 消息 | 數據 |
    | 方法 | 對象 |

  - 一個數據可能有很多域
    不同的域可能是爲了不同的方法所準備的
    - 比如 lambda 的 type 域 爲 type-check 這個方法而準備
      比如 lambda 的 data 域 爲 compute 這個方法而準備

  - 定義每個數據時
    也要定義它的一系列方法
    一個數據的方法可以在之後定義
    一個方法以這種數據類型爲主要參數
    它可能有一些控制結構
    並且查看某些域並向這些域中的數據發送消息
    - 比如 lambda 的 compute 要遍歷其 data 域
      並向其中數據[遞歸地]發送 compute 消息
      比如 lmabda 的 type-check 要遍歷其 type 域
      並向其中數據[遞歸地]發送 type-check 消息

  - 方法的效果都是改變機器的狀態

  - 注意 實現層 和 被實現層 兩層語言

  - 被完全展開的語法 要能夠清晰簡單地描述如何定義數據

  --------------------

  - k ::
       注意 jo 與 data 有別
       如上所述 應該是 jo

  - x ::
       jo 與 data 有別但是又有重疊
       可以依接口函數來區別類

  - k ::
       我們好像不需要 oo 中的繼承機制

  - x ::
       有時同一個方法可以作用於多種類型
       繼承機制 可能就是爲此

  - k ::
       我們可以在使用 js 的同時
       用 js 寫一個 runtime 來改變它
       然後把 sexp 的簡單語法 編譯到這個 runtime 的特殊 js
       可爲找錯而實現 查找可接受某組 message 的所有數據類型 等等

  - x ::
       還有很多問題
    1. 傳遞消息的語法
       後綴 或 中綴
    2. 數據 消息 函數 之分

  - k ::
       數據構造子 就是 oo 的 class
       與 pattern-matching 不同
       這裏的每個數據之域都要有名
       如果說 函數都是消息
       那麼 數據構造子 作爲函數就是特殊的消息
       因爲沒有數據來接受這個消息
       [或者說接受這個消息的數據被隱藏了起來]

  - x ::
       如若如此
       如果我們還使用後綴表達式的話
       棧處理函數也是特殊的消息
       難點是消息是可以帶有參數的
       這裏是否要求消息的所有參數都有名
       如若都有名則看似純粹的後綴表達式也可行
       不過語法上這可能過於極端了

  - k ::
       不妨區分數據域之求取消息 object.field
       與帶有參數的消息 object (message arg ...)
       不帶參數的消息 不做特殊處理 object (message)

  - k ::
       如此看來
       一個帶有局部變元支持的 類 forth 語言 就可以勝任了

  - x ::
       既然構造子的每個域都要有名稱
       那麼 構造子在被當作函數而作用時
       就需要 optional argument
       object.field 的語法也不對
       因爲 object 是棧頂元素而已
       並不出現在文本中

  - k ::
       我們可以假設順序
       #+begin_src scheme
       (data var id level)
       #+end_src
       這樣 var 就可以直接作用於棧中的兩個元素了

  - x ::
       我發現 object (message arg ...)
       應該寫爲 (message arg ...)
       因爲 object 是棧頂的數據 它不一定出現在文本中
       那麼 (message arg ...) 就是默認以棧頂元素爲主參數的
       或者我們可以用 {message arg ...}
       而把 (message arg ...) 留給 (define ...) 之類的東西

  - k ::
       構造數據也可想象用
       new (constructor-as-message arg ...)
       先置 new 於棧頂

  - x ::
       我想我們還是簡單地利用順序吧
       再看消息傳遞的語法
       (message arg ...) 中的 arg 都是一些直接數據或變元
       或者說 arg ... 計算出的結果返回到一個臨時棧中

  - k ::
       變元機制就用 #name 與 :name 的對子吧

  - x ::
       我想我們已經可以在實現之前試用我們的語法來實現 sequent0 了

* >< 總結 自然語言對算法的描述

* 語法試用

  - x ::
       比如
       #+begin_src scheme
       (+ var id level)
       (~ var (compose)
          ds (push bs (deep :self)))
       (~ var (unify :data)
          ...)
       (* swap
          #1 #2
          :1 :2)
       ;; when you are defining a method
       ;; all the arguments in the returned new data-stack are named

       (define-data var id level)
       (define-method var (compose)
         ds (push bs (deep :self)))
       (define-method var (unify :data)
         ...)
       (define-function swap
         #1 #2
         :1 :2)
       #+end_src

  - k ::
       下面我們還需要明白如何實現 if 或者單純用 cond
       我們從之間的 rc1 找靈感

  - x ::
       我們可以有 'if' as message
       (if [] [])
       或者 還有 'cond' as message
       (cond [] []
             ...)

  - k ::
       如此的話 if 是 true 和 false 的 message
       但是 cond 是誰的 message 呢

  - x ::
       所以不能
       (cond [] []
             ...)
       而只能
       [ [] []
         ...
       ] (cond)
       這樣 cond 就是 list 這個數據的 message

  - k ::
       還有多參數的 combinator
       比如 linrec binrec
       應該如何處理

  - x ::
       我知道了
       只要不要把 cond 實現爲 list 的 message
       而實現爲一般的對棧中的 list 做 processing 的函數就好了
       不是
       [ [] []
         ...
       ] (cond)
       而是
       [ [] []
         ...
       ] cond
       或
       [ {} {}
         ...
       ] cond
       同樣 linrec binrec ifte 也是如此

  - k ::
       看起來是不錯
       既然這裏用到了很多 list
       那麼 這個語言應該如何對待 list 呢

  - x ::
       既然 list 中可以包含各種類型的數據
       那麼我們就把 list 處理函數都實現爲一般的 非消息型函數
       並且 我們甚至可以把 object 這個數據結構如何用 list 實現給暴露出來

  - k ::
       literal list 的語法是什麼

  - x ::
       literal list of data 是 []
       literal list of jojo 是 {}

  - k ::
       我們還要區分 定義消息的語法 與 定義一般函數的語法

  - x ::
       沒錯
       如果說 object 要暴露出來
       那麼 object 機制可能就能在語言內部實現
       但是我想還是不要暴露的好
       因爲這樣我們就有更多優化語言的機會

  - k ::

* 再 語法試用

*** data & jo

    #+begin_src scheme
    ;; data
    (+ var                id   level)
    (+ cons               name {data ...})
    (+ arrow              jojo jojo)
    (+ lambda             type body)
    (+ bind               data sub-data)
    (+ trunk              type (vector trunky) index)

    ;; trunky
    (+ trunky-todo        body {data ...})
    (+ trunky-done        {data ...})

    ;; can be viewed as type
    ;; jojo               {jo ...}
    ;; body               {arrow ...}

    ;; vector thus unique
    ;; ls (level binding-list) in id for commit
    (+ id                 (vector (name . counter) ls))

    ;; jo
    (+ call               name)
    (+ apply)
    (+ ex-bind            jo   jojo)
    (+ im-bind            jo   jojo)
    #+end_src

*** 妙

    - x ::
         我們現在可以定義
         數據構造子
         消息
         函數
         還需要定義變元

    - k ::
         作爲一個動態語言
         我們只要試用一個 box
         使得裏面可以保存任何 data 就好了

    - x ::
         那麼相關的語法如何設計呢
         必須引入新的語法關鍵詞了
         比如
         #+begin_src scheme
         (= ns [])
         #+end_src
         就像之前設計 類似 forth 的全局變元一樣
         這裏又有兩種選擇了
         即 比如當 ns 的名字出現時
         默認的處理方式是給出 box 本身
         還是 box 中的值

    -----------------

    - x ::
         我們竟然迂迴曲折地選擇了這麼久
         也選擇不出 '正確的' 實現方式
         遠方的朋友的友好的信件看起來都像是催促了

    - k ::
         可是說我們是在這種思考中積累經驗嗎

    - x ::
         那看似是在爲自己的行爲開脫

    - k ::
         很難找到 '正確' 的實現方法
         所謂 '正確' 本身之存在性也值得懷疑
         如何找尋 之問本身看來也失意
         正誤爲一問
         失意爲一問
         失意之問 之意又生問

    - x ::
         啊
         如此如此
         鬧怪欲停問而行
         需循方生方死之法

    - k ::
         而行者循者看來也失悟
         文字比之行動之弱
         由此得以觀知

    - x ::
         而文之爲行
         亦行也
         何高下強弱之分
         古之真人
         化其爲醇酒而樂享之

*** 關於全局變元

    - x ::
         關於全局變元
         必須從語法上區別
         得其地址
         或取其地址下的值
         這兩種語義
         #+begin_src scheme
         (^ <ns> [])
         ns
         <ns>
         #+end_src

    - k ::
         或者我們可以學習 clojure erlang 等等其他語言對全局變元之限制
         以獲得更好的函數式語義

*** 實現

    - x ::
         我們就使用上面所定下的語法吧
         我們一邊用假想的語言寫 sequent0
         一邊想辦法實現這個語言
         總之就是一個簡單那的解釋器
         編譯到 js 若是不行
         就用 js 或 scheme 寫一個簡單那的解釋器

    - k ::
         scheme 用得太多
         我們這次用 js 吧

    - x ::
         但是我們可能脫離不了 scheme
         我暫且希望我們的語言實現起來能極爲簡單
         這樣所使用的語言就不重要了
         但是 但是
         如果要自己處理命名空間
         就難以做到極端簡單

    - k ::
         type +
         method ~
         function *
         global-var ^
         這就是我們要的全部了
         而且
         其實命名空間也可以先不用 hash-table 處理
         直接用一個 name-list

* 再試

*** data & jo

    #+begin_src scheme
    ;; data
    (+ var                id   level)
    (+ cons               name data-list)
    (+ arrow              antecedent succedent)
    (+ lambda             type body)
    (+ bind               data sub-data)
    (+ trunk              type trunky index)

    ;; trunky
    (+ trunky-todo        body data-list-ref)
    (+ trunky-done        data-list-ref)

    ;; can be viewed as type
    ;; jojo               {jo ...}
    ;; body               {arrow ...}

    ;; vector thus unique
    ;; ls (level binding-list) in id for commit
    (+ id                 (vector (name . counter) ls) ref)

    ;; jo
    (+ call               name)
    (+ apply)
    (+ ex-bind            jo   jojo)
    (+ im-bind            jo   jojo)
    #+end_src

*** stack

    #+begin_src scheme
    (^ <ns> [])
    (^ <ds> [])
    (^ <bs> [])
    (^ <rs> [])
    (^ <gs> [])

    (* push
       )
    (* push-list
       )
    (* pop
       )
    (* pop-list
       )
    #+end_src

*** note

    - x ::
         我要用 rc1 來實現 sequent0
         同時也要用 rc1 來實現 at1

    - k ::
         我們可以先試試看 rc1 實現 sequent0 的核心部分時的感受
         這樣就是強迫的自上而下的編程了
         因爲不光其中所調用的底層函數根本還沒有實現
         甚至這個語言本身也沒有實現

    - x ::
         就這麼辦
         但是還有一個問題
         我之前說
         [] 爲 list
         {} 爲 jojo
         其實是錯誤的
         因爲 rc1 里根本就沒有 jojo
         rc1 的 meta-programming 應該如何設計還不知道

    - k ::
         我想被基本的符號模式所區分的 lex
         都應該在 meta-programming 有自己的數據類型存在
         這樣 meta-programming 本身就更結構化

    - x ::
         基本的 符號模式 有

         global-constructor
         .field
         (message . body)

         global-function

         <global-data-box>
         global-data

         :local-name
         #local-name

         [element ...]

         頂層的 + ~ * ^ 除外
         它們之後甚至可以被處理爲縮進語法
         而不用 sexp

    - k ::
         注意 這裏只有下面三個是有歧義的
         global-constructor
         global-function
         global-data
         其他都是在語法上就能夠區分出來的

    - x ::
         在元編程時
         如果我們使用編譯語義
         那麼我們就可能在編譯時 確定這三種同樣模式的 symbol 之具體類型
         這樣我們就能在元編程是完全區分他們了

    - k ::
         還有一個問題是
         constructor 所構造出來的東西應該如何處理

    - x ::
         也許我們應該讓這些東西完全不透明
         儘管開始的時候我們處理它們的方式可能很簡單

    - k ::
         沒錯
         我想我們使用編譯到 js 的實現方式
         在編譯的過程中考慮元編程能力

*** >< compose

    #+begin_src scheme
    ;; on

    #+end_src
