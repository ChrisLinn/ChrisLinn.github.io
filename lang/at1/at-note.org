#+title: algebraic topology note

* todo

  - 現在有了
    1. 構造幾何對象的形式語法
    2. 判斷(低階)幾何對象之間的同倫等價的方法
    而 引入同倫等價這個概念 最初就是爲了在計算同倫群時
    給出 判斷群中元素是否等價的方式

* a reading guide of hott

  - always concern yourself about the geometry aspects
    of the formal language,
    because the language is to be used as a formalization
    of the geometry intuition of human.

  - a type is a geometry object.
    a definition of a geometry object is just like
    a description of how you could draw a picture of the geometry object.

  - constructors are used to construct geometry objects.
    | level | geometry object |
    |-------+-----------------|
    |     0 | point           |
    |     1 | path            |
    |     2 | surface         |
    |   ... | ...             |

  - cell complex
    注意 不能跨階粘貼邊界
    boundary
    ><><><
    note that the '=' based syntax is not 對稱
    因爲 (例如就二階元素而言) p = q 等價於 p q^{-1} = 1
    在高階的情形更是如此

  - a dependent type is a type family,
    a type family is a fibration,
    a function of such type is a section of the fibration.

  - all functions are considered continuous.
    when you want to find a function of certain type,
    such as (A -> B), (x:A -> B(x)),
    it must satisfy some constrains to be continuous.
    what are such constrains ?

    - a fibration is a type family,
      a type family can be used as a function.
      to be able to describe the constraint of continuous function,
      what constrains a type family must satisfy ?

  - a type is a proposition,
    a function body of such type is its proof.
    a proof is a record of deduction steps
    that finally would arrive the proposition.

  - what is the meaning of being constructive ?

* the meaning of being constructive

  - deduction system 與 rewrite system 之間的關係
    首先以 deduction system 爲本
    設計用來記錄 record of deduction steps 的語法
    此時的語法並沒有 rewrite 的意義

  - rewrite 的意義來原於
    1. constructor 作爲平凡的函數體
    2. 定義函數體的 pattern match 語法使得新定義的函數體描述 rewrite

  - 注意
    type class 的接口函數名字 與 constructor 不同
    不能被當作平凡函數體
    我想這就是 logic harmony
    constructor 構造
    而 pattern match 解構

* constraint of fibration

  - to be able to describe the constraint of continuous function,
    a fibration must also has a function body for its transport.
    because constraints of continuous function of fibration
    are described by transport.

  - 如果 一個 dependent type 不足以確定一個 fibration
    即 還需要明確指定其 transport
    那麼 就不可能有一般的 獲得 transport 的函數體 的方式

* 單值性 與 連續性

  - 當把 path 理解爲 geometry object 時
    函數定義的基本限制是 連續性

  - 當把 path 理解爲 引入的等詞時
    函數定義的基本限制是 也可以被理解爲 單值性

* higher inductive definition

  - ~ 是遞歸展開
    = 是遞歸基礎

* >< continuous

  - (A -> B)

  - (x:A -> B(x))

* (Σ2 ~> S^1) 與 (ΣΣ2 ~> S^2)

  - 函數之間的 同倫 記 '~'
    空間之間的 同倫等價 記 '~>'

  - 目前所有的計算都來源於想要證明
    Σ2 ~> S^1 與 ΣΣ2 ~> S^2
    證明 '~>'
    即 構造兩個作爲 fibration 的特殊 path space 中的元素
    f : (A ~> B)
    g : (B ~> A)
    k : ((a : A) -> a f g = a)
    z : ((b : B) -> b g f = b)

* curry vs uncurry

  #+begin_src scheme
  (def f
    (lambda (-> [A] [B])
      ...))
  (def g
    (lambda (-> [A] [B])
      ...))

  ;;;; f ~ g

  ;; curry
  (def k
    (lambda (-> [A %:a] [:a f :a g ==])
      ...))

  ;; uncurry
  (def h
    (lambda (-> [A I] [B])
      {(-> [:a 0] [:a f])
       (-> [:a 1] [:a g])}
      ;; an extension problem indeed
      ...))
  #+end_src

* (bool-suspend ~> sphere-1)

  #+begin_src scheme
  (def sphere-1
    (type (-> [] [type])
      b (-> [] [sphere-1])
      loop (-> [] [(== b b)])))

  (+ bool : type
     0 : bool
     1 : bool)

  (+ bool-suspend : type
     n : bool-suspend
     s : bool-suspend
     m : (bool -> (n = s)))

  (~ f : (bool-suspend -> sphere-1)
     (n -> b)
     (s -> b)
     f : ((n = s) -> (b = b))
     (0 m -> loop)
     (1 m -> b rf))

  (~ g : (sphere-1 -> bool-suspend)
     (b -> n)
     g : ((b = b) -> (n = n))
     (loop -> {0 m 1 m rev}))

  (~ g f : (sphere-1 -> sphere-1)
     (b -> b)
     g f : ((b = b) -> (b = b))
     (loop -> loop))

  (~ f g : (bool-suspend -> bool-suspend)
     (n -> n)
     (s -> n)
     f g : ((n = s) -> (n = n))
     (0 m -> {0 m 1 m rev})
     (1 m -> n rf))

  (~ :k : ((:x : bool-suspend) -> (:x f g = :x))
     {n :k : (n = n)}
     {s :k : (n = s)}
     :k : ((:p : (n = s)) -> (n :k (:p :k tp) = s :k))
     {0 m :k : ((0 m f g) rev n :k 0 m = s :k)}
     {1 m :k : ((1 m f g) rev n :k 1 m = s :k)}
     (<solve>
      n :k == n rf
      s :k == 1 m
      0 m :k == 1 m rf
      1 m :k == 1 m rf))
  #+end_src

* (bool-suspend-suspend ~> sphere-2)

  #+begin_src scheme
  (+ sphere-1 : type
     b : sphere-1
     loop : (b = b))

  (+ sphere-2 : type
     b2 : sphere-2
     surf : (b2 rf = b2 rf))

  (+ bool : type
     0 : bool
     1 : bool)

  (+ bool-suspend : type
     n : bool-suspend
     s : bool-suspend
     m : (bool -> (n = s)))

  (+ bool-suspend-suspend : type
     n2 : bool-suspend-suspend
     s2 : bool-suspend-suspend
     m2 : (bool-suspend -> (n2 = s2)))

  (~ f : (bool-suspend-suspend -> sphere-2)
     (n2 -> b2)
     (s2 -> b2)
     f : ((n2 = s2) -> (b2 = b2))
     (n m2 -> b2 rf)
     (s m2 -> b2 rf)
     f : ((n m2 = s m2) -> (b2 rf = b2 rf))
     (0 m m2 -> surf)
     (1 m m2 -> b2 rf rf))

  (~ g : (sphere-2 -> bool-suspend-suspend)
     (b2 -> n2)
     g : ((b2 rf = b2 rf) -> (n2 rf = n2 rf))
     (surf -> {0 m m2 1 m m2 {n m2 s m2 rev}}))

  (~ f g : (bool-suspend-suspend -> bool-suspend-suspend)
     (n2 -> n2)
     (s2 -> n2)
     f g : ((n2 = s2) -> (n2 = n2))
     (n m2 -> n2 rf)
     (s m2 -> n2 rf)
     f g : ((n m2 = s m2) -> (n2 rf = n2 rf))
     (0 m m2 -> {0 m m2 1 m m2 {n m2 s m2 rev}})
     (1 m m2 -> n rf rf))

  (~ g f : (sphere-2 -> sphere-2)
     (b2 -> b2)
     g f : ((b2 rf = b2 rf) -> (b2 rf = b2 rf))
     (surf -> surf))

  (~ :k : ((:x : bool-suspend-suspend) -> (:x f g = :x))
     {n2 :k : (n2 = n2)}
     {s2 :k : (n2 = s2)}
     :k : ((:p : (n2 = s2)) -> (n2 :k (:p :k tp) = s2 :k))
     {n m2 :k : (n2 :k n m2 = s2 :k)}
     {s m2 :k : (n2 :k s m2 = s2 :k)}
     :k : ((:h : (n m2 = s m2)) -> (n m2 :k (:h :k tp2) = s m2 :k))
     ;; 這裏的 tp2 使用比 hott 更高階的類型
     {0 m m2 :k : (><><><)}
     {1 m m2 :k : (><><><)}
     (solve-by
      ><><><))
  #+end_src

* >< tp 與 apd

  #+begin_src scheme
  ;; fibration
  F := ((:x : A) -> :x P)
  ;; 每個 fibration 必須有 tp
  (* (F tp) : ((:x = :y) -> (:x P ~> :y P)))
  ;; section
  (* k : ((:x : A) -> :x P))
  ;; k 和 (F tp) 的作用 出現在 (k apd) 的類型中
  (* (k apd) : ((:p : (:x = :y)) -> (:x k (:p F tp) = :y k)))
  ;; (k apd) 的函數體的存在性 就是限制 k 的函數體的方程
  ;; 所謂 限制
  ;;   即 x k 與 y k 不能在 x P 與 y P 中任意取值
  ;;   即 有邊相連的點 x 與 y 其值 x k 與 y k 受邊所生成的方程的限制
  #+end_src

  - 而古典理論中 描述 fibre bundle 的方式是
    projection : total-space -> base-space
    這裏 total-space 的定義本身就描述了全局結構

  - fibre bundle 中 fibre 是固定的空間
    而 fibration 中 fibre 是可依賴 x 的
    此時 fibre 不必是相等的空間
    但是必須是同倫等價的
    這就是 要求 tp 存在的原因

  - 而在形式理論中 描述 fibration 的方式是
    F := (x : base-space -> x P)
    此時 total-space 是構造出來的 F
    需要額外用 tp 給出 fibration 的全局結構
    - 所謂 全局結構 或 全局信息
      其實也是局部的 只不過不是就 point 來描述
      而是就 path 或高階幾何元素來描述而已

  - apd 的類型中 有 tp 的作用 可能是爲了
    能夠以線性的方式表示封閉的高階 path

* at1 之用

*** 引

    - x ::
         我知道我不必找到一個終極的目的之後
         才能爲了這個目的而行動
         我可以用別的方式來理解行動
         或者來說服自己去行動
         但是
         亞里士多德的書給了我們一些希望
         不是嗎

    - k ::
         at1 如果能促進 at
         那麼 at 之用就是 at1 之用

    - x ::
         但是我想找更直接的用

* note

   - pattern match is about reverse and reversible function
     we need to learn more about reverse and dual

   - ><><><
     in a practical langauge
     beside algebraic datatype
     there is also record
     which is used as the named product type
     some interface functions can be generated by these names
     - I need to designed syntax for this too
       maybe {} should be used for them

   - if type can be generated
     then we have many ways to define a type
     - thus how a type is defined
       should be part of the metadata of a type
     - thus how a function is defined
       should also be part of the metadata of a function

   - meta programming is about macro
     when we are able to write macro
     how should we type macro

   - to be constructive
     a quotient space should be defined by a natural-projection
     maybe fiber bundle should also be defined by projection

   - ><><><
     the gluing of adjunction is the same as
     that of the gluing of fibers ?

* the extension problem

  #+begin_src scheme
  (def inclusion
    (lambda (-> [(: :a type) (: :x type)
                 (< :a :x) drop]
                (-> :a :x))
      (-> [:a :x]
          (lambda (-> :a :x)
            (-> :v :v)))))

  ;; in the view of sze-tsen-hu
  ;; extension problem is the main kind of general problem of topology

  ;; to solve the extension problem
  ;; is to solve an equation in the continuous function space
  ;; is to find x for given condition

  (def g
    (lambda (-> [(< A X) drop A]
                [Y])
      ...))

  (def f
    (lambda (-> [X]
                [Y (== [g]
                       [A X inclusion @ f])])
      ...))
  #+end_src

* the method of algebraic topology

  - to induce algebraic equation from continuous equation
    is the method of algebraic topology

  #+begin_src scheme
  (def H/induce
    (lambda (-> []
                [])
      (-> []
          [])))

  ;; should act like the following
  ;;   this means the language must be powerful enough
  ;;   to handle function have type (-> [...] [...])
  ;;   it is serious meta programming

  (def g
    (lambda (-> [{< A X} A]
                Y)
      ...))

  (def f
    (lambda (-> X
                [Y (== [g]
                       [A X inclusion @ f])])
      ...))

  (def [g H/induce]
    (lambda (-> [{< A X} A empty-space :m H]
                [Y empty-space :m H])
      ...))

  (def [f H/induce]
    (lambda (-> [X empty-space :m H]
                [Y empty-space :m H
                   (== [g H/induce]
                       [A X inclusion @ H/induce f H/induce])]))
    ...)

  ;; many styles pf homology theory
  ;;   which is the best for implementation

  ;; without serious meta programming power
  ;;   we can try the following limited definition of homology theory

  (def H
    (lambda (-> [(: :X space) (< :A :X) int]
                abelian-group)
      ...))

  (def H/induce
    (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                (-> [:X :A :q H] [:Y :B :q H])))
    (note H 作用於空間本身
          還需要一個 H* 作用於空間中的元素)
    (note 可能需要一個選擇函數
          來從 由 H* 得到的 abelian-group 中的元素
          選擇一個原來 space 中的元素
          這樣 實現 H/induce 就簡單了))

  (def boundary
    (lambda (-> [:X :A :q H]
                [:X empty-space :q 1 sub H])
      ...))
  #+end_src

* retraction

  #+begin_src scheme
  (def r
    (lambda (-> X
                [A (== [A id] [A X inclusion @ r])])
      ...))

  (def [r H/induce]
    (lambda (-> [X empty-space :m H]
                [A empty-space :m H
                   (== [A empty-space :m H id]
                       [A X inclusion @ H/induce r H/induce])])
      ...))
  #+end_src

* note quotient space

  - to define a quotient space
    is to lessen the equality

  - the construction of quotient space
    is also called topological identification

  - there are many patterns by which we can re-implement equality of a type

  - when one is trying to formalize a concept in math
    he should try to use all the implementation tech
    and all the language paradigms

  - but it seems we have a basic uniformed equality in the term-lattice
    re-implement of equality is to be built on top of it

* quotient/natural-projection

  - which can always be done by natural-projection

  #+begin_src scheme
  (def quotient/natural-projection
    (lambda (-> [(: :x type) (-> :x :y)]
                (: :z type))
      (-> [:x :p]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        [:a :p @ :b :p @ :y.eq @])}
           :z])))

  (def npj
    (lambda (-> [(: :x type) (: :z type) {/ :x :z}]
                (-> :x :z))
      (-> [:x :z]
          (lambda (-> :x :z)
            (-> :v :v)))))
  #+end_src

* quotient/acting-group

  #+begin_src scheme
  (def quotient/acting-group
    (lambda (-> [(: :x type) (< :g (-> :x :x))]
                (: :z type))
      (-> [:x :g]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        [{= :e (search :g)} :a :e @ :b :x.eq @])}
           :z])))
  #+end_src

* quotient/identity-element

  - by enlarging zero (or one) in algebraic structure

  #+begin_src scheme
  (def quotient/identity-set
    (lambda (-> [(: :x type) {with-interface sub :x} (< :x0 :x)]
                (: :z type))
      (-> [:x :x0]
          [{= :z (derive :x)}
           {= :z.eq (-> [:a :b]
                        {: [:a :b sub] :x0})}
           :z])))
  #+end_src

* ><><>< adjunction space

  #+begin_src scheme
  (def adjoin
    (lambda (-> [(: :x type) (: :y type) (-> [:a {< :a :x}] :y)]
                (: :z type))
      (-> [:x :y :g]
          [{= :z (derive (+ :x :y))}
           {= :z.eq (lambda (-> [:z :z] bool)
                      (-> [:a :b]
                          [{} ><><><]))}
           :z])))
  #+end_src

* >< extension equal to retraction of adjunction

  #+begin_src scheme
  (~ g : ((A < X) -> Y))

  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion @ r)))
  (~ f : (X -> Y
            (g = A X inclusion @ f))
     (:x -> :x p r))

  (~ f : (X -> Y
            (g = A X inclusion @ f)))
  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion @ r))
     ><><><)
  #+end_src

* >< mapping cylinder

  #+begin_src scheme
  (def f (lambda (-> X Y) ...))

  (def mapping-cylinder/p
    (lambda (-> (+ (X I) Y) [f mapping-cylinder])
      (-> [:x 1] [:x f])
      (-> [:x :i] [:x :i])
      (-> :y :y)))
  #+end_src

* >< from chain-complex to homology

* >< the cat of top

  - for the cat of top
    a top constructor is defined by
    specifying set-level construction
    and specifying the open set or closed set

* >< cell-complex

  - CW-complex
    C for closure-finite
    W for weak-topology

* note fiber space

* covering homotopy property

  #+begin_src scheme
  p : E -> B
  project : total-space -> base-space

  (def f (lambda (-> X B) ...))

  (~ f/homotopy : (X -> B))

  ;; cover is defined by abstract interface
  (~ cover )
  (~ f p cover : (X -> E
                    (p f p cover = f)))
  #+end_src

* note continuous

  - to say a map is continuous
    is to allow it to be used in the language

* set

*** note set theory vs type theory

    - ><
      what is this vs ?

    - class (in oo) is encoded by a list of interface functions
      type-class (in haskell) is encoded by a list of abstract interface functions
      which all seem like the dual of the poset structure of set as cat

    - the methods of set theory have no fault
      the fault is to not to view them with implementation in mind

*** the encoding of type

    #+begin_src scheme
    (def-type T
      T.C = [(c1 : (* -> T))
             (c2 : (* -> T))]
      T.G = [(g1 : (term -> bool))
             (g2 : (term -> bool))]
      T.I = [(i1 : (T -> *))
             (i2 : (T -> *))
             (note
               interface functions are implemented by term rewriting)
             (note
               interface can be limited by type-cless)])

    (T1 < T2 :=
        T1.C < T2.C
        T1.G > T2.G)

    (note
      T1.I < T2.I
      T1 is a quotient space of T2)

    (note
      comparing can only be done by comparing list of names
      or declared relation between names
      (naming itself is also a declaration))

    (note
      names are made as unique as possible
      this labor can be easied by a module-system or infer-system)

    (note
      constructor can be shared by different types
      thus can not infer a unique type from a constructor
      thus cut needs to do search and backtracing)

    ;; in the view of
    ;; function as proof and type as theorem and space

    (note
      union of two types as a list of glue operations
      intersection in the two types will intro new connection
      continuous is all about levels of glues
      maybe the main formal law of continuous condition is hidden in the union)

    (def-function union)
    (def-function intersection)

    (note
      the formalization of gluing
      must be with detailed info about the the gluing is done
      if i view union as gluing
      the info will be denoted by the global-naming-as-mark
      two types with the same constructor can still be seprated or not ?)

    (note
      to define a named type
      is to intro a named level structure over the space of terms)
    #+end_src

*** image and inverse-image of function

    #+begin_src scheme
    (~ f : (X -> Y))
    (+ A < X)
    (+ B < Y)
    (+ B inverse f = ((:x : X) {:x f : B}))
    (+ A f = ({:x : A} (:x f : Y)))
    #+end_src

*** >< cartesian product

    - cartesian product of two type is a special case of
      general cartesian product
      which is the space of section of fiber bundle
      (i.e. dependent function space)
      (not the total space)

    - actually we can see
      the dependent function space is not about fiber bundle
      but only about general cartesian product
      to get fiber bundle we need more info

* >< topology

*** note

    - ><
      how this would improve my understanding of
      the formalization of continuous function in my language

    - how the concept of continuous is formalized by abstract axioms of topology
      not only by open set but by the union and intersection functions

*** >< abstract axioms of topology structure

* homology

*** definition

    #+begin_src scheme
    (def H
      (lambda (-> [(: :X space) (< :A :X) int]
                  abelian-group)
        ...))
    (def H/induce
      (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                  (-> [:X :A :q H] [:Y :B :q H])))
      ...)
    (def boundary
      (lambda (-> [:X :A :q H]
                  [:X empty-space :q 1 sub H])
        ...))

    (def co-H
      (lambda (-> [(: :X space) (< :A :X) int]
                  abelian-group)
        ...))
    (def co-H/induce
      (lambda (-> [(-> [:X :A] [:Y :B]) (: :q int)]
                  (-> [:Y :B q co-H] [:X :A q co-H]))
        ...))
    (def co-boundary
      (lambda (-> [:X empty-space :q 1 sub co-H]
                  [:X :A :q co-H])
        ...))
    #+end_src

*** >< axioms

    #+begin_src scheme
    (def H/identity
      (lambda (-> [{: :id (-> [:X :A] [:X :A])} :id space/iso {: :q int}]
                  [:id :q H/induce abelian-group/iso])
        ...))

    (def H/compose
      (note
        this is always true
        for H/induce is recursively defined over function composition))
    #+end_src
