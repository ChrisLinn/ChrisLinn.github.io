#+title: algebraic-topology-1

* for reader

  - If you know how to implement a interpreter,
    try to imagine how you would implement this language.

* todo before leaving

*** note

    - I am thinking of leaving this project for a better life.
      Before leaving, I have to write down the topics I have touched
      by the psycho-logical order of my psyche, instead of the
      merely logical order of the topics.

*** cobordism

    - not all closed space can be boundary of 1-dim higher space.
      if two disjoint closed spaces, B1 and B2, are boundary of
      1-dim higher space C, then C is the cobordism of B1 and B2,
      B1 and B2 are called cobordant.

*** immersion and imbedding

    - a map is a (topological) immersion.
      with conditations, a map can be a imbedding.
      thus different kinds of map need to be distinguished in the language.

*** to be expressed more explictly

    - continuity-check
    - the ways to glue
      - the explict way to glue 1-level parts
      - the implict way to glue 2-level parts
    - boundary conditation in type definition
      - way 0-level parts can only be glued by path ?

*** hopf fibration

    #+begin_src scheme
    (def I
      (type space
        i0 i1 (-1 <>)
        i01 (0 i0 i1)))

    (def sphere-1
      (type (-> space)
        b1 (-> (-1 <>))
        loop (-> (0 b1 b1))))

    (* sphere-1 I)
    (* b1 i0)    : (-1 (* sphere-1 I))
    (* b1 i1)    : (-1 (* sphere-1 I))
    (* b1 i01)   : (* b1 (0 i0 i1))
    -->            (0 (* b1 i0) (* b1 i1))
    (* loop i0)  : (* (0 b1 b1) i0)
    -->            (0 (* b1 i0) (* b1 i0))
    (* loop i1)  : (* (0 b1 b1) i1)
    -->            (0 (* b1 i1) (* b1 i1))
    (* loop i01) : (+ (* loop (0 i0 i1)) (* (0 b1 b1) i01))
    -->            (+ (1 (* loop i0) (* loop i1) rev)
                      (1 (* b1 i01) (* b1 i01) rev))
    -->            (1 (* loop i0) (* b1 i01)
                      (* loop i1) rev (* b1 i01) rev)

    (? sphere-1 I)
    (? b1 i0)    : (-1 (? sphere-1 I))
    (? b1 i1)    : (-1 (? sphere-1 I))
    (? b1 i01)   : (? b1 (0 i0 i1))
    -->            (0 (? b1 i0) (? b1 i1))
    (? loop i0)  : (? (0 b1 b1) i0)
    -->            (0 (? b1 i0) (? b1 i1))
    (? loop i1)  : (? (0 b1 b1) i1)
    -->            (0 (? b1 i1) (? b1 i0))
    (? loop i01) : (1 (? loop i0)
                      (? loop i1))

    (def sphere-1
      (type (-> space)
        b1 (-> (-1 <>))
        loop (-> (0 b1 b1))))

    (def sphere-2
      (type (-> space)
        b2 (-> (-1 <>))
        surf (-> (1 b2 refl))))

    (* sphere-2 sphere-1)
    (* b2 b1)     : (-1 (* sphere-2 sphere-1))
    (* b2 loop)   : (* b2 (0 b1 b1))
    -->             (0 (* b2 b1) (* b2 b1))
    (* surf b1)   : (* (1 b2 refl) b1)
    -->             (1 (* b2 b1) refl)
    (* surf loop) : (+ (* surf (0 b1 b1))
                       (* (1 b2 refl) loop))
    -->             (+ (2 (* surf b1) (* surf b1))
                       (2 (1 (* b2 loop)) refl))
    -->             (2 (* surf b1) (* surf b1)
                       (1 (* b2 loop)) refl)

    (? sphere-2 sphere-1)
    (? b2 b1)     : (-1 (? sphere-2 sphere-1))
    (? b2 loop)   : (? b2 (0 b1 b1))
    -->             (0 (? b2 b1) (? b2 b1))
    (? surf b1)   : (? (1 b2 refl) b1)
    -->             (1 (? b2 loop))
    (? surf loop) : (+ (? surf (0 b1 b1))
                       (? (1 b2 refl) loop))
    #+end_src

*** lens-space

    - how can we do a cutting-and-regluing
      to cut (* sphere-1 sphere-2)
      and to reglue it to sphere-3

    - is this the same as hopf fibration

    - what lens-space are equal to ?

    - different ways to construct lens-space
      - dehn-surgery
        - note that, we have a change of dim here
      - ><><><

*** the plan

    - Inspired by Bishop's plan
      and the treatment of algebraic-topology by sze-tsen-hu.

    - A concept is defined once we explain how to implement it in our language.
      - Just like in physics, a concept is operationally defined,
        once we explain how to measure it.

    - To define property of object
      by the solvability of problem fromed around the object.

* intro

  1. I will show how to design and implement a language
     to formalize and machine-lize
     a little part of algebraic topology.

  2. I call this prototype 'at1',
     which is an abbreviation of 'algebraic-topology-1'.

* simple-space

  1. In a language, we always have primitive elements,
     and many ways to compose elements to new compound element,
     also many ways to derive new element from old one.

  2. Here, I describe a simple way to construct spaces,
     so constructed spaces will be called simple-spaces,
     which constitute the first kind of primitive spaces in my language.
     Before having other ways to construct spaces,
     I will simply call them 'space' instead of 'simple-space'.

     - In algebraic topology,
       our simple-space is called
       CW-complex, cell-complex or cellular polytopes.

  3. A space is constructed part by part.

  4. A part is of certain dimension,
     part of 0 dimension is point,
     part of 1 dimension is an interval,
     part of 2 dimension is a disk,
     part of 3 dimension is a ball,
     part of 4 dimension is a 4-cell,
     part of n dimension is a n-cell.

  5. The way to construct a space from parts,
     goes from low dimension to high dimension.
     I will take a >< as example.

     - In 0 dimension,

       we name all the points of the space.

       #+begin_src scheme
       (type space
         a1 a2 a3 a4 (-1 <>))
       #+end_src

     - In 1 dimension,

       we name all the intervals of the space,

       and for each interval,
       we attach its two end points to two points of the space
       [the two points of the space might be the same point],

       so that the boundary of the interval
       can be viewed as two points of the space.

       #+begin_src scheme
       (type space
         a1 a2 a3 a4 (-1 <>)
         b12 (0 a1 a2)
         b13 (0 a1 a3)
         b14 (0 a1 a4)
         b23 (0 a2 a3)
         b24 (0 a2 a4)
         b34 (0 a3 a4))
       #+end_src

       For example, the boundary of 'b12' are 'a1' and 'a2'.

       One can view 'b12' as a directed path pointing from 'a1' to 'a2'.

       We write two points in the keyword (0 ...), and the order matters.

     - In 2 dimension,

       we name all the disk of the space,

       and for each disk,
       we attach its boundary circle to a loop in the space.

       #+begin_src scheme
       (type space
         a1 a2 a3 a4 (-1 <>)
         b12 (0 a1 a2)
         b13 (0 a1 a3)
         b14 (0 a1 a4)
         b23 (0 a2 a3)
         b24 (0 a2 a4)
         b34 (0 a3 a4)
         c123 (1 b12 b23 b13 rev)
         c124 (1 b12 b24 b14 rev)
         c134 (1 b13 b34 b14 rev)
         c234 (1 b23 b34 b24 rev))
       #+end_src

       For example, the boundary of 'c123' can be described as
       going through 'b12' forwardly, 'b23' forwardly, and 'b13' backwardly.

       We write '(1 b12 b23 b13 rev)' to denote this loop.

       In the keyword (1 ...) 1-dimensional parts [intervals]
       are glued together, in which
       the right end point of one interval must matches
       the left end point of the next interval.

       The 'rev' follows 'b13', is saying 'go through b13 backwardly',
       thus during the gluing,
       the left and right end points of 'b13' are reversed.

       ><><>< need close check


     - In 3 dimension,

       #+begin_src scheme
       (type space
         a1 a2 a3 a4 (-1 <>)
         b12 (0 a1 a2)
         b13 (0 a1 a3)
         b14 (0 a1 a4)
         b23 (0 a2 a3)
         b24 (0 a2 a4)
         b34 (0 a3 a4)
         c123 (1 b12 b23 b13 rev)
         c124 (1 b12 b24 b14 rev)
         c134 (1 b13 b34 b14 rev)
         c234 (1 b23 b34 b24 rev)
         d1234 (2 c123
                  c124 (1 b14 b24 rev b23 b13 rev) glue-for-border
                  c134 (1 b34 b24 rev b23) glue-for-border
                  c234 (1) glue-for-border))
       #+end_src

       -


  6. syntax in (0 ...) (1 ...) (2 ...) are different,
     but syntax in (2 ...) (3 ...) (4 ...) ... are similar.
     because (0 ...) is special, in the sense that, ><><><
     and (1 ...) is special, in the sense that, ><><><
     and the nature of (2 ...) (3 ...) (4 ...) ... are ><><><

  7. in (key1 ... (key2 ...))
     key2 might be a marker for key1 which follows the rule of key1
     or itself a key which follows its own rule

* ><

*** >< 語法的難點

    - 語法的難點並不出現在構造過程的前幾階
      glue 首先出現在 dc 的 type 限制中

    - 0-level
      a : T
      任意引入

    - 1-level
      b : a0 == a1
      [即使是 a0 == a0 也不能消去 而使得信息減少]

    - 2-level
      c : b1 + b2 - b3 - b4

    - 每次 glue 的時候
      有兩體
      兩體都有邊界
      語法要能夠指出是就哪個公共邊界來做 glue

    - 1-level 元素的邊界很簡單
      爲了指明就哪個公共邊界來 glue
      只要用 + - 就好了
      比如
      b1 + b2 - b3 - b4
      對於 2-level 元素就有
      c1 [ ] c2 [ ] c3 [ ] c4
      這裏 [ ] 有兩種設計方法
      - (積)
        寫出 glue 之後的複合元素的邊界
        此時 典型的認知過程是
        看出 兩體就公共邊界 glue 之後 所得到的邊界是什麼
        [在低階情形這是利用等式代換來完成的]
      - (微)
        寫出 每次變化的細節
        [比如 1-level 時的 + - 就是如此]

*** >< about the example

    - 如上的語法設計到了搜索
      並非是完全信息充分的語法
      但是可以依照這個來定義完全信息充分的語法
      在這個基礎上的改進
      可以看成是增加信息以保證唯一搜索

    - 上面這些以數字爲語法關鍵詞的 sexp
      都是相對自治的 不同 level 上語法可能都不一樣

    - 我想這種描述邊界而自動搜索的語法可能纔是正確的
      否則 高階幾何體的 glue 細節實在是難以用充分的語法描述
      但是
      即便是有自動搜索
      還是要設計信息充分的語法來向用戶展示搜索的結果

*** >< semantic

    - semantic is more important than syntax,
      for semantic is our imagination about how the machine runs.

    - x ::
         with higher-inductive-type we can form data that can be composed
         假設我們用 di-graph 來實現 composed data
         那麼
         每次用到 composition [glue] 的時候
         就是對棧中已有的東西做 di-graph processing

    - k ::
         如若如此
         glue 本身就應該被實現爲一個 明顯的函數了
         如上我們用 (2 ...) 這個 macro
         隱藏了 glue-for-border 這個明顯的函數調用

* subspace relation

  - The subspace relation between spaces is encoded by parts.

* continuity-check

  - map have the following general types
    - level-same
    - level-diff
      - level-up
      - level-down

  - the border of the succedent of a dc
    must be empty,
    i.e. the succedent of a dc must be closed.

  - not only closed,
    a dc is also a characteristic-map
    ><><><

* >< primitive space v.s. compound space

  - compound space
    1. product space
    2. indexed space

  - a space is depicted by its parts and the borders of these parts.
    for example,
    we have rule for identifying parts of a product space and their borders.

  - there can be many way by which we can compose new spaces,
    each of such way must shows what is the parts of the space,
    and what is the borders of the parts.

  - ><><><
    rule for indexed space
    cellular ?

* note

  - Suppose the glue in (1 ...) is always explict,
    and the (+ ...) in the boundary rule is strict to position.

* >< product-space

*** the rule

    - it is assumed that the (+ ...) [the glue]
      in the rule is always not ambiguous.
      but I need more examples to be sure about this.

    #+begin_src scheme
    ;; [infix]
    ;; the rule
    (A * B) f : (boundary (A * B)) f
    (boundary (A * B)) = (((boundary A) * B) + (A * (boundary B)))
    ;; example of the rule
    (i01 * i0) f : (0 (i0 * i0) f (i1 * i0) f)
    (i1 * i01) f : (0 (i1 * i0) f (i1 * i1) f)
    (i01 * i1) f : (0 (i0 * i1) f (i1 * i1) f)
    (i0 * i01) f : (0 (i0 * i0) f (i0 * i1) f)
    (i01 * i01) f : (1 (i01 * i0) f (i1 * i01) f
                       (i01 * i1) rev f (i0 * i01) rev f)

    ;; [prefix]
    ;; the rule
    (* A B) f : (boundary (* A B)) f
    (boundary (* A B)) = (+ (* (boundary A) B) (* A (boundary B)))
    ;; example of the rule
    (* i01 i0) f : (0 (* i0 i0) f (* i1 i0) f)
    (* i1 i01) f : (0 (* i1 i0) f (* i1 i1) f)
    (* i01 i1) f : (0 (* i0 i1) f (* i1 i1) f)
    (* i0 i01) f : (0 (* i0 i0) f (* i0 i1) f)
    (* i01 i01) f : (1 (* i01 i0) f (* i1 i01) f
                       (* i01 i1) rev f (* i0 i01) rev f)
    #+end_src

* >< extension-problem of partial map defined on subspace

* >< extension-problem and retraction-problem

* >< indexed-space

*** note

    - When defining a space, parts of it can be indexed
      by parts of another space.
      Such a named indexing of parts is called an indexed-parts,
      which is also a subspace of the larger space.

    - Note that,
      if the indexing is to be viewed as a map,
      it would be a level-up map.

*** >< about 'I'

    - 'I' indexed by a space,
      is the suspension of the space.

* >< SPSG

  - same-position-self-gluing
    [for example: p * p^{-1}]

  - non-same-position-self-gluing
    can only happen,
    when there is at least one part of the border is repeating.
    [for example: p * p]

* simple principle of uncurry

  - a path in B is a function of type (I -> B)
    thus (A -> (path in B)) == (A -> (I -> B))
    can be uncurried to (A I -> B)

  - with the method of path-as-function
    we can define homotopy between pathes by equality of functions
    (f1 ~ f2)

* I

  #+begin_src scheme
  (def I
    (type space
      i0 i1 (-1 <>)
      i01 (0 i0 i1)))

  (def f
    (lambda (-> (* I I) X)
      (with (-> (* (-1 I) (-1 I)) (-1 X))
        (-> (* i0 i0) ...)
        (-> (* i0 i1) ...)
        (-> (* i1 i0) ...)
        (-> (* i1 i1) ...))
      (with (-> (* (-1 I) %:i (0 i0 i1))
                (0 (* :i i0) <>
                   (* :i i1) <>))
        (-> (* i0 (1 i01)) ...)
        (-> (* i1 (1 i01)) ...))
      (with (-> (* (0 i0 i1) (-1 I) %:i)
                (0 (* i0 (1 :i)) <>
                   (* i1 (1 :i)) <>))
        (-> (* (1 i01) i0) ...)
        (-> (* (1 i01) i1) ...))
      (with (-> (* (0 i0 i1) %:p0
                   (0 i0 i1) %:p1)
                (1 (* (1 :p0) i0) <>
                   (* i1 (1 :p1)) <>
                   (* (1 :p0) i1) <> rev
                   (* i0 (1 :p1)) <> rev)))
      ;; product 的各個部分 之邊界 所生成的 函數值
      ;; 想要融合成一個 封閉的圖形 其方式可能總是唯一的
      ;; 如果我允許 (1 ...) 內構造出不聯通的圖形
      ;; 那麼我可能就有機會描述出來這種唯一可能
      (note (1 (* (1 :p0) i0) <>
               (* (1 :p0) i1) <> rev
               (1 (* i0 (1 :p1)) <>
                  (* i1 (1 :p1)) <> rev) rev))
      (-> (* (1 i01) (1 i01)) ...)))
  #+end_src

* (bool-suspend ~> sphere-1)

  #+begin_src scheme
  (def sphere-1
    (type (-> space)
      b (-> (-1 <>))
      loop (-> (0 b b))))

  (def bool
    (type (-> space)
      #f #t (-> (-1 <>))))

  (def bool-suspend
    (type (-> space)
      n s (-> (-1 <>))
      m (-> bool (0 n s))))

  (def f
    (lambda (-> bool-suspend sphere-1)
      (with (-> (-1 bool-suspend) (-1 sphere-1))
        (-> n b)
        (-> s b))
      (with (-> (0 n s) (0 b b))
        (-> (1 #f m) (1 loop))
        (-> (1 #t m) (1 b refl)))))

  (def g
    (lambda (-> sphere-1 bool-suspend)
      (with (-> (-1 sphere-1) (-1 bool-suspend))
        (-> b n))
      (with (-> (0 b b) (0 n n))
        ;; (1 ...) is only needed when there is glue of elements of 2-level
        (-> (1 loop) (1 #f m #t m rev)))))

  (def [g f] ;; which is already id of sphere-1
    (lambda (-> sphere-1 sphere-1)
      (with (-> (-1 sphere-1) (-1 sphere-1))
        (-> b b))
      (with (-> (0 b b) (0 b b))
        (-> (1 loop) (1 loop)))))

  (def [f g]
    (lambda (-> bool-suspend bool-suspend)
      (with (-> (-1 bool-suspend) (-1 bool-suspend))
        (-> n n)
        (-> s n))
      (with (-> (0 n s) (0 n n))
        (-> (1 #f m) (1 #f m #t m rev))
        (-> (1 #t m) (1 n refl)))))

  ;; uncurry
  (def h ;; to proof (f g ~ id of bool-suspend)
    (lambda (-> (* bool-suspend I) bool-suspend)
      (extend-from
        (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
          (-> (* :x i0) [:x f g])
          (-> (* :x i1) :x)))
      (with (-> (* (-1 bool-suspend) %:a (0 i0 i1))
                (0 (* :a i0) <> (* :a i1) <>))
        (-> (* n (1 i01)) (1 n refl)
            : (0 n n))
        (-> (* s (1 i01)) (1 #t m)
            : (0 n s)))
      (with (-> (* (0 n s) %:b (0 i0 i1) %:i)
                (1 (* :b i0) <> (* s :i) <>
                   (* :b i1) <> rev (* n :i) <> rev))
        (-> (* (1 #f m) (1 i01)) (2)
            : (1 (1 #f m #t m rev) (1 #t m)
                 (1 #f m) rev (1 n refl) rev))
        (-> (* (1 #t m) (1 i01)) (2)
            : (1 (1 n refl) (1 #t m)
                 (1 #t m) rev (1 n refl) rev)))))
  #+end_src

* (bool-suspend-suspend ~> sphere-2)

  #+begin_src scheme
  (def sphere-2
    (type (-> space)
      b2 (-> (-1 <>))
      ;; no need for (1 b2 refl b2 refl rev) ?
      ;; for b2 refl is as identity
      surf (-> (1 b2 refl))))

  (def bool-suspend-suspend
    (type (-> space)
      n2 s2 (-> (-1 <>))
      m2 (-> bool-suspend (0 n2 s2))))

  ;; n m2 : (0 n2 s2)
  ;; s m2 : (0 n2 s2)
  ;; #f m m2 : (1 n m2 s m2 rev)
  ;; #t m m2 : (1 n m2 s m2 rev)

  (def f
    (lambda (-> bool-suspend-suspend sphere-2)
      (with (-> (-1 bool-suspend-suspend) (-1 sphere-2))
        (-> n2 b2)
        (-> s2 b2))
      (with (-> (0 n2 s2) (0 b2 b2))
        (-> (1 n m2) (1 b2 refl))
        (-> (1 s m2) (1 b2 refl)))
      (with (-> (1 n m2 s m2 rev) (1 b2 refl))
        (-> (2 #f m m2) (2 surf))
        (-> (2 #t m m2) (2 b2 refl refl)))))

  (def g
    (lambda (-> sphere-2 bool-suspend-suspend)
      (with (-> (-1 sphere-2) (-1 bool-suspend-suspend))
        (-> b2 n2))
      (with (-> (1 b2 refl) (1 n2 refl))
        (-> (2 surf) (2 #f m m2 (1 n m2 s m2 rev)
                        #t m m2 (1))))))

  (def [g f]
    (lambda (-> sphere-2 sphere-2)
      (with (-> (-1 sphere-2) (-1 sphere-2))
        (-> b2 b2))
      (with (-> (1 b2 refl) (1 b2 refl))
        (-> (2 surf) (2 surf)))))

  ;; (2 surf)
  ;; g =>
  ;; (2 #f m m2 (1 n m2 s m2 rev)
  ;;     #t m m2 (1))
  ;; f =>
  ;; (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev)
  ;;     (2 b2 refl refl) (1))
  ;; ==
  ;; (2 surf)

  (def [f g]
    (lambda (-> bool-suspend-suspend bool-suspend-suspend)
      (with (-> (-1 bool-suspend-suspend) (-1 bool-suspend-suspend))
        (-> n2 n2)
        (-> s2 n2))
      (with (-> (0 n2 s2) (0 n2 n2))
        (-> (1 n m2) (1 n2 refl))
        (-> (1 s m2) (1 n2 refl)))
      (with (-> (1 n m2 s m2 rev) (1 n2 refl))
        (-> (2 #f m m2) (2 #f m m2 (1 n m2 s m2 rev)
                           #t m m2 (1)))
        (-> (2 #t m m2) (2 n2 refl refl)))))

  (def h ;; to proof (f g ~ id of bool-suspend-suspend)
    (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
      (extend-from
        (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
          (-> (* :x i0) (* [:x f g]))
          (-> (* :x i1) (* :x))))
      (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                (0 (* :a i0) <> (* :a i1) <>))
        (-> (* n2 (1 i01)) (1 n2 refl) ;; (1 n m2 s m2 rev)
            : (0 n2 n2))
        (-> (* s2 (1 i01)) (1 s m2) ;; (1 n m2)
            : (0 n2 s2)))
      (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                   (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
        (-> (* (1 n m2) (1 i01)) (2 #t m m2)
            : (1 (1 n2 refl) (1 s m2)
                 (1 n m2) rev (1 n2 refl) rev)
            = (1 (1 s m2) (1 n m2) rev))
        (-> (* (1 s m2) (1 i01)) (2)
            : (1 (1 n2 refl) (1 s m2)
                 (1 s m2) rev (1 n2 refl) rev)
            = (1 (1 s m2)
                 (1 s m2) rev)
            = (1)))
      (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                (2 (* (1 n m2) (1 :i)) <>
                   (1 (* n2 (1 i01)) <>
                      (* (1 n m2) i1) <>
                      (* s2 (1 i01)) <> rev
                      (* (1 n m2) i0) <> rev)
                   (* (1 s m2) (1 :i)) <>
                   (1 (* (1 n m2) i1) <>
                      (* (1 n m2) i0) <> rev
                      (* (1 s m2) i1) <> rev
                      (* (1 s m2) i0) <>)
                   (* (2 :c) i0) <>
                   (1 (* (1 n m2) i1) <>
                      (* (1 s m2) i1) <> rev)
                   (* (2 :c) i1) <>
                   (1)))
        (-> (* (2 #f m m2) (1 i01)) (3)
            : (2 (2 #t m m2)
                 (1 (1 n2 refl)
                    (1 n m2)
                    (1 s m2) rev
                    (1 n2 refl) rev)
                 (2)
                 (1 (1 n m2)
                    (1 n2 refl) rev
                    (1 s m2) rev
                    (1 n2 refl) rev)
                 (2 #f m m2 (1 n m2 s m2 rev)
                    #t m m2 (1))
                 (1 (1 n m2)
                    (1 s m2) rev)
                 (2 #f m m2)
                 (1)))
        (-> (* (2 #t m m2) (1 i01)) (3)
            : (2 (2 #t m m2)
                 (2)
                 (2 n2 refl refl)
                 (2 #t m m2))))))

  (def h ;; to proof (f g ~ id of bool-suspend-suspend)
    (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
      (extend-from
        (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
          (-> (* :x i0) (* [:x f g]))
          (-> (* :x i1) (* :x))))
      (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                (0 (* :a i0) <> (* :a i1) <>))
        (-> (* n2 (1 i01)) (1 n2 refl))
        (-> (* s2 (1 i01)) (1 s m2)))
      (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                   (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
        (-> (* (1 n m2) (1 i01)) (2 #t m m2))
        (-> (* (1 s m2) (1 i01)) (2)))
      (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                (2 (* (1 n m2) (1 :i)) <>
                   (1 (* n2 (1 i01)) <>
                      (* (1 n m2) i1) <>
                      (* s2 (1 i01)) <> rev
                      (* (1 n m2) i0) <> rev)
                   (* (1 s m2) (1 :i)) <>
                   (1 (* (1 n m2) i1) <>
                      (* (1 n m2) i0) <> rev
                      (* (1 s m2) i1) <> rev
                      (* (1 s m2) i0) <>)
                   (* (2 :c) i0) <>
                   (1 (* (1 n m2) i1) <>
                      (* (1 s m2) i1) <> rev)
                   (* (2 :c) i1) <>
                   (1)))
        (-> (* (2 #f m m2) (1 i01)) (3))
        (-> (* (2 #t m m2) (1 i01)) (3)))))
  #+end_src

* >< fiber-space

  - After a construction of a fiber-bundle,
    we can proof the total-space is equal to another space,
    and by doing so, we get a level-down map from the space to the base-space.

  - level-down map can only be achieved by means of fiber-bundle.

* >< lifting-problem of ><><>< fiber-space

* >< lifting-problem and cross-section-problem

  - cross-section-problem can be viewed as
    lifting a subspace [instead of function] of the base-space,
    or just lifting the base-space itself [i.e. global cross-section].
