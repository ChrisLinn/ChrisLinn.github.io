#+title: syntax -- design and notes

* note

  - 上同調與微分形式有關

  - 古典的數學語言之所以晦澀
    是因爲 爲了 書寫的速度 而 放棄了 易讀性
    寫者在當時的思考環境下 可以很容易讀懂自己的簡記
    但是另外一個讀者 或者寫着本身脫離了當時的思考環境之後
    所寫的東西就需要解釋許久才能恢復意義
    有時甚至根本不可能再恢復意義

* design the language with the UI in mind

  - should I design the language with the UI in mind,
    or seprate the language and the UI ?

  - what kind of UI do I want ?

* on the type of syntax

  - infix
    prefix
    postfix
    borderfix

  - the asymmetry of writing method

* syntax to describe syntax

  | global | <name> |
  | local  | :name  |

  #+begin_src scheme
  (:= <name> (or ...))
  (:= :name (or ...))
  #+end_src

* general linguistics

  - compare to natural language,
    the syntaxes of programming languages are very simple.
    this single fact makes it very important to learn general linguistics.

* what is good syntax ?

  - good syntax make meaning explicit to reader.
    meaning is use.

* the psychology of reading code

  - by reading code in some language,
    you imagine how the machine would run.
    in your mind, you are always actively interpreting the code.
    the understanding of code happens in many levels.

  - this observation amost can guide a language designer.
    language should help the imagination.

* about modularity

  - it is such a burden
    to have to come up with unique name for every dc.
    it is also not satisfactory
    to prefix every dc with their space name.

  - a module-system must be design to solve this.
    a syntax for 'prefixing every dc with their space name'
    must be designed.
    but locally, in every source code file,
    the prefix can be omited.

  - I will use symbel-pattern '<space-name>/<dc-name>' here.
    or '<module-name>/<space-name>/<dc-name>'
    or '<module-name>/<function-name>'

* about simple macro system

  - in (key1 ... (key2 ...))
    key2 might be a marker for key1 which follows the rule of key1
    or itself a key which follows its own rule

* the syntax of 'belong to'

  - x -
    'belong to' = 'boundary ='
    目前 (lambda ...) 與 (type ...) 這兩個關鍵詞
    使得 'belong to' 的語義被隱藏起來了

  - k -
    之前之所以有這種 (lambda ...) 與 (type ...)
    是因爲想要統一 (def ...)
    並且使得可以形成沒有命名的數據
    但是這種對 '無名' 的追求是不切實際的

  - x -
    那麼我們就拋棄這種設計
    新設計的要求是
    1. make 'belong to' explicit
    2. [maybe] make the mark-lang richer

  - k -
    首先我們不能使用中綴表達式
    這必須當作是一個重要的原則
    否則語法就喪失就設計者而言的簡潔性了

  ------

  - x -
    我們不能取消 (lambda ...) 與 (type ...) 這種 '無名' 語法關鍵詞
    因爲 我發現 '有名' 的傾向 會使得名字氾濫

  - k -
    那我們增加 (: ...) 與 (= ...) 這兩個前綴表達式的語法關鍵詞
    用來做 assertion

  - x -
    中綴表達式的傾向體現於如下的例子中
    #+begin_src scheme
    (def h ;; to proof (~ [f g] [bool-suspend-suspend id])
      (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
        (extend-from
          (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
            (-> (* :x i0) (* [:x f g]))
            (-> (* :x i1) (* :x))))
        (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n2 (1 i01)) (1 n2 refl) ;; (1 n m2 s m2 rev)
              : (0 n2 n2))
          (-> (* s2 (1 i01)) (1 s m2) ;; (1 n m2)
              : (0 n2 s2)))
        (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                  (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                     (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
          (-> (* (1 n m2) (1 i01)) (2 #t m m2)
              : (1 (1 n2 refl) (1 s m2)
                   (1 n m2) rev (1 n2 refl) rev)
              = (1 (1 s m2) (1 n m2) rev))
          (-> (* (1 s m2) (1 i01)) (2)
              : (1 (1 n2 refl) (1 s m2)
                   (1 s m2) rev (1 n2 refl) rev)
              = (1 (1 s m2)
                   (1 s m2) rev)
              = (1))      )
        (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                  (2 (* (1 n m2) (1 :i)) <>
                     (1 (* n2 (1 i01)) <>
                        (* (1 n m2) i1) <>
                        (* s2 (1 i01)) <> rev
                        (* (1 n m2) i0) <> rev)
                     (* (1 s m2) (1 :i)) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 n m2) i0) <> rev
                        (* (1 s m2) i1) <> rev
                        (* (1 s m2) i0) <>)
                     (* (2 :c) i0) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 s m2) i1) <> rev)
                     (* (2 :c) i1) <>
                     (1)))
          (-> (* (2 #f m m2) (1 i01)) (3)
              : (2 (2 #t m m2)
                   (1 (1 n2 refl)
                      (1 n m2)
                      (1 s m2) rev
                      (1 n2 refl) rev)
                   (2)
                   (1 (1 n m2)
                      (1 n2 refl) rev
                      (1 s m2) rev
                      (1 n2 refl) rev)
                   (2 #f m m2 (1 n m2 s m2 rev)
                      #t m m2 (1))
                   (1 (1 n m2)
                      (1 s m2) rev)
                   (2 #f m m2)
                   (1)))
          (-> (* (2 #t m m2) (1 i01)) (3)
              : (2 (2 #t m m2)
                   (2)
                   (2 n2 refl refl)
                   (2 #t m m2))))))
    #+end_src

  - x -
    其中
    有如下的縮寫
    #+begin_src scheme
    (:> (2)
        (1 (1 n2 refl) (1 s m2)
           (1 s m2) rev (1 n2 refl) rev)
        (1 (1 s m2)
           (1 s m2) rev)
        (1))

    ==>

    (2)
    : (1 (1 n2 refl) (1 s m2)
         (1 s m2) rev (1 n2 refl) rev)
    = (1 (1 s m2)
         (1 s m2) rev)
    = (1)
    #+end_src

* infix notation

  #+begin_src scheme
  (note
    (2 surf)
    g =>
    (2 #f m m2 (1 n m2 s m2 rev)
       #t m m2 (1))
    f =>
    (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev)
       (2 b2 refl refl) (1))
    ==
    (2 surf))

  (note
    The above rewriting, if to be expressed in prefix notation,
    would be ::
    (= [(2 surf) g]
       (2 #f m m2 (1 n m2 s m2 rev)
          #t m m2 (1)))
    (= [(2 #f m m2 (1 n m2 s m2 rev)
           #t m m2 (1)) f]
       (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev)
          (2 b2 refl refl) (1)))
    (= (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev)
          (2 b2 refl refl) (1))
       (2 surf))
    I think this might be where we really need infix notation.)
  #+end_src

* should we free the use of '[]' or using ',' as clojure ?

  - x -
    首先我們總結一下現象

    #+begin_src scheme
    (: [n m2] (0 n2 s2))
    (: [s m2] (0 n2 s2))
    (: [#f m m2] (1 n m2 s m2 rev))
    (: [#t m m2] (1 n m2 s m2 rev))
    #+end_src
    這裏 [] 單純是爲了讓人知道 [] 內的是一個單一的元素

    #+begin_src scheme
    (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
      (-> (* :x i0) [:x f g])
      (-> (* :x i1) :x))
    #+end_src
    這個被認爲是下面的縮寫
    #+begin_src scheme
    (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
      (-> [(* :x i0)] [:x f g])
      (-> [(* :x i1)] [:x]))
    #+end_src
    這裏
    (-> ...) 內 [] 使得多個參數和多個返回值成爲可能
    [雖然 這個例子中 單參數 與 單返回值]
    也就是說
    [] 內可能是多個元素
    比如
    #+begin_src scheme
    (lambda  (-> [(* bool-suspend (-1 I)) (* bool-suspend (-1 I))]
                 [bool-suspend bool-suspend])
      (-> [(* :x0 i0) (* :x1 i0)] [:x0 f g :x1 f g])
      (-> [(* :x0 i1) (* :x1 i1)] [:x0 :x1]))
    #+end_src

    是否允許如下的 '明確化' 呢
    #+begin_src scheme
    (lambda  (-> [(* bool-suspend (-1 I)) (* bool-suspend (-1 I))]
                 [bool-suspend bool-suspend])
      (-> [(* :x0 i0) (* :x1 i0)] [[:x0 f g] [:x1 f g]])
      (-> [(* :x0 i1) (* :x1 i1)] [[:x0] [:x1]]))
    #+end_src
    或者
    #+begin_src scheme
    (lambda  (-> [(* bool-suspend (-1 I)) (* bool-suspend (-1 I))]
                 [bool-suspend bool-suspend])
      (-> [(* :x0 i0) (* :x1 i0)] [:x0 f g, :x1 f g])
      (-> [(* :x0 i1) (* :x1 i1)] [:x0, :x1]))
    #+end_src

  - k -
    我想前者嵌套的 [[]] 肯定是不可取的

  - x -
    但是如果使用後者的話
    比如
    #+begin_src scheme
    (def bool-suspend
      (type space
        (: n s (-1 <>))
        (: m (-> bool (0 n s)))))
    #+end_src
    就應該寫成
    #+begin_src scheme
    (def bool-suspend
      (type space
        (: [n, s] (-1 <>))
        (: m (-> bool (0 n s)))))
    #+end_src
    然而對於 (: ...) 來說 這其實是沒有必要的

  - k -
    但是我們可以要求這一點
    以使得 對 [] 與 ',' 的使用變得一致

  - x -
    那我們就追求這種一致性吧
    也許之後對 (: ...) 這個語法關鍵詞的擴展
    可能使得 (: ...) 類似於 (-> ...)
    從而讓 這種用法變得有必要

  - k -
    這樣我們就要以 clojure 的方式使用 ',' 了

  - x -
    沒錯
