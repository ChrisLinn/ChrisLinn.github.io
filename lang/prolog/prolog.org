#+TITLE:  tutorial of prolog
#+AUTHOR: 謝宇恆 / XIE Yuheng

* note type check

*** note
    - dependent type 也使用 variable 的 unification
      來做 type check
      所以也許可以在這裏學到實現類型檢查器的技術

    - 之後可以總結一下
      我所設計的類型檢查算法
      對 variable unification 的使用
      與 prolog 有什麼區別
      讓我們來討論一下吧

** 討論

   - x ::
        都是 declarative
        類型檢查的時候
        類型鍵擦通過與否
        正如 prolog 中一個 query 的結果 爲 true 還是 false

   - k ::
        感覺上 你所設計的 type check 實現方式
        像是 prolog 的特殊情況

* note learn prolog now

  - fact rule query

  - variable unification

  - The business of unifying variables
    with information in the knowledge base
    is the heart of Prolog

  - As we’ll learn
    there are many interesting ideas in Prolog
    but when you get right down to it,
    it’s Prolog’s ability to perform unification
    and return the values of the variable bindings to us
    that is crucial

  - As we shall see,
    such nested (or recursively structured) terms
    enable us to represent many problems naturally.
    In fact the interplay between recursive term structure
    and variable unification
    is the source of much of Prolog’s power.

* note interface

  - fact and rule in file
  - query in interpreter

* k1

  #+begin_src prolog
  loves(vincent,mia).
  loves(marsellus,mia).
  loves(pumpkin,honey_bunny).
  loves(honey_bunny,pumpkin).

  jealous(X,Y):-
    loves(X,Z),
    loves(Y,Z).
  #+end_src

* unification

*** 簡要敘述

    - Two terms unify
      if
      1. they are the same term
      2. or if they contain variables
         that can be uniformly instantiated with terms
         in such a way that the resulting terms are equal
         - 這裏所說的 'uniformly instantiated with terms'
           就是可能給兩個變元共同鏈接到一個新的變元
           這樣就能保持有向圖無圈

*** 具體算法描述

    - If term1 and term2 are constants,
      then term1 and term2 unify
      if and only if
      they are the same atom,
      or the same number.

    - If term1 is a variable and term2 is any type of term,
      then term1 and term2 unify,
      and term1 is instantiated to term2 .
      Similarly, if term2 is a variable
      and term1 is any type of term,
      then term1 and term2 unify, and term2 is instantiated to term1 .
      - So if they are both variables,
        they’re both instantiated to each other,
        and we say that they share values.
        這裏就是困難的地方
        或者不如說是實現方式非平凡的地方

    - If term1 and term2 are complex terms,
      then they unify if and only if:
      - They have the same functor and arity,
      - and all their corresponding arguments unify,
      - and the variable instantiations are compatible.
        - For example,
          it is not possible to instantiate variable X to mia
          when unifying one pair of arguments,
          and to instantiate X to vincent
          when unifying another pair of arguments .

    - Two terms unify
      if and only if
      it follows from the previous three clauses that they unify.

*** 實現方式非平凡的地方

    - X = Y demands that
      we unify two finite representations of infinite terms
      #+begin_src prolog
      X = father(X),
      Y = father(Y),
      X = Y.
      #+end_src

    - here we need the function 'equal?'
      to be able to check two looped lists

    - standard unification algorithms are pessimistic.
      They first carry out the occurs check,
      and only when they are sure that the situation is safe
      they do go ahead and actually try to unify the terms.

* proof search as computation

  - prolog reads the knowledge base,
    and tries to unify k(Y) with
    either a fact, or the head of a rule.

  - 雖說運行方式是 search
    但是只要按照 functor 的名字 來查找 hash-table
    就也是線性時間

  - 所以每次 通過 functor 查找到的是函數體
    所謂的 在查找中試錯
    其實就是用 return-stack 來記錄之前執行到的函數體中的位置
    這樣 與我目前所使用的實現方式就非常相似了
    注意
    函數體中都是 一次一次得 unification
    在一次 unification 中 X 可能匹配到 a
    在下一次 unification 中 X 可能匹配到 b
    可以想像如何使用 scope-stack
    和 編譯時在 clauses 之間增加一些特殊的 primitive-function
    來實現這種效果
    - 也就是需要 undo binding

* note 以 謂詞的處理方式 分類語言

  - x ::
       之前說過 謂詞的處理方式 可用以 分類語言
       prolog 就是一個極端的例子
       因爲裏面所有的函數都是謂詞
       根本沒有正常意義上的函數

* recursive definition

*** note

    - recursive definition is different from recursive unification
      how ?

* ffi and instantiation_error

  - 默認的語義是
    =(X,+(1,2)).
    需要做算數時使用
    is(X,+(1,2)).
    也就是說
    參數都被當作 term 了
    但是函數頭不是

  - But there is a deeper point that is worth reflecting on:
    bolting on the extra capability
    to do arithmetic in this way
    has further widened the gap
    between the procedural and declarative meanings
    of Prolog programs.

* 多出一個命名

  - 有些東西可以表達地很簡單
    因爲於等式相比
    謂詞多了一個命名
    比如
    #+begin_src prolog
    add(0, N, N).
    add(succ(M), N, succ(O)):-
      add(M, N, O).

    %% add(0, N) = N.
    %% add(succ(M), N)
    %% = succ(add(M, M)).
    %% with
    %% add(M, M) = O.

    append([], List2, List2).
    append([Head1 | Tail1], List2, [Head1 | Tail2]):-
      append(Tail1, List2, Tail2).

    %% append([], List2) = List2.
    %% append([Head1 | Tail1], List2)
    %% = [Head1 | append(Tail1, List2)].
    %% with
    %% append(Tail1, List2) = Tail2.
    #+end_src

  - 函數 -> 謂詞
    把等號右邊命名
    然後重新組織模式匹配對算法的表達方式
    - 很可能就更簡單了
      因爲多了一個名字

  - 謂詞 -> 函數
    當某個變元做爲 結果變元 在某個謂詞式子末尾的位置單獨出現時
    把這個謂詞式子轉化爲等式

  - 可以發現 logic 編程的特點是能夠模式匹配運算結果

* 實現

  - 做爲 functor 的名字的同時
    每個 atom 本身也數據
    - 被 quote 的時候 lisp 中的 symbol 是數據
      而 prolog 中默認所有的 atom 在 參數位置的出現是 quote 的
      只有在頂層的

* 語義

  - 特點是
    沒有 argument-stack
    只有 scope-stack
    我的 unification 是
    函數體中 一個 sequent 的 antecedent 去匹配 argument-stack 中的值
    但是這裏已經沒有 argument-stack 了
    要知道
    邏輯範式下 定義的不是函數 而是謂詞
    只有函數才需要使用參數棧來 傳遞參數 和返回值

  - 函數體 jojo 中的每個 jo
    都代表 一個等待 unify 的 term
    而不是一個等待作用的 function
    每個函數體中項所帶有的變元 需要在 scope-stack 中查找來知道其意思
    每個函數退出時 忘掉它自己的 scope-stack 就能維護 lexical-scope

  - 好像還是需要一個類似 argument-stack 的棧
    感覺上是 argument-stack 來處理 '且'
    而 return-stack 來處理 '或'

  - 但是 argument-stack 和 return-stack 看起來是連動的
    所以
    還是設想單獨的 return-stack
    此時每個 return-point 是
    return-point = [querying term, index to functor body]
    需要兩個指針
    一個是 return-stack-top
    一個是 return-stack-current
    但是這樣 可能使用的就不是深度優先的搜索了
    但是這種語義是正確的 並不應該使用深度有限
    注意 [term, index]
    在遞增 index 的時候 會伴隨特定的副作用
    比如
    - 若前一個 jo 給 X 賦值了
      那麼在遞增 index 的時候 就應該 undo 這個賦值
    - 若錢一個 jo 入返回棧了新的元素
      那麼在遞增 index 的時候 就應該 undo 這些入棧的元素

  - 注意在每次 :- 成功時 都要 reset scope-stack
    所有的 local-variable 都應該被匹配到了 [因爲這樣謂詞才算是成功]
    所以 在返回的 term 的時候 取出這些匹配到的元素就行了
    注意
    如果匹配的時候兩個都是變元 那麼就會生成新的變元
    新的變元所佔用的內存 在返回之後也是不能回收的
    [上面的 '返回' 和函數返回意義不同]

  - 比如
    #+begin_src prolog
    append([], List2, List2).
    append([Head1|Tail1], List2, [Head1|Tail2]):-
      append(Tail1, List2, Tail2).
    #+end_src
    問 append([a,b,c],[1,2,3],X).
    X 匹配到了 [Head1|Tail2]
    在返回 append(Tail1, List2, Tail2) 的時候
    就不能把 所有的 Tail1, List2, Tail2 都代換成值
    其中 Tail2 不能代換成值
    因爲 雖然 匹配成功了
    但是它所匹配到的是不定元
    匹配的方式是
    X = [a|Tail2]

* lispy

  - play
    #+begin_src scheme
    (append () :list2 :list2)
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2))

    (goal:
      (append (list a b c) (list 1 2 3) :x))
    (variable-stack:
      :x -- ?)

    (unify:
      (append (cons :head1 :tail1) :list2 (cons :head1 :tail2)))
    (variable-stack:
      :x -- (cons a :tail2)
      :head1 -- a
      :tail1 -- (list b c)
      :list2 -- (list 1 2 3)
      :tail2 -- ?)

    (note:
      此時需要複製壓縮了
      但是 複製壓縮 的依據 看來有兩個
      一個是 :x
      一個是 新返回的
      (goal:
        (append (list b c) (list 1 2 3) :tail2)))

    (goal:
      (append (list b c) (list 1 2 3) :tail2))
    (variable-stack:
      :x -- (cons a :tail2)
      :tail2 -- ?)

    (unify:
      (append (cons :head1 :tail1) :list2 (cons :head1 :tail2)))
    (variable-stack:
      :x -- (cons a :tail2)
      :tail2 -- (cons b :tail2)
      ------
      :head1 -- b
      :tail1 -- (list c)
      :list2 -- (list 1 2 3)
      :tail2 -- ?)

    (goal:
      (append (list c) (list 1 2 3) :tail2))
    (variable-stack:
      :x -- (cons a :tail2)
      :tail2 -- (cons b :tail2)
      ------
      :tail2 -- ?)
    #+end_src

* 討論 <2015-12-24>

  - x ::
       上面的 :tail2 不能代換成值 的原因是
       unify 的時候 它沒有匹配到確定的值
       匹配的方式是
       :x = (cons a :tail2)
       :tail2 的不確定性來源於 :x
       但是 完整的信息卻是保存在 :x 中的
       當看 :tail2 的時候 是不能知道爲什麼這個元素是不確定的

  - k ::
       那麼能不能反過來編碼
       把 unify 的方式
       :x = (cons a :tail2)
       轉化爲
       :tail2 = (equal :x (cons a ::))
       這樣當 :tail2 確定了的時候
       就能順次去確定 :x

  - x ::
       總之在編碼這些信息的時候
       如果使用一些技巧 看來就是可能有利於垃圾回收器的
       又比如 我們可以通過生成共同引用
       使得 從 :x 開始 也能獲得獲得全部的信息
       需要 編碼的 unify 是
       :x = (cons a :tail2)
       此時可以生成公共引用點 (= :x (cons a :tail2))
       然後
       (:x
         (= :x (cons a :tail2)))
       (:tail2
         (= :x (cons a :tail2)))
       比如
       :x = :y
       (:x
         (= :x :y))
       (:y
         (= :x :y))
       注意
       只有在做 unify 的時候
       才有機會生成這種相互引用的編碼

* lispy

  #+begin_src scheme
  (append () :list2 :list2)
  (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
          (append :tail1 :list2 :tail2))

  ------

  (goal:
    (append (list a b c) (list 1 2 3) :x))
  (variable-stack:
    :x ?)
  (unify:
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))
  (variable-stack:
    :x (= :x (cons a :tail2))
    :head1 a
    :tail1 (list b c)
    :list2 (list 1 2 3)
    :tail2 (= :x (cons a :tail2)))
  (new-goal:
    (append (list b c) (list 1 2 3) :tail2))
  (variable-stack:
    ;; copy to conjugate
    :x (= :x (cons a :tail2))
    :tail2 (= :x (cons a :tail2)))
  (unify:
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))
  (variable-stack:
    :x:1 (= :x:1 (cons a :tail2:1))
    :tail2:1 (= :x:1 (cons a :tail2:1)) (= :tail2:1 (cons b :tail2:2))
    ------
    :head1 b
    :tail1 (list c)
    :list2 (list 1 2 3)
    :tail2:2 (= :tail2:1 (cons b :tail2:2)))
  (new-goal:
    (append (list c) (list 1 2 3) :tail2))
  (variable-stack:
    ;; copy to conjugate
    :x:1 (= :x:1 (cons a :tail2:1))
    :tail2:1 (= :x:1 (cons a :tail2:1)) (= :tail2:1 (cons b :tail2:2))
    :tail2:2 (= :tail2:1 (cons b :tail2:2)))
  #+end_src

* 回收內存的時機

  - 起初我想 回收內存應該激進 每次函數退除的時候都應該回收

  - 之後我想 回收內存的時機應該延遲

  - 最後我發現 根本不需要回收 local-variable 的內存
    只要使用一個很大的 round-buffer 就可以了
    假設沒有一個單獨的循環或者遞歸會使用到這麼多的內存就行了

  - 注意
    在 cicada-language 的類型檢查中也有同樣的問題
    也可以使用同樣的處理方式

  #+begin_src scheme
  (define
    (append () :list2 :list2)
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))

  (goal:
    (append (list a b c) (list 1 2 3) :x))
  (variable-stack:
    :x ?)
  (unify: #1#
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))
  (variable-stack:
    :x (cons a :tail2)
    ------
    #1#
    :head1 a
    :tail1 (list b c)
    :list2 (list 1 2 3)
    :tail2 ?)

  (goal: #1#
    (append (list b c) (list 1 2 3) :tail2))
  (unify: #2#
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))
  (variable-stack:
    :x (cons a :tail2#1)
    ------
    #1#
    :head1 a
    :tail1 (list b c)
    :list2 (list 1 2 3)
    :tail2 (cons b :tail2#2)
    ------
    #2#
    :head1 b
    :tail1 (list c)
    :list2 (list 1 2 3)
    :tail2 ?)

  (goal: #2#
    (append (list c) (list 1 2 3) :tail2))
  (unify: #3#
    (append (cons :head1 :tail1) :list2 (cons :head1 :tail2) <-
            (append :tail1 :list2 :tail2)))
  (variable-stack:
    :x (cons a :tail2#1)
    ------
    #1#
    :head1 a
    :tail1 (list b c)
    :list2 (list 1 2 3)
    :tail2 (cons b :tail2#2)
    ------
    #2#
    :head1 b
    :tail1 (list c)
    :list2 (list 1 2 3)
    :tail2 (cons c :tail2#3)
    ------
    #3#
    :head1 c
    :tail1 ()
    :list2 (list 1 2 3)
    :tail2 ?)

  (goal: #3#
    (append () (list 1 2 3) :tail2))
  (unify: #4#
    (append () :list2 :list2))
  (variable-stack:
    :x (cons a :tail2#1)
    ------
    #1#
    :head1 a
    :tail1 (list b c)
    :list2 (list 1 2 3)
    :tail2 (cons b :tail2#2)
    ------
    #2#
    :head1 b
    :tail1 (list c)
    :list2 (list 1 2 3)
    :tail2 (cons c :tail2#3)
    ------
    #3#
    :head1 c
    :tail1 ()
    :list2 (list 1 2 3)
    :tail2 (list 1 2 3)
    ------
    #4#
    :list2 (list 1 2 3))
  #+end_src
