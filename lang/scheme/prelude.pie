#lang pie

(claim one Nat)
(define one (add1 zero))

(claim two Nat)
(define two (add1 one))

(claim vegetables (Pair Atom Atom))
(define vegetables (cons 'celery 'carrot))

;; RECURSION IS NOT AN OPTION!

;; (claim gauss (-> Nat Nat))
;; (define gauss
;;   (lambda (n)
;;     (which-Nat n
;;       zero
;;       (lambda (prev)
;;         (add n (gauss prev))))))

(claim Pear U)
(define Pear (Pair Nat Nat))

(claim Pear-maker U)
(define Pear-maker (-> Nat Nat Pear))

(claim elim-Pear (-> Pear Pear-maker Pear))
(define elim-Pear
  (lambda (pear maker)
  (maker (car pear) (cdr pear))))

(check-same (Pair Nat Nat)
  (the Pear
    (elim-Pear
     (the Pear (cons 1 2))
     (the Pear-maker
       (lambda (a d)
         (cons d a)))))
  (cons 2 1))

(claim step-+ (-> Nat Nat))
(define step-+ (lambda (almost) (add1 almost)))

(claim + (-> Nat Nat Nat))
(define + (lambda (x y) (iter-Nat x y step-+)))

(claim step-gauss (-> Nat Nat Nat))
(define step-gauss (lambda (prev almost) (+ (add1 prev) almost)))

(claim gauss (-> Nat Nat))
(define gauss (lambda (n) (rec-Nat n zero step-gauss)))

(check-same Nat (gauss 0) 0)
(check-same Nat (gauss 1) 1)
(check-same Nat (gauss 2) 3)
(check-same Nat (gauss 3) 6)
(check-same Nat (gauss 4) 10)
(check-same Nat (gauss 5) 15)

;; (claim make-step-* (-> Nat (-> Nat Nat)))
;; (define make-step-* (lambda (y) (lambda (almost) (+ y almost))))

;; pie has currying

(claim make-step-* (-> Nat Nat Nat))
(define make-step-* (lambda (y almost) (+ y almost)))

(claim * (-> Nat Nat Nat))
(define * (lambda (x y) (iter-Nat x zero (make-step-* y))))

(check-same Nat (* 2 2) 4)
(check-same Nat (* 2 3) 6)
(check-same Nat (* 3 2) 6)
(check-same Nat (* 3 4) 12)
(check-same Nat (* 4 3) 12)

(claim step-factorial (-> Nat Nat Nat))
(define step-factorial (lambda (prev almost) (* (add1 prev) almost)))

(claim factorial (-> Nat Nat))
(define factorial (lambda (x) (rec-Nat x one step-factorial)))

(check-same Nat (factorial 0) 1)
(check-same Nat (factorial 1) 1)
(check-same Nat (factorial 2) 2)
(check-same Nat (factorial 3) 6)
(check-same Nat (factorial 4) 24)

(claim filp (Pi ([A U] [D U]) (-> (Pair A D) (Pair D A))))
(define filp (lambda (A D p) (cons (cdr p) (car p))))

(check-same (Pair Atom Nat)
  (filp Nat Atom (cons 123 'abc))
  (cons 'abc 123))

(check-same (-> (Pair Nat Atom) (Pair Atom Nat))
  (filp Nat Atom)
  (lambda (p) (cons (cdr p) (car p))))

(claim elim-Pair (Pi ([A U] [D U] [X U]) (-> (Pair A D) (-> A D X) X)))
(define elim-Pair (lambda (A D X p f) (f (car p) (cdr p))))

(claim kar (-> (Pair Nat Nat) Nat))
(define kar
  (lambda (p)
    (elim-Pair Nat Nat Nat p (lambda (a d) a))))

(claim kdr (-> (Pair Nat Nat) Nat))
(define kdr
  (lambda (p)
    (elim-Pair Nat Nat Nat p (lambda (a d) d))))

(check-same Nat (kar (cons 1 2)) 1)
(check-same Nat (kdr (cons 1 2)) 2)

(claim swap (-> (Pair Nat Atom) (Pair Atom Nat)))
(define swap
  (lambda (p)
    (elim-Pair
     Nat Atom (Pair Atom Nat)
     p (lambda (a d) (cons d a)))))

(check-same (Pair Atom Nat)
  (swap (cons 123 'abc)) (cons 'abc 123))

(claim twin (Pi ([A U]) (-> A (Pair A A))))
(define twin (lambda (A a) (cons a a)))

(check-same (Pair Nat Nat)
  (twin Nat 123) (cons 123 123))

(check-same (Pair Atom Atom)
  (twin Atom 'abc) (cons 'abc 'abc))

(claim twin-Nat (-> Nat (Pair Nat Nat)))
(define twin-Nat (lambda (a) (cons a a)))

(check-same (Pair Nat Nat)
  (twin Nat 123) (twin-Nat 123))

(check-same (-> Nat (Pair Nat Nat))
  (twin Nat) twin-Nat)
