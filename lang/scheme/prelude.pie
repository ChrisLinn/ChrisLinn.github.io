#lang pie

;; 1. The More Things Change, the More They Stay the Same

(claim one Nat)
(define one (add1 zero))

(claim two Nat)
(define two (add1 one))

;; 2. Doin' What Comes Naturally

(claim vegetables (Pair Atom Atom))
(define vegetables (cons 'celery 'carrot))

;; RECURSION IS NOT AN OPTION!

;; (claim gauss (-> Nat Nat))
;; (define gauss
;;   (lambda (n)
;;     (which-Nat n
;;       zero
;;       (lambda (prev)
;;         (add n (gauss prev))))))

(claim Pear U)
(define Pear (Pair Nat Nat))

(claim Pear-maker U)
(define Pear-maker (-> Nat Nat Pear))

(claim elim-Pear (-> Pear Pear-maker Pear))
(define elim-Pear
  (lambda (pear maker)
  (maker (car pear) (cdr pear))))

(check-same (Pair Nat Nat)
  (the Pear
    (elim-Pear
     (the Pear (cons 1 2))
     (the Pear-maker
       (lambda (a d)
         (cons d a)))))
  (cons 2 1))

;; 3. Eliminate All Natural Numbers!

(claim step-+ (-> Nat Nat))
(define step-+ (lambda (almost) (add1 almost)))

(claim + (-> Nat Nat Nat))
(define + (lambda (x y) (iter-Nat x y step-+)))

(claim step-gauss (-> Nat Nat Nat))
(define step-gauss (lambda (prev almost) (+ (add1 prev) almost)))

(claim gauss (-> Nat Nat))
(define gauss (lambda (n) (rec-Nat n zero step-gauss)))

(check-same Nat (gauss 0) 0)
(check-same Nat (gauss 1) 1)
(check-same Nat (gauss 2) 3)
(check-same Nat (gauss 3) 6)
(check-same Nat (gauss 4) 10)
(check-same Nat (gauss 5) 15)

;; pie has currying

(claim step-* (-> Nat Nat Nat))
(define step-* (lambda (y almost) (+ y almost)))

(claim * (-> Nat Nat Nat))
(define * (lambda (x y) (iter-Nat x zero (step-* y))))

(check-same Nat (* 2 2) 4)
(check-same Nat (* 2 3) 6)
(check-same Nat (* 3 2) 6)
(check-same Nat (* 3 4) 12)
(check-same Nat (* 4 3) 12)

(claim step-factorial (-> Nat Nat Nat))
(define step-factorial (lambda (prev almost) (* (add1 prev) almost)))

(claim factorial (-> Nat Nat))
(define factorial (lambda (x) (rec-Nat x one step-factorial)))

(check-same Nat (factorial 0) 1)
(check-same Nat (factorial 1) 1)
(check-same Nat (factorial 2) 2)
(check-same Nat (factorial 3) 6)
(check-same Nat (factorial 4) 24)

;; 4. Easy as Pie

(claim filp (Pi ([A U] [D U]) (-> (Pair A D) (Pair D A))))
(define filp (lambda (A D p) (cons (cdr p) (car p))))

(check-same (Pair Atom Nat)
  (filp Nat Atom (cons 123 'abc))
  (cons 'abc 123))

(check-same (-> (Pair Nat Atom) (Pair Atom Nat))
  (filp Nat Atom)
  (lambda (p) (cons (cdr p) (car p))))

(claim elim-Pair (Pi ([A U] [D U] [X U]) (-> (Pair A D) (-> A D X) X)))
(define elim-Pair (lambda (A D X p f) (f (car p) (cdr p))))

(claim kar (-> (Pair Nat Nat) Nat))
(define kar
  (lambda (p)
    (elim-Pair Nat Nat Nat p (lambda (a d) a))))

(claim kdr (-> (Pair Nat Nat) Nat))
(define kdr
  (lambda (p)
    (elim-Pair Nat Nat Nat p (lambda (a d) d))))

(check-same Nat (kar (cons 1 2)) 1)
(check-same Nat (kdr (cons 1 2)) 2)

(claim swap (-> (Pair Nat Atom) (Pair Atom Nat)))
(define swap
  (lambda (p)
    (elim-Pair
     Nat Atom (Pair Atom Nat)
     p (lambda (a d) (cons d a)))))

(check-same (Pair Atom Nat)
  (swap (cons 123 'abc)) (cons 'abc 123))

(claim twin (Pi ([A U]) (-> A (Pair A A))))
(define twin (lambda (A a) (cons a a)))

(check-same (Pair Nat Nat)
  (twin Nat 123) (cons 123 123))

(check-same (Pair Atom Atom)
  (twin Atom 'abc) (cons 'abc 'abc))

(claim twin-Nat (-> Nat (Pair Nat Nat)))
(define twin-Nat (lambda (a) (cons a a)))

(check-same (Pair Nat Nat)
  (twin Nat 123) (twin-Nat 123))

(check-same (-> Nat (Pair Nat Nat))
  (twin Nat) twin-Nat)

;; 5. Lists, Lists, and More Lists

(claim expectations (List Atom))
(define expectations
  (:: 'cooked
    (:: 'eaten
      (:: 'tried-cleaning
        (:: 'understood
          (:: 'slept nil))))))

(claim toppings (List Atom))
(define toppings (:: 'potato (:: 'butter nil)))

(claim condiments (List Atom))
(define condiments (:: 'chives (:: 'mayonnaise nil)))

(claim step-length (Pi ([E U]) (-> E (List E) Nat Nat)))
(define step-length (lambda (E e es almost) (add1 almost)))

(claim length (Pi ([E U]) (-> (List E) Nat)))
(define length (lambda (E l) (rec-List l zero (step-length E))))

(check-same Nat (length Atom expectations) 5)

(check-same (-> (List Atom) Nat)
  (length Atom)
  (lambda (l) (rec-List l zero (step-length Atom))))

(claim step-append (Pi ([E U]) (-> E (List E) (List E) (List E))))
(define step-append (lambda (E e es almost) (:: e almost)))

(claim append (Pi ([E U]) (-> (List E) (List E) (List E))))
(define append (lambda (E x y) (rec-List x y (step-append E))))

(check-same (List Nat)
  (append Nat (:: 1 (:: 2 nil)) (:: 3 (:: 4 nil)))
  (:: 1 (:: 2 (:: 3 (:: 4 nil)))))

;; reusing `step-append`
(claim snoc (Pi ([E U]) (-> (List E) E (List E))))
(define snoc (lambda (E es e) (rec-List es (:: e nil) (step-append E))))

(check-same (List Nat)
  (snoc Nat (:: 1 (:: 2 nil)) 3)
  (:: 1 (:: 2 (:: 3 nil))))

(claim step-reverse (Pi ([E U]) (-> E (List E) (List E) (List E))))
(define step-reverse (lambda (E e es almost) (snoc E almost e)))

(claim reverse (Pi ([E U]) (-> (List E) (List E))))
(define reverse
  (lambda (E x)
    (rec-List x
      (the (List E) nil)
      (step-reverse E))))

(check-same (List Nat)
  (reverse Nat (:: 1 (:: 2 (:: 3 (:: 4 nil)))))
  (:: 4 (:: 3 (:: 2 (:: 1 nil)))))

;; reusing `step-reverse`
(claim concat (Pi ([E U]) (-> (List E) (List E) (List E))))
(define concat
  (lambda (E x y)
    (rec-List (reverse E y)
      x (step-reverse E))))

(check-same (List Nat)
  (concat Nat (:: 1 (:: 2 nil)) (:: 3 (:: 4 nil)))
  (:: 1 (:: 2 (:: 3 (:: 4 nil)))))

;; 6. Precisely How Many?
