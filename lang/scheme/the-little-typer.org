#+title: the little typer

* [note]

*** syntax examples

    - (the <type> <data>)

    - (check-same <type> <data> <data>)

    - (claim <name> <type>)
      (define <name> <data>)

    - (which-<type>)
      (rec-<type>)
      (iter-<type>)
      (ind-<type>)

    - (= <type> <data> <data>)
      (same <data>)

* 1. The More Things Change, the More They Stay the Same

  #+begin_src scheme
  'ratatouille
  (the Atom 'ratatouille)
  (the Atom (the Atom 'ratatouille))

  (the (Pair Atom Atom)
    (cons 'ratatouille 'baguette))
  #+end_src

  - The Four Forms of Judgment
    1. ___ is a ___.
    2. ___ is the same ___ as ___.
    3. ___ is a type.
    4. ___ and ___ are the same type.

  - The normal form of an expression
    is the most direct way of writing it.
    Any two expressions that are the same have identical normal forms,
    and any two expressions with identical normal forms are the same.

    Given a type, every expression described by that type has a normal form.

  #+begin_src scheme
  0 1
  (the Nat 0)
  (the Nat 1)
  (the Nat 1729)

  (the Nat zero)
  (the Nat (add1 zero))
  #+end_src

  - x -
    Remember Bishop's set
    "To define a set we prescribe, at least implicitly,
    1. what we (the constructing intelligence) must do
       in order to construct an element of the set,
    2. and what we must do to show that
       two elements of the set are equal."

    We used a stronger way to define a type,
    instead of asking for a equivalent relation,
    we are asking for a normal form.
    Thus a program to eval expressions of a type to normal form,
    give us a predicate for equivalent relation.

    We are also explicit about constructing.
    To define a type, we explicit specify its constructors.
    - `Nat` has `zero` and `add1` as constructors
    - primitive type `Atom` has infinitely many constructors

  - In Pie,
    expressions do not refer to some external notion of meaning,
    there is nothing but expressions
    and what we judge about them.

    While in Lisp, values are distinct from expressions,
    and the result of evaluation is a value.

  - expression > value (top is constructor) > normal form

  - x -
    I should do the same in my design.
    - Note that,
      "expression" is about semantics,
      and not about concrete syntax.

* 2. Doin' What Comes Naturally

  - Constructors build values,
    and eliminators takeapart values built by constructors.

  - `lambda` is a constructor,
    because every expression that looks like
    `(lambda (x0 x ...) <body>)` is a value.

    Applying a function to arguments
    is the eliminator for functions.

  - x -
    "Applying a function" seems not like eliminators like
    `car` and `cdr`, which are functions.

    "Applying a function" is builtin to the language.
    `car` and `cdr` can also be builtin as
    "taking fields of record".

  #+begin_src scheme
  (check-same (-> Atom Atom (Pair Atom Atom))
    (lambda (a d) (cons a d))
    (lambda (d a) (cons d a)))

  (check-same (-> Nat Nat)
    (lambda (y) (car (the (Pair Nat Nat) (cons y y))))
    (lambda (x) x))
  #+end_src

  - x -
    expression >
    value (top is constructor) >
    normal form

    strategy >
    strategy with explicit next step >
    strategy with every steps

  - Expressions that are not values
    and cannot yet be evaluated due to a variable
    are called neutral.

    if `x` is a variable,
    which we only know its type is `(Pair Nat Nat)`,
    but not know its value.
    then `(car x)` or `(cdr x)` are neutral

  - Neutral expressions make it necessary to expand our view on
    what it means to be the same.
    Each variable is the same as itself,
    no matter what type it has.

    This is because variables are only replaced consistently,
    so two occurrences of a variable
    cannot be replaced by values that are not the same.

  - If two expressions have identical eliminators at the top
    and all arguments to the eliminators are the same,
    then the expressions are the same.

    such as `(car x)` and `(car x)`

  - Neutral expressions that are written identically
    are the same, no matter their type.

  - *The Second Commandment of cons*
    If p is a (Pair A D),
    then it is the same (Pair A D)
    as (cons (car p) (cdr p)).

  #+begin_src scheme
  (which-Nat zero
    'naught
    (lambda (n) 'more))

  (check-same Atom
    (the Atom 'naught)
    (which-Nat zero
      'naught
      (lambda (n) 'mor)))

  (check-same Atom
    (the Atom 'more)
    (which-Nat (add1 (add1 (add1 zero)))
      'naught
      (lambda (n) 'more)))
  #+end_src

  - cicada-like:

  #+begin_src typescript
  which_Nat: (
    {{ X: type }}
    target: Nat,
    base: X,
    step: (prev: Nat) -> X,
  ) -> X = {
    case (target) {
      zero => base
      succ => step (target.prev)
    }
  }
  #+end_src

  - RECURSION IS NOT AN OPTION
  - RECURSION IS NOT AN OPTION
  - RECURSION IS NOT AN OPTION

  - Recursion is not an option
    because every expression must have a value.

    Some recursive definitions make it possible
    to write expressions that do not have values.

  - *Every U Is a Type*
    Every expression described by U is a type,
    but not every type is described by U.
    - such as U and (Pair U U)

* Recess: A Forkful of Pie

  - Using Pie is very much like a conversation:
    it accepts claims, definitions, and expressions
    and it replies with feedback.

  - For claims and definitions,
    the feedback is whether they are meaningful.

    For expressions,
    the feedback is also the expression's type and normal form.

  - When an expression is a type, but does not have a type,
    Pie replies with just its normal form.
    - such as U, (Pair U U), (Pair Atom U), (-> U U)

  #+begin_src scheme
  (the (Pair Atom (Pair Atom Atom))
    (cons 'spinach
          (the (Pair Atom Atom)
            (cons 'kale 'cauliflower))))

  (the (Pair Atom (Pair Atom Atom))
    (cons 'spinach
          (cons 'kale 'cauliflower)))

  (car (the (Pair Atom Nat)
         (cons 'brussels-sprout 4)))
  #+end_src

* 3. Eliminate All Natural Numbers!

  - "same as" chart
    - x -
      base of the format of the game of equivalent

  #+begin_src scheme
  | (gauss (add1 zero))
  | (add1 (gauss zero))
  | (add1 zero)
  #+end_src

  - *Total Function*
    A function that always assigns a value
    to every possible argument is called a total function.

  - x -
    | strategy | winning strategy |
    | function | total function   |

  - cicada-like:

  #+begin_src typescript
  iter_Nat: (
    {{ X: type }}
    target: Nat,
    base: X,
    step: (almost: X) -> X,
  ) -> X = {
    case (target) {
      zero => base
      succ => step (iter_Nat (target.prev, base, step))
    }
  }

  rec_Nat: (
    {{ X: type }}
    target: Nat,
    base: X,
    step: (prev: Nat, almost: X) -> X,
  ) -> X = {
    case (target) {
      zero => base
      succ => step (
        prev = target.prev,
        almost = rec_Nat (target.prev, base, step),
      )
    }
  }

  step_add: (almost: Nat) -> Nat = succ (almost)
  add: (x: Nat, y: Nat) -> Nat = iter_Nat (x, y, step_add)

  step_gauss: (prev: Nat, almost: Nat) -> Nat = add (succ (prev), almost)
  gauss: (n: Nat) -> Nat = rec_Nat (n, zero, step_gauss)
  #+end_src

* 4. Easy as Pie

  #+begin_src typescript
  elim_Pair: (
    A: type,
    D: type,
    X: type,
    p: Pair (A, D),
    f: (A, D) -> X,
  ) -> X = f (p.car, p.cdr)
  #+end_src

* 5. Lists, Lists, and More Lists

  #+begin_src typescript
  rec_List: (
    {{ E: type, X: type }}
    target: List (E),
    base: X,
    step: (car: E, cdr: List (E), almost: X) -> X,
  ) -> X = {
    case (target) {
      null => base
      cons => step (
        car = target.car,
        cdr = target.cdr,
        almost = rec_List (target.cdr, base, step),
      )
    }
  }
  #+end_src

* 6. Precisely How Many?

  #+begin_src scheme
  (the (Vec Atom 0) vecnil)
  (the (Vec Atom 1) (vec:: 'oyster vecnil))

  (the Atom
    (head (the (Vec Atom 1) (vec:: 'oyster vecnil))))
  (the (Vec Atom 0)
    (tail (the (Vec Atom 1) (vec:: 'oyster vecnil))))
  #+end_src

  - We avoid attempting to define a non-total function
    by using a more specific type
    to rule out unwanted arguments.

  - *Use a More Specific Type*
    Make a function total
    by using a more specific type
    to rule out unwanted arguments.

  - (-> Y X) is sugar for (Pi ([y Y]) X)
    when `y` does not occur in `Y`

* 7. It All Depends On the Motive
* Recess: One Piece at a Time
* 8. Pick a Number, Any Number
* 9. Double Your Money, Get Twice as Much
* 10. It Also Depends On the List
* 11. All Lists Are Created Equal
* 12. Even Numbers Can Be Odd
* 13. Even Haf a Baker's Dozen
* 14. There's Safety in Numbers
* 15. Imagine That ...
* 16. If It's All the Same to You
* A. The Way Forward
* B. Rules Are Made to Be Spoken
