#+title: the little typer

* [note]

*** syntax examples

    - (the <type> <data>)
    - (same-check <type> <data> <data>)
    - (claim <name> <type>)
    - (define <name> <data>)
    - (which-<type>)
      (rec-<type>)
      (iter-<type>)
      (ind-<type>)
    - (= <type> <data> <data>)
      (same <data>)

* 1. The More Things Change, the More They Stay the Same

  #+begin_src racket
  'ratatouille
  (the Atom 'ratatouille)
  (the Atom (the Atom 'ratatouille))

  (the (Pair Atom Atom)
       (cons 'ratatouille 'baguette))
  #+end_src

  - The Four Forms of Judgment
    1. ___ is a ___.
    2. ___ is the same ___ as ___.
    3. ___ is a type.
    4. ___ and ___ are the same type.

  - The normal form of an expression
    is the most direct way of writing it.
    Any two expressions that are the same have identical normal forms,
    and any two expressions with identical normal forms are the same.

    Given a type, every expression described by that type hasa normal form.

  #+begin_src racket
  0 1
  (the Nat 0)
  (the Nat 1)
  (the Nat 1729)

  (the Nat zero)
  (the Nat (add1 zero))
  #+end_src

  - x -
    Remember Bishop's set
    "To define a set we prescribe, at least implicitly,
    1. what we (the constructing intelligence) must do
       in order to construct an element of the set,
    2. and what we must do to show that
       two elements of the set are equal."

    We used a stronger way to define a type,
    instead of asking for a equivalent relation,
    we are asking for a normal form.
    Thus a program to eval expressions of a type to normal form,
    give us a predicate for equivalent relation.

    We are also explicit about constructing.
    To define a type, we explicit specify its constructors.
    - `Nat` has `zero` and `add1` as constructors
    - primitive type `Atom` has infinitely many constructors

  - In Pie,
    expressions do not refer to some external notion of meaning,
    there is nothing but expressions
    and what we judge about them.

    While in Lisp, values are distinct from expressions,
    and the result of evaluation is a value.

  - expression > value (top is constructor) > normal form

    - x -
      I should do the same in my design.
      - Note that,
        "expression" is about semantics,
        and not about concrete syntax.

* 2. Doin' What Comes Naturally
* Recess: A Forkful of Pie
* 3. Eliminate All Natural Numbers!
* 4. Easy as Pie
* 5. Lists, Lists, and More Lists
* 6. Precisely How Many?
* 7. It All Depends On the Motive
* Recess: One Piece at a Time
* 8. Pick a Number, Any Number
* 9. Double Your Money, Get Twice as Much
* 10. It Also Depends On the List
* 11. All Lists Are Created Equal
* 12. Even Numbers Can Be Odd
* 13. Even Haf a Baker's Dozen
* 14. There's Safety in Numbers
* 15. Imagine That ...
* 16. If It's All the Same to You
* A. The Way Forward
* B. Rules Are Made to Be Spoken
