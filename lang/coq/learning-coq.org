#+title:  learning-coq

* 記

*** to use coq and ProofGeneral

***** in org-mode

      - M-n
        (C-c C-n)
        proof-assert-next-command-interactive

      - M-p
        (C-c C-u)
        proof-undo-last-successful-command

      - C-c <C-return>
        proof-goto-point

***** about unicode

      #+begin_src coq
      Notation "∀ x .. y , P" :=
        (forall x, .. (forall y, P) ..)
          (at level 200, x binder, y binder, right associativity) : type_scope.

      Notation "∃ x .. y , P" := (exists x, .. (exists y, P) ..)
        (at level 200, x binder, y binder, right associativity) : type_scope.

      Notation "x ∨ y" := (x \/ y) (at level 85, right associativity) : type_scope.

      Notation "x ∧ y" := (x /\ y) (at level 80, right associativity) : type_scope.

      Notation "x → y" := (x -> y) (at level 90, right associativity): type_scope.

      Notation "x ↔ y" := (x <-> y) (at level 95, no associativity): type_scope.

      Notation "¬ x" := (~x) (at level 75, right associativity) : type_scope.

      Notation "x ≠ y" := (x <> y) (at level 70) : type_scope.

      Notation "'λ' x .. y , t" :=
        (fun x => .. (fun y => t) ..)
          (at level 200, x binder, y binder, right associativity).

      Check (λ x:nat , x = 3).
      #+end_src

* coq in a hurry

*** command : Check

    to check whether a formula is well-formed
    the conditions for terms to be well-formed have two origins:
    1. the syntax must be respected
       parentheses must be balanced
       binary operators must have two arguments
       etc
    2. expressions must respect a type discipline
    #+begin_src coq
    Check True.
    Check False.
    Check (1+2).
    Check ((3=5)/\True).
    Check Prop.
    Check nat.
    Check (3).
    #+end_src

*** to be explicit about the type of a exp
    #+begin_src coq
    Check True:Prop.
    Check (3, 3=5):nat*Prop.
    #+end_src

*** keyword : fun
    replaces the λ symbol of λ calculus
    + why do not jusu use the the λ symbol of λ calculus ???
      i can configure emacs to change the way
      it display keywords
    #+begin_src coq
    Require Import Arith.

    (* λx:nat.x=3 *)
    Check (fun x:nat => x = 3).
    Check ((fun x:nat => x = 3) 1).

    (* ∀x:nat.x<3 ∨ ∃y:nat.x=y+3 *)
    Check (forall x:nat, x < 3 \/ (exists y:nat, x = y + 3)).
    #+end_src

*** keyword : let
    local-binding by pattern-matching
    + like haskell
      or one should say
      like math
    + not using parentheses
      but using syntax-keyword ``in'' to show
      where is the body of the exp
    + and in the following a type-inferacer is working
    + overloaded notation: * as:
      1) multiplication on numbers
      2) cartesian product on types
    #+begin_src coq
    Check (let f := fun x => (x * 3,x)
           in f 3).
    #+end_src

*** command : Locate
    to find the function hidden behind a notation
    #+begin_src coq
    Locate "_ <= _".
    Locate "_ \/ _".

    Check and.
    Check (and True False).
    Check (and True).
    Locate and.

    Locate plus.
    Locate sum.
    Locate nat.
    Locate "_ + _".
    #+end_src

*** command : Eval
    some symbolic computation is performed on this formula
    and there are several strategies to perform this symbolic computation
    one strategy is called ``compute''
    #+begin_src coq
    Eval compute in
        let f := fun x => (x * 3, x)
        in f 3.

    Check fun x1:nat => fun x2:nat => (plus x1 x2).

    Eval compute in
        let f := fun x1:nat => fun x2:nat => (plus x1 x2)
        in f 4 3.
    #+end_src

*** command : Definition
    with ``Definition'' one could write programs
    programs are usually represented by functions

    simple programs can be executed in the coq system itself
    more complex coq programs can be transformed into programs
    in more conventional languages and executed outside coq


    #+begin_src coq
    Definition example1 (x : nat) := x*x+2*x+1.
    (* one can't use Definition
       to define something more than once *)

    Check example1.
    Eval compute in
        example1 100.


    (* to see the free a binding of an name *)
    Reset example1.

    (* explicit version: *)
    Definition example1 := fun x : nat => x*x+2*x+1.

    (* to see the definition of an name *)
    Print example1.
    #+end_src

*** type : bool
    observing the difference between bool and Prop
    #+begin_src coq
    Require Import Bool.

    Eval compute in
        if true
        then 3
        else 5.

    Check true.

    Check True.
    #+end_src

*** command : Search and SearchAbout
    knowing what functions are provided by a datatype
    #+begin_src coq
    Search bool.
    SearchAbout bool.

    Check false : bool.
    Check true : bool.
    Check xorb : bool -> bool -> bool.
    Check orb : bool -> bool -> bool.
    Check negb : bool -> bool.
    Check implb : bool -> bool -> bool.
    Check andb : bool -> bool -> bool.


    Search Prop.
    SearchAbout Prop.
    #+end_src

*** type : nat
    #+begin_src coq
    Require Import Arith.

    Eval compute in
        S (S (S 1)).

    Definition is_zero :=
      (fun n:nat =>
         match n with
           | 0 => true
           | S p => false
         end).

    Eval compute in
        is_zero 1.

    Eval compute in
        is_zero 0.

    Definition nat_sub1 :=
      fun n:nat =>
        (match n with
           | 0 => 0
           | S p => p
         end).

    Eval compute in
        nat_sub1 1.

    Eval compute in
        nat_sub1 0.

    Print pred.
    #+end_src

*** command : Fixpoint
    is it means that the recursion is implemented by ``Y''???
    >< but way one can't use ``Fixpoint'' as ``Definition'' ???
    #+begin_src coq
    Fixpoint sum_n n :=
      match n with
        | 0 => 0
        | S p => p + sum_n p
      end.

    Fixpoint sum_n2 n s :=
      match n with
        | 0 => s
        | S p => sum_n2 p (p + s)
      end.

    Eval compute in
        sum_n2 100 0.

    Eval compute in
        sum_n2 100 0.


    Fixpoint evenb n :=
      match n with
        | 0 => true
        | 1 => false
        | S (S p) => evenb p
      end.

    Eval compute in
        evenb 100.

    Eval compute in
        evenb 101.
    #+end_src
    structural-recursion-constraint:
    the recursive call can only be made
    on a subterm of the initial argument
    it can't ensure that every computation terminates at all
    so this kind of funking constraint is always bad for user

*** type : list
    list of data must be of the same type
    #+begin_src coq
    Require Import List.


    Check 1::2::3::nil.

    Check nil.
    (* have no type *)

    Check (nil : list nat).

    Eval compute in
        map (fun x => x + 3) (1::3::2::nil).

    Eval compute in
        map S (1::22::3::nil).

    Eval compute in
        let l := (1::2::3::nil)
        in l ++ map (fun x => x + 3) l.


    Fixpoint evenb n :=
      match n with
        | 0 => true
        | 1 => false
        | S (S p) => evenb p
      end.

    Definition head_evb :=
      fun l =>
        match l with
          | nil => false
          | a::tl => evenb a
        end.

    Eval compute in
        head_evb (2::1::nil).

    Fixpoint sum_list l :=
      match l with
        | nil => 0
        | n::tl => n + sum_list tl
      end.

    Eval compute in
        sum_list (2::1::nil).

    Fixpoint 大于等于 n1 n2 :=
      match n1 with
        | 0 => match n2 with
            | 0 => true
            | S k2 => false
          end
        | S k1 =>
          match n2 with
            | 0 => true
            | S k2 => 大于等于 k1 k2
          end
        end.


    Fixpoint insert n l :=
      match l with
        | nil => n::nil
        | a::tl => if 大于等于 a n
                   then n::l
                   else a::insert n tl
      end.
    Fixpoint sort l :=
      match l with
        | nil => nil
        | a::tl => insert a (sort tl)
      end.

    Eval compute in
        sort (1::4::3::22::5::16::7::nil).

    Fixpoint is_sorted l :=
      match l with
        | nil => true
        | a::nil => true
        | a1::a2::nil => 大于等于 a2 a1
        | a1::a2::tail => if 大于等于 a2 a1
                          then
                            match l with
                              | nil => true
                              | a1::tail => is_sorted tail
                            end
                          else false
      end.
    Eval compute in
        is_sorted (1::2::3::nil).
    Eval compute in
        is_sorted (1::4::3::nil).
    #+end_src

*** propositions and proofs
    the semantices of x:A
    1. x is proof of logical formula A
    2. x is of the type A

*** command : Search and SearchPattern
    to find already existing proofs of facts
    its argument should always be an identifier

    some axiom joint of the directed-graph
    #+begin_src coq
    Search True.

    (* Search le. *)

    (* SearchPattern (_ + _ <= _ + _). *)

    (* SearchRewrite (_ + (_ - _)). *)

    SearchAbout True.
    #+end_src

*** command : Theorem and Lemma

***** note
      *curry–howard isomorphism*
      *propositions-as-types*

      这是通过语法的相似性而被发现的
      当发现语法相似的时候就是应该融合形式语言的时候
      尽管语义不同

      Qed. quod erat demonstrandum
      w.z.b.w. was zu beweisen war

      A -> B == ¬A ∨ B

***** tactics是写在Proof.于Qed.之间的context&conclusion-processing function
      每个tactics只能处理某些特定patten的context&conclusion

******* goal == context&conclusion
        so one can say ``goal-processing function''

        it looks like:
        <context>
        =======================
        <conclusion>
        + >< 其中<context>是前面证明过的定理和局部的假设 ???

        and initially it is:
        <>
        =======================
        <statements>

        就下面的在一般数学文本中出现的对推理规则的表达而言
        Γ,x:σ ͱ M:τ
        ------------------- (->introduction)
        Γ ͱ (λx.M):(σ->τ)
        coq中的双横线``=============''对应于这里的``ͱ''
        而这里的单横线``-------------''对应于coq中的``tactics''
        可以看出在一般数学文本中
        语义上``ͱ''与``-------------''是相似的
        只不过它们的层次不同

******* 被处理的context&conclusion作为数据结构是什么样的?
        即是问context&conclusion和context&conclusion之间的关系是什么
        这些关系是如何实现的
        有向图吗 ???
        其实就是被隐蔽起来的有向图处理
        onescontext&conclusion是有向图的节点
        tactics用来指明在回溯过程中下一步往那个方向走

******* tactics for the basic logical connectives

********* intros h1 h2 ...
          introduce
          用来处理conclusion中的
          1) 全称量词(universal quantification)
             + 量词后面的是约束变元 所以可以随便用什么名字
          2) 蕴含式的假设(implication)
          3) 否定式
          把表达式引入context的同时消减了conclusion中的东西
          即从conclusion中提取出可以在局部假设成立得到假设
          intros后面跟标示符用来给提取出来的局部成立的假设命名
          #+begin_src coq
          Lemma example2 : forall a b : Prop, a /\ b -> b /\ a.
          Proof.
            intros a b.
            intros H.
            split.
            destruct H as [H1 H2].
            exact H2.
            intuition.
            (* intuition as: *)
            (* destruct H as [H1 H2]. *)
            (* exact H1. *)
          Qed.
          #+end_src

********* destruct H as [H1 H2]
          用来处理context中的b /\ a
          这将会在一个goal中把H分开为两句

********* destruct H as [H1 | H2]
          用来处理context中的b \/ a中的
          这将会把一个goal分开为两个goal
          即是分情况证明
          #+begin_src coq
          Lemma example3 : forall A B, A \/ B -> B \/ A.
          Proof.
            intros A B H.
            destruct H as [H1 | H2].
            right.
            assumption.
            left.
            assumption.
          Qed.
          #+end_src

********* exact H
          simply expresses that we want to prove
          a statement that is present in the context

********* assumption
          to look for one hypothesis whose
          statement is the same as the conclusion

********* intuition
          automatic tactic
          让coq帮忙来完成一些步骤

********* apply
          用来处理context中的
          universal-quantification with implication:
          #+begin_src coq
          Theorem kkk
                  forall x1 x2 x3 ,
                    (P1 x1 x2 x3 ->
                     (P2 x1 x2 x3 ->
                      (P3 x1 x2 x3 ->
                       (P4 x1 x2 x3 -> C x1 x2 x3)))).
          #+end_src
          apply try to match
          <premise> -> <conclusion>
          with the pattern provided by a Theorem
          and try to form new goal accordingly:
          #+begin_src coq
          Theorem lll C a1 a2 a3.
          Proof.
            apply kkk.
            (* replaces the current goal with 4 goals *)
            (* whose statements are: *)
            (* A1 a1 a2 a3.  *)
            (* A2 a1 a2 a3.  *)
            (* A3 a1 a2 a3.  *)
            (* A4 a1 a2 a3.  *)
          ...
          #+end_src

          其实证明定理就像是在有向图中行走
          看能走到哪里就算证明到了哪里
          而当我证明了一个带有全称量词的定理的时候
          就相当于我熟悉了这个有向图中的某种模式的道路
          当我再次遇到这个种道路的时候
          我就可以直接到达道路的那一头
          而不用再一步一步地走了
          #+begin_src coq
          Check le_n.
          (* le_n: forall n : nat, n <= n *)
          Check le_S.
          (* le_S: forall n m : nat, n <= m -> n <= S m *)
          Lemma example4 : 3 <= 5.
          Proof.

            (* 下面apply处理context中的 *)
            (* universal-quantification with implication *)
            apply le_S.
            apply le_S.

            (* 下面apply处理context中的 *)
            (* universal-quantification without implication: *)
            (* 这时就有可能完成证明了 *)
            apply le_n.

          Qed.
          #+end_src

          transitivity theorem for the order
          ``less than or equal to'' on natural numbers
          #+begin_src coq
          Require Import Arith.

          Check le_trans.
          (* Lemma le_trans : forall n m p : nat, n <= m -> m <= p -> n <= p. *)

          Lemma example5_1 :  1 <= 2 -> 2 <= 3 -> 1 <= 3.
          Proof.
            apply le_trans.
          Qed.

          Lemma example5 : forall x y, x <= 10 -> 10 <= y -> x <= y.
          Proof.

            intros x y x10 y10.
            apply le_trans with (m := 10).
            (* 可以理解到如果没有with (m := 10)为什么就会失败 *)
            (* 因为apply想要利用定理le_trans给出sub-goal的时候 *)
            (* 会发现当把全称量词中的约束变元作为pattern-variable时 *)
            (* 有的pattern-variable(这里的m)没有绑定到任何值 *)

            (* 之后就简单了 *)

            (* 最精确的: *)
            (* exact x10. *)
            (* exact y10. *)

            (* 模糊一点 让coq帮忙查找: *)
            (* assumption. *)
            (* assumption. *)

            (* 最模糊的: *)
            intuition.
            intuition.

          Qed.
          #+end_src

********* rewrite
          many theorems have a conclusion that is an equality
          the most practical tactic to use these theorem is rewrite
          即rewrite是用来给证明等式的
          rewrite所使用的定理(rewrite-rule)
          pattern-matching被证定理的等号左边
          然后将被证的等式恒等变形为另一个等式
          #+begin_src coq
          Require Import Arith.

          Lemma example6 : forall x y, (x + y) * (x + y) = x*x + 2*x*y + y*y.
          Proof.

            intros x y.
            (* 约束变元的类型被推导出来了 *)
            (* 下面查一下(左)分配律的重写规则 *)
            SearchRewrite (_ * (_ + _)).
            rewrite mult_plus_distr_l.
            (* 下面查一下(右)分配律的重写规则 *)
            SearchRewrite ((_ + _) * _).

            (* rewrite mult_plus_distr_r. *)

            (* 可以用with来指定一个上面所查找到的的定理中的 *)
            (* 约束变元所应该在模式匹配中被绑定到的项 *)
            (* 否则coq会选择前面的一个 *)
            rewrite mult_plus_distr_r with (p:=y).
            rewrite mult_plus_distr_r.

            (* intuition在这里不能用 *)
            (* 看来它是专门处理一阶逻辑中的显然步骤的 *)

            (* 那么继续找加法结合律 *)
            SearchRewrite (_ + (_ + _)).
            (* plus_assoc: forall n m p : nat, n + (m + p) = n + m + p *)
            rewrite plus_assoc.

            (* 下面反着利用rewrite-rule *)
            (* 而匹配的还是被证明项的等号左边 *)
            rewrite <- plus_assoc with (n := x * x).

            (* next : commutativity for multiplication *)
            SearchPattern (?x * ?y = ?y * ?x).
            (* mult_comm: forall n m : nat, n * m = m * n *)
            rewrite mult_comm with (n:= y) (m:=x).

            (* 找定理的时候要小部分小部分地找 *)
            (* 汉语形成副词的方式是通过重复:小部分小部分地 *)
            SearchRewrite ((S _) * _).
            SearchRewrite (S _ * _).
            (* mult_succ_l: forall n m : nat, S n * m = n * m + m *)
            (* mult_1_l: forall n : nat, 1 * n = n *)


            (* using a tactic called pattern *)
            (* to limit the place where rewriting occurs *)
            pattern (x * y) at 1.
            rewrite <- mult_1_l.
            rewrite <- mult_succ_l.

            (* 然后是乘法结合律 *)
            SearchRewrite (_ * (_ * _)).
            rewrite mult_assoc.

            reflexivity.
            (* reflexivity用来引入基本等词 *)

          Qed.
          #+end_src
          上面的证法很笨很笨
          对等价关系所形成的表达式之间的无向路
          应该有更好的处理方式

          确实coq提供了ring这个函数
          >< 但是如何使用呢?
          下面的用法是不行的
          #+begin_src coq
          Lemma example6 : forall x y, (x + y) * (x + y) = x*x + 2*x*y + y*y.
          Require Import Ring.
          Proof.
            intros.
            ring.
          Qed.
          #+end_src
          #+begin_src coq
          Require Import Omega.
          Lemma omega_example :
            forall f x y, 0 < x ->
                     0 < f x ->
                     3 * f x <= 2 * y ->
                     f x <= y.
          Proof.
            intros.
            omega.
          Qed.
          #+end_src

*** >< proving properties of programs on numbers

*** >< proving properties of programs on lists

* software foundations

*** 數據類型 與 函數語義
    * 一個數據類型被理解爲表達式的集合
      用 Inductive 來遞歸定義新的表達式的集合
    * 用 expression-rewriting
      來理解 function-application
    * 用 pattern-match 定義函數
    * 把 symbol 到 function 的綁定
      理解爲
      symbol 到 rewrite-rule [轉寫規則] 的綁定
      只有當 symbol 在表達式中以 "完全作用形式" 出現時
      所綁定的 rewrite-rule 才有可能被使用
      對 rewrite-rule 的執行
      由 simpl 來指示 [多步 rewrite]
    * 非平凡的構造子
      [非零元函數]
      可以被理解爲
      不對應任何轉寫規則的表達式
      當這種表達式以 "完全形式" 出現時
      沒有任何相關的轉寫
      這種表達式被理解爲是用來編碼數據的結構
      說表達式的結構能夠被反映在模式匹配中
      就是說這種結構在模式匹配 能夠被作爲模式
    * 默認地
      多元函數被完全的一元化 即 curry
      [用箭頭來編碼函數類型的類型系統都是如此
      其實
      使用等待缺口被補全的參數列表
      來編碼函數的類型就行了]
    * 每個可以在表達式中出現的 symbol 一定都對應於一個類型
    * 表達式的結構
      還有 表達式的基本等詞
      [這當然也就包含了 symbol 的基本等詞]
      都首先體現在模式匹配中
    * 對於函數
      其所對應的具體的轉寫規則
      是首先需要瞭解的
    * 對於數據類型
      那些 symbol 作爲它的構造子
      是首先需要瞭解的

*** 證明論
    * 可以理解爲
      利用
      表達式的基本等詞
      還有
      表達式之間的關係
      [能夠被用戶動態引入的]
      來作證明
    * 最簡單的證明就是
      用表達式的基本等詞
      來對兩個表達式的相等關係作以肯定
    * keyword
      [Example] [Theorem] [Lemma] [Fact] [Remark]
      只是名稱不同而已
      語義相同
    * tactic
      [intros]
      [simpl]
      [reflexivity]
    * a tactic is a command
      that is used between [Proof] and [Qed]
      to tell Coq
      how it should check the correctness
      of some claim (on expressions) we are making
    * 每個定理都以表達式的基本等詞爲基礎
      來形成表達式之間的更複雜的關係
      需要知道的是
      有那些方法可以用來從簡單來構架複雜
      於構建關係相平行地
      對更複雜關係的證明也變複雜了
      每個 可以用來從簡單來構架複雜 的方法
      都對應一個 證明方法
    * intros 其實是在臨時給符號以類型
      或者給 兩個符號以相等關係
      兩個符號有相等關係之後
      就能用來 rewrite 了
    * 如果前面證明的是一個等式
      那麼在後面就可以利用這個等式來作 rewrite 了

*** bool
    #+begin_src coq :tangle bool.v
    Inductive bool : Type
      :=
      | true  : bool
      | false : bool.


    Definition negb
               (b : bool) : bool
      :=
        match b with
          | true  => false
          | false => true
        end.


    Definition andb
               (b1 : bool)
               (b2 : bool) : bool
      :=
        match b1 with
          | true => b2
          | false => false
        end.


    Definition orb
               (b1 : bool)
               (b2 : bool) : bool
      :=
        match b1 with
          | true => true
          | false => b2
        end.
    #+end_src

*** nat
    #+begin_src coq :tangle nat.v
    Require Export bool.


    Inductive nat : Type
      :=
      | O : nat
      | S : nat -> nat.


    Fixpoint beq_nat
             (n : nat)
             (m : nat) : bool
      :=
        match n, m with
          | O   , O    => true
          | O   , S m' => false
          | S n', O    => false
          | S n', S m' => beq_nat n' m'
        end.

    Fixpoint ble_nat
             (n : nat)
             (m : nat) : bool
      :=
        match n, m with
          | O   , _    => true
          | S n', O    => false
          | S n', S m' => ble_nat n' m'
        end.


    Fixpoint evenb
             (n : nat) : bool
      :=
        match n with
          | O           =>  true
          | (S O)       =>  false
          | (S (S n'))  =>  (evenb n')
        end.


    Definition oddb
               (n : nat) : bool
      :=
        (negb (evenb n)).


    Definition pred
               (n : nat) : nat
      :=
        match n with
          | O  =>  O
          | (S n')  =>  n'
        end.


    Fixpoint plus
             (n : nat)
             (m : nat) : nat
      :=
        match n with
          | O       =>  m
          | (S n')  =>  (S (plus n' m))
        end.


    Fixpoint mult
             (n : nat)
             (m : nat) : nat
      :=
        match n with
          | O       =>  O
          | (S n')  =>  (plus m (mult n' m))
        end.


    Fixpoint minus
             (n : nat)
             (m : nat) : nat
      :=
        match n, m with
          | O , _   =>  O
          | _ , O   =>  n
          | (S n'), (S m')  =>  (minus n' m')
        end.


    Fixpoint exp
             (base  : nat)
             (power : nat) : nat
      :=
        match power with
          | O      =>  (S O)
          | (S p)  =>  (mult base (exp base p))
        end.


    Fixpoint factorial
             (n : nat) : nat
      :=
        match n with
          | O  =>  O
          | (S O)  =>  (S O)
          | (S n')  =>  (mult n (factorial n'))
        end.
    #+end_src

*** simpl
    * 如上對 nat 的基本函數 的遞歸定義
      其定義中 並沒有展示出 對稱性 和 結合性
      這些運算運算律是需要在之後證明的
    * 何以至此
      能在定義中就展示其 對稱性 與 結合性 邪
    * 當使用自然數的不同的編碼方式時
      情況會不同
    #+begin_src coq :tangle simpl.v
    Require Export nat.


    Theorem plus_O_n :
      forall n : nat,
        (plus O n) = n.
    Proof.
      intros n.  destruct n as [ | n' ].
      (* n = O *)
      simpl.  reflexivity.
      (* n = S n' *)
      simpl.
      (* 從下面的證明可以看出
         在用基本等詞判斷表達式是否相等的時候
         表達式中是可以存在約束變元的
         注意每個約束變元也是有類型的 *)
      reflexivity.
    Qed.


    Theorem plus_n_O :
      forall n : nat,
        (plus n O) = n.
    Proof.
      intros n.  simpl.
      (* Doesn't do anything!
         so we can not just reflexivity *)
      destruct n as [ | n' ].
      simpl.
      reflexivity.
      (* 發現如果按上面的方式定義加法 就沒法證明這個定理 *)
    Abort.


    (* 注意 (plus 1 n) 與 (S n) 的語義差別 *)
    Theorem plus_1_l :
      forall n : nat,
        (plus (S O) n) = (S n).
    Proof.
      intros n.  simpl.  reflexivity.
    Qed.


    Theorem mult_O_l :
      forall n : nat,
        (mult O n) = O.
    Proof.
      intros n.  simpl.  reflexivity.
    Qed.
    #+end_src

*** rewrite
    #+begin_src coq :tangle rewrite.v
    Require Export simpl.


    Theorem plus_id_example :
      forall n m : nat,
        n = m
        -> (plus n n) = (plus m m).
    Proof.
      intros n.
      intros m.

      (* move hypothesis into context *)
      intros h.

      (* rewrite the goal using hypothesis *)
      (* apply the rewrite from left to right *)
      (* from left of  n = m  to right of it *)
      rewrite -> h.
      (* from right to left is also ok *)
      (* from right of  n = m  to left of it *)
      rewrite <- h.

      reflexivity.
    Qed.


    Theorem plus_id_exercise :
      forall n m o : nat,
        n = m
        -> m = o
        -> (plus n m) = (plus m o).
    Proof.
      intros n m o.
      intros h1.
      intros h2.
      rewrite -> h1.
      rewrite <- h2.
      reflexivity.
    Qed.


    Theorem mult_O_plus :
      forall n m : nat,
        (mult (plus O n) m) = (mult n m).
    Proof.
      intros n m.
      rewrite -> plus_O_n.
      reflexivity.
    Qed.


    Theorem mult_S_1 :
      forall n m : nat,
        m = (S n)
        -> (mult m (plus (S O) n)) = (mult m m).
    Proof.
      intros n m.
      intros h.
      (* 類型就是命題
         h : m = S n
         即 h 屬 m = S n 類型
         所以 intros 對上面看似不同的對象的處理方式是一致的 *)
      rewrite -> plus_1_l.
      rewrite <- h.
      reflexivity.
    Qed.
    #+end_src

*** destruct
    * coq 的設計失誤
      當使用 destruct 而形成了 subgoal
      並沒有對 subgoal 的命名機制
    #+begin_src coq :tangle destruct.v
    Require Export rewrite.


    Theorem plus_1_neq_O :
      forall n : nat,
        (beq_nat (plus n (S O)) O) = false.
    Proof.
      intros n.
      simpl.
      (* does nothing!
         the first argument to [+]
         is the unknown number [n]
         and the argument to [beq_nat]
         is the compound expression [n + 1]
         neither can be simplified
         這表明了
         simpl 是跟定義函數的時候
         匹配參數時的順序有關的
         simpl 每次之能處理一個參數 *)
      destruct n as [ | n'].
      (* The [destruct] tactic
         can be used with any inductively defined datatype

         [as] is used to
         bind subcases of the [destruct]
         to variables  *)
      simpl.
      reflexivity.
      simpl.
      reflexivity.
    Qed.

    (* negation is its own inverse *)
    Theorem negb_involutive :
      forall b : bool,
        (negb (negb b)) = b.
    Proof.
      intros b.
      destruct b.
      reflexivity.
      reflexivity.
    Qed.

    Theorem zero_nbeq_plus_1 :
      forall n : nat,
        (beq_nat O (plus n (S O))) = false.
    Proof.
      intros n.  destruct n as [ | n'].
      simpl.  reflexivity.
      simpl.  reflexivity.
    Qed.


    Theorem andb_eq_orb :
      forall (b c : bool),
        (andb b c = orb b c)
        -> b = c.
    Proof.
      intros b c.
      destruct b .
      destruct c.
      simpl.
      intros h.
      reflexivity.
      simpl.
      intros h.
      (* 每個表達式之間的等式都可以被用來作 rewrite
         即使是看似錯誤的 true = false *)
      rewrite <- h.
      reflexivity.
      destruct c.
      simpl .
      intros h.
      rewrite <- h.
      reflexivity.
      simpl.
      intros h.
      reflexivity.
    Qed.
    #+end_src

*** induction
    * 其特點是 需要證明相等的兩個表達式中
      有約束變元是函數作用的參數
      1. 如果 函數的定義中 沒有匹配這個位置的參數
         那麼 可能就不需要歸納法
      2. 如果 函數的定義中 匹配了這個位置的參數
         那麼 可能就需要歸納法
      因爲
      如果 函數根本就沒有匹配某個約束變元
      那麼
      這個約束變元在表達式改寫中
      被改寫的方式 就是平凡的
      注意
      形式上 與 destruct 相比
      induction 向環境中多引入了一個條件
    #+begin_src coq :tangle induction.v
    Require Export destruct.


    Theorem plus_n_O :
      forall n : nat,
        (plus n O) = n.
    Proof.
      intros n. induction n as [ | n' ].
      (* n = 0 *)
      reflexivity.
      (* n = S n'. *)
      simpl. rewrite -> IHn'. reflexivity.
    Qed.


    Theorem minus_diag :
      forall n : nat,
        (minus n n) = O.
    Proof.
      intros n. induction n as [ | n'].
      (* n = 0 *)
      simpl. reflexivity.
      (* n = S n' *)
      simpl. rewrite -> IHn'. reflexivity.
    Qed.


    Theorem mult_O_r :
      forall n : nat,
        (mult n O) = O.
    Proof.
      intros n. induction n as [ | n' ].
      (* n = O *)
      simpl.  reflexivity.
      (* n = S n' *)
      simpl. rewrite -> IHn'.  reflexivity.
    Qed.


    Theorem plus_n_Sm :
      forall n m : nat,
        (S (plus n m)) = (plus n (S m)).
    Proof.
      intros n m.  induction n as  [ | n' ].
      (* n = O *)
      simpl.  reflexivity.
      (* n = S n' *)
      simpl.  rewrite -> IHn'.  reflexivity.
    Qed.


    Theorem plus_comm :
      forall n m : nat,
        (plus n m) = (plus m n).
    Proof.
      intros n m.
      induction n as [ | n' ].
      (* n = O *)
      rewrite -> plus_O_n.
      rewrite -> plus_n_O. reflexivity.
      (* n = S n' *)
      simpl.  rewrite -> IHn'.
      rewrite -> plus_n_Sm.
      reflexivity.
    Qed.


    Theorem plus_assoc :
      forall n m p : nat,
        (plus n (plus m p)) = (plus (plus n m) p).
    Proof.
      intros n m p.  induction n as [ | n' ].
      (* n = O *)
      simpl.  reflexivity.
      (* n = S n' *)
      simpl.  rewrite -> IHn'.
      reflexivity.
    Qed.


    Fixpoint double
             (n : nat) : nat
      :=
        match n with
          | O => O
          | S n' => S (S (double n'))
        end.


    Lemma double_plus :
      forall n : nat,
        (double n) = (plus n n) .
    Proof.
      intros n.  induction n as [ | n' ].
      (* n = O *)
      simpl.  reflexivity.
      (* n = S n' *)
      simpl.  rewrite -> IHn'.
      rewrite -> plus_n_Sm. reflexivity.
    Qed.
    #+end_src

*** assert
    * coq 的設計失誤
      沒有方便的語法
      來指明某次 rewrite 作用的位置
    * 在 assert 中出現的局部變元
      並不是約束變元
      而是在局部環境中被引入了的
      使用它們時
      所能比配到的子表達式是更具體的
      這樣就能用通過使用 assert
      來補救上面的設計失誤
    * 可以發現
      對於有結合律和交換律的二元函數而言
      用前綴表達式或者後綴表達式時
      我們就難以觀察到
      應該使用那些運算律來對表達式進行變換
      可能因爲
      1. 我們不熟悉這些運算律
         在非中綴表達式中的樣子
      2. 中綴表達式對於體現這些運算律而言
         是本質重要的
    #+begin_src coq :tangle assert.v
    Require Export induction.


    Theorem mult_O_plus' :
      forall n m : nat,
        (mult (plus O n) m) = (mult n m).
    Proof.
      intros n m.

      assert (h: (plus O n) = n).
      reflexivity.

      rewrite -> h.  reflexivity.
    Qed.



    Theorem plus_rearrange :
      forall n m p q : nat,
        (plus (plus n m) (plus p q))
        = (plus (plus m n) (plus p q)).
    Proof.
      intros n m p q.

      rewrite -> plus_comm.
      (* doesn't work
         for coq rewrote the wrong plus *)
      rewrite -> plus_comm.

      assert (h: (plus n m) = (plus m n)).
      (* lemma *)
        rewrite -> plus_comm. reflexivity.

      rewrite -> h. reflexivity.
    Qed.



    Theorem plus_swap :
      forall n m p : nat,
        (plus n (plus m p))
        = (plus m (plus n p)).
    Proof.
      intros n m p.

      assert (l1 : (plus n (plus m p)) = (plus (plus n m) p)).
      rewrite -> plus_assoc. reflexivity.

      assert (l2 : (plus m (plus n p)) = (plus (plus m n) p)).
      rewrite -> plus_assoc. reflexivity.

      assert (l3 : (plus m n) =  (plus n m)).
      rewrite -> plus_comm. reflexivity.

      rewrite -> l1.
      rewrite -> l2.
      rewrite -> l3.
      reflexivity.
    Qed.



    Theorem left_mult_step_distribution :
      forall n m : nat,
        (plus m (mult m n)) = (mult m (S n)).
    Proof.
      intros n m.

      induction m as [ | m' ].

      (* m = O *)
      simpl.
      reflexivity.

      (* m = S m' *)
      simpl.
      rewrite ->  plus_swap.
      rewrite ->  IHm'.
      reflexivity.
    Qed.



    Theorem mult_comm :
      forall n m : nat,
        (mult n m) = (mult m n).
    Proof.
      intros n m.

      induction n as [ | n' ].
      (* n = O *)
      simpl.  rewrite -> mult_O_r.
      reflexivity.

      (* n = S n' *)
      simpl.
      rewrite -> IHn'.
      rewrite -> left_mult_step_distribution.
      reflexivity.
    Qed.



    Theorem evenb_n__oddb_Sn :
      forall n : nat,
        (evenb n) = (negb (evenb (S n))).
    Proof.
      intros n.

      induction n as [ | n' ].

      (* n = O *)
      simpl. reflexivity.

      (* n = S n' *)
      simpl.
    Abort.



    Theorem ble_nat_refl :
      forall n : nat,
        true = (ble_nat n n).
    Proof.
      intros n.
      induction n as [ | n' ].
      (* n = true *)
      simpl. reflexivity.
      (* n = S n' *)
      simpl.  rewrite <- IHn'. reflexivity.
    Qed.


    Theorem zero_nbeq_S :
      forall n : nat,
        (beq_nat O (S n)) = false.
    Proof.
      intros n.
      simpl. reflexivity.
    Qed.


    Theorem andb_false_r :
      forall b : bool,
        (andb b false) = false.
    Proof.
      intros b.
      destruct b as [ | ].
      (* b = true *)
      simpl. reflexivity.
      (* b = false *)
      simpl. reflexivity.
    Qed.

    Theorem plus_ble_compat_l :
      forall n m p : nat,
        (ble_nat n m) = true
        -> (ble_nat (plus p n) (plus p m)) = true.
    Proof.
      intros n m p.
      intros h.
      induction p as [ | p'].
      (* p = O *)
      simpl. rewrite -> h. reflexivity.
      (* p = S p' *)
      simpl. rewrite -> IHp'. reflexivity.
    Qed.


    Theorem S_nbeq_0 :
      forall n : nat,
        (beq_nat (S n) O) = false.
    Proof.
      intros n.
      simpl. reflexivity.
    Qed.


    Theorem mult_1_l :
      forall n : nat,
        (mult (S O) n) = n.
    Proof.
      intros n.
      simpl. rewrite -> plus_n_O. reflexivity.
    Qed.


    Theorem all3_spec :
      forall b c : bool,
        (orb
           (andb b c)
           (orb (negb b)
                (negb c)))
        = true.
    Proof.
      intros b c.
      destruct b as [ | ].
      destruct c as [ | ].
      (* b = true *)
      (* c = true *)
      simpl. reflexivity.
      (* c = false *)
      simpl. reflexivity.
      (* b = false *)
      simpl. reflexivity.
    Qed.


    Theorem mult_plus_distr_r :
      forall n m p : nat,
        (mult (plus n m) p)
        = (plus (mult n p) (mult m p)).
    Proof.
      intros n m p.
      induction n as [ | n' ].
      (* n = O *)
      simpl. reflexivity.
      (* n = S n' *)
      simpl.
      rewrite -> IHn'.
      rewrite -> plus_assoc.
      reflexivity.
    Qed.


    Theorem mult_assoc :
      forall n m p : nat,
        (mult n (mult m p))
        = (mult (mult n m) p).
    Proof.
      intros n m p.
      induction n as [ | n' ].
      (* n = O *)
      simpl. reflexivity.
      (* n = S n' *)
      simpl.
      rewrite -> mult_plus_distr_r.
      rewrite -> IHn'.
      reflexivity.
    Qed.


    Theorem beq_nat_refl :
      forall n : nat,
        true = (beq_nat n n).
    Proof.
      intros n.
      induction n as [ | n' ].
      (* n = O *)
      simpl. reflexivity.
      (* n = S n' *)
      simpl. rewrite -> IHn'. reflexivity.
    Qed.



    Theorem plus_swap' :
      forall n m p : nat,
        (plus n (plus m p))
        = (plus m (plus n p)).
    Proof.
      intros n m p.
      rewrite -> plus_assoc.
      rewrite -> plus_assoc.
      replace (plus n m) with (plus m n).
      reflexivity.
      rewrite -> plus_comm.
      reflexivity.
    Qed.
    #+end_src

*** bin

    * 就是反過來的二進制編碼
      | 0 |   0 | Z       |
      | 1 |   1 | i Z     |
      | 2 |  10 | o i Z   |
      | 3 |  11 | i i Z   |
      | 4 | 100 | o o i Z |
      | 5 | 101 | i o i Z |
      | 6 | 110 | o i i Z |
      | 7 | 111 | i i i Z |
    #+begin_src coq
    Inductive bin : Type
      :=
      | Z : bin
      | o : bin -> bin
      | i : bin -> bin.
    #+end_src

*** 關於什麼是證明

    * 作者對證明的認識
      強調了證明的主觀性
      但是
      我的以基本等詞爲基礎的理論
      將強調等詞的客觀性
    * 其實在我看來
      作者的證明主觀論
      是無法被接受的
    * 我可以理解
      作者之所以有這種強調
      是因爲他認識到了形式證明的不易讀性
      而我認爲
      這種不易讀性的本質
      來源於對等詞的錯誤認識
      即對等詞的使用的限制
      只要能夠在形式證明中以靈活的方式引入等詞
      那麼就能改變形式證明不易讀的狀況

* coq art

* (adam chlipala) certified programming with dependent types

* inria tutorial

* oberwolfach hott tutorial

* oplss 2011

*** link

    - https://www.cs.uoregon.edu/research/summerschool/summer11/curriculum.

*** (hugo herbelin) the calculus of inductive constructions

*** (benjamin pierce) proof theory in coq

*** (dana scott) what is a proof?

*** (john harrison) formal verification in industry

*** (robert constable) design issues for implemented type theories
