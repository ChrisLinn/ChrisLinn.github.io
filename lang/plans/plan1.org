* 可構造性的譜系

  - x ::
       (1) 可以構造出來的東西
       (2) 假設可以構造出來的東西 還有這些東西上的操作
       爲什麼說 微分幾何中定義流形的方式
       只是在考慮假設可以構造出來的東西

  - k ::
       但是要知道
       這種考慮其實有主觀的一面
       即 如果這個構造方式非常複雜
       在發展理論的時候
       人們就不給出實際的構造 而只是假設構造存在
       其實這些東西也是可以構造

  - x ::
       也就是說
       我們應該 用簡單的構造代替複雜的構造
       使得人們能夠常常考慮構造的例子

* draw1

  - k ::
       所以是不是根本就沒有必要批判 流形的理論 和 微分幾何的方法
       我們是因爲不熟悉這些知識
       所以想要批判它
       可能這種知識不適合我們 ?

  - x ::
       其實我們是無法避免這些知識的
       如果 在給出一個語言形式化代數拓撲之後
       我們還想 讓這個系統能夠自動繪製出一些圖像
       來幫助我們理解這些構造
       那麼 微分幾何 還有 代數幾何 的知識就是必要的
       並且要注意
       於我們有用的知識 將是數字化的
       因爲
       我們需要在座標系中
       用點陣繪製出 看似光滑的圖形 [或者說 可以任意精確的圖形]

* 語言設計計劃

  - k ::
       目前我們計劃實現 at1 和 draw1
       因爲 我們要獲得自治
       所以 我們不可能用已有的程序語言來實現它們
       我們必須先實現一個通用的程序語言

  - x ::
       也許是 這個通用的程序語言就是
       從 sequent0 發展出來的 sequent2
       實現的計劃將是
       (0) 首先要知道 編譯是自治的前提
       (1) 用底層語言實現一個虛擬機 vm1
       (2) 用任意語言寫一個 (sequent2 -> vm1)
       (3) 用 sequent2 寫 (sequent2 -> vm1)

  - k ::
       作爲一個通用的語言
       sequent2 需要有什麼性質 ?

  - x ::
       (1) 靈活可擴展的類型系統
       也就是說 '類型安全' 的意義是可以擴展的
       真實的安全性 依賴於 使用這個擴展機制添加新類型的用戶
       (2) 模塊系統 與 包管理

  - k ::
       作爲 sequent2 的編譯對象
       vm1 需要有什麼性質 ?

  - x ::
       ><><><

  - k ::
       作爲 dependent-type language
       sequent2 與 vm1 之間有什麼關係

  - x ::
       注意之前所得到的重要結論
       '類型檢查器是一個獨立的解釋器'
       這裏的實現計劃能夠與這個結論相容嗎 ?

  - k ::
       類型檢查器 和 編譯器 都是特殊的解釋器
       問題就是在目前的計劃中
       是否應該將二者的實現分離

  - x ::
       我想正確的實現方式是
       實現一個 解釋器
       它能夠 做類型檢查 但是以低效的方式運行代碼
       [這就是上面的重要結論 '類型檢查器是一個獨立的解釋器']
       之後在這個解釋器中
       加入生成目標代碼的功能
       這就是編譯器了
       這個編譯器 可以用到很多 類型檢查中所獲得信息


* 關於語法擴展系統

  - x ::
       放棄語法擴展系統
