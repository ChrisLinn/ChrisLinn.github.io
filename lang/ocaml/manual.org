#+TITLE:  the manual says
#+AUTHOR: 謝宇恆 / XIE Yuheng

* Chapter 1  The core language

*** 1.1  Basics
    1. ocaml : the interactive system
    2. cicada 对 phrases 的处理方式已经 超过 ocaml 了
       cicada 的处理方式更简洁 并且易于理解
    #+begin_src caml
    let pi = 4.0 *. atan 1.0;;

    let square x = x *. x;;

    square (sin pi) +. square (cos pi);;

    let rec fib n =
      if n < 2
      then n
      else fib (n-1) + fib (n-2);;

    fib 10;;
    #+end_src

*** 1.2  Data types
    #+begin_src caml
    (2 < 1) = false;;

    'a';;

    "hello world";;

    let l = ["is"; "a"; "tale"; "told"; "etc."];;

    (* 下面的是 cons 是函数式的 而非副作用
     * 这对于符号计算来说非常好
     * 但是对于有向图处理来说并不好 *)
    "life" :: l;;

    let rec sort list =
      match list with
      | [] -> []
      | head :: tail -> insert head (sort tail)
    and insert element list =
      match list with
      | [] -> [element]
      | head :: tail ->
          if element <= head
          then element :: list
          else head :: insert element tail
    ;;

    (* = 还有 <= 这两个函数是多态的
     * 或者说是 重载的
     * 所以 sort 有这样的类型
     * 但是 其实 = 和 <= 并不是函数
     * 它们是 中缀的 *)
    sort;;

    sort l;;

    sort [6;2;5;3];;

    sort [3.14; 2.718];;
    #+end_src

*** 1.3  Functions as values
    #+begin_src caml
    (* 微分算子 以函数为参数 以函数为返回值 *)
    let deriv f dx = function x -> (f (x +. dx) -. f x) /. dx;;

    let sin' = deriv sin 1e-6;;

    sin' pi;;


    let compose f g = function x -> f (g x);;

    let cos2 = compose square cos;;


    List.map (function n -> n * 2 + 1) [0;1;2;3;4];;

    let rec map f l =
      match l with
      | [] -> []
      | hd :: tl -> f hd :: map f tl;;

    map (function n -> n * 2 + 1) [0;1;2;3;4];;

    map cos2 [0.;1.;2.;3.;4.];;
    #+end_src

*** 1.4  Records and variants
    1. records and variants
       是用户定义类型的两种方式
       variants 是个很有趣的命名
       这个命名也许来源于这个词在法语中的词义
       可以理解为:
       1) 构造子 (利用 of 这个虚词) 对数据的变化
       2) of 这个虚词 外加一个 词
          形成 形容词短语 或 定语
          以 在已有的 类型上 演化出来的新类型
    #+begin_src caml
    type ratio = {num: int; denom: int};;

    let add_ratio r1 r2 =
      {num = r1.num * r2.denom + r2.num * r1.denom;
       denom = r1.denom * r2.denom};;

    add_ratio {num=1; denom=3} {num=2; denom=5};;


    type number =
      | Int of int
      | Float of float
      | Error;;


    type sign =
      | Positive
      | Negative;;

    let sign_int n =
      if n >= 0
      then Positive
      else Negative;;


    let add_num n1 n2 =
      match (n1, n2) with
      | (Int i1, Int i2) ->
          (* Check for overflow of integer addition *)
          if sign_int i1 = sign_int i2
              && sign_int (i1 + i2) <> sign_int i1
          then Float(float i1 +. float i2)
          else Int(i1 + i2)
      | (Int i1, Float f2) -> Float(float i1 +. f2)
      | (Float f1, Int i2) -> Float(f1 +. float i2)
      | (Float f1, Float f2) -> Float(f1 +. f2)
      | (Error, _) -> Error
      | (_, Error) -> Error;;

    add_num (Int 123) (Float 3.14159);;


    type 'a btree =
      | Empty
      | Node of 'a * 'a btree * 'a btree
    ;;


    let rec member x btree =
      match btree with
      | Empty -> false
      | Node(y, left, right) ->
          if x = y then true else
          if x < y then member x left else member x right
    ;;

    let rec insert x btree =
      match btree with
      | Empty -> Node(x, Empty, Empty)
      | Node(y, left, right) ->
          if x <= y then Node(y, insert x left, right)
          else Node(y, left, insert x right)
    ;;
    #+end_src

*** 1.6  Exceptions
    #+begin_src caml
    exception Empty_list;;

    let head l =
      match l with
        [] -> raise Empty_list
      | hd :: tl -> hd;;

    head [1;2];;

    head [];;


    List.assoc 1 [(0, "zero"); (1, "one")];;

    List.assoc 2 [(0, "zero"); (1, "one")];;


    let name_of_binary_digit digit =
      try
        List.assoc digit [0, "zero"; 1, "one"]
      with Not_found ->
        "not a binary digit";;

    name_of_binary_digit 0;;
    name_of_binary_digit (-1);;
    #+end_src

*** 1.7  Symbolic processing of expressions
    #+begin_src caml
    type expression =
      | Const of float
      | Var of string
      | Sum of expression * expression    (* e1 + e2 *)
      | Diff of expression * expression   (* e1 - e2 *)
      | Prod of expression * expression   (* e1 * e2 *)
      | Quot of expression * expression   (* e1 / e2 *)
    ;;

    exception Unbound_variable of string;;

    let rec eval env exp =
      match exp with
      | Const c -> c
      | Var v ->
          (try List.assoc v env
           with Not_found ->
            raise (Unbound_variable v))
      | Sum(f, g) -> eval env f +. eval env g
      | Diff(f, g) -> eval env f -. eval env g
      | Prod(f, g) -> eval env f *. eval env g
      | Quot(f, g) -> eval env f /. eval env g
    ;;

    eval [("x", 1.0); ("y", 3.14)]
      (Prod(Sum(Var "x", Const 2.0), Var "y"))
    ;;
    eval [("x", 1.0); ("y", 3.14)]
      (Prod(Sum(Var "x", Const 2.0), Var "z"))
    ;;


    let rec deriv exp dv =
      match exp with
      | Const c -> Const 0.0
      | Var v -> if v = dv then Const 1.0 else Const 0.0
      | Sum(f, g) -> Sum(deriv f dv, deriv g dv)
      | Diff(f, g) -> Diff(deriv f dv, deriv g dv)
      | Prod(f, g) -> Sum(Prod(f, deriv g dv), Prod(deriv f dv, g))
      | Quot(f, g) -> Quot(Diff(Prod(deriv f dv, g), Prod(f, deriv g dv)),
                           Prod(g, g))
    ;;

    deriv (Quot(Const 1.0, Var "x")) "x";;
    #+end_src

*** 1.8  Pretty-printing and parsing
    #+begin_src caml
    let print_expr exp =
      (* Local function definitions *)
      let open_paren prec op_prec =
        if prec > op_prec then print_string "(" in
      let close_paren prec op_prec =
        if prec > op_prec then print_string ")" in
      let rec print prec exp =
        (* prec is the current precedence *)
        match exp with
          Const c -> print_float c
        | Var v -> print_string v
        | Sum(f, g) ->
            open_paren prec 0;
            print 0 f; print_string " + "; print 0 g;
            close_paren prec 0
        | Diff(f, g) ->
            open_paren prec 0;
            print 0 f; print_string " - "; print 1 g;
            close_paren prec 0
        | Prod(f, g) ->
            open_paren prec 2;
            print 2 f; print_string " * "; print 2 g;
            close_paren prec 2
        | Quot(f, g) ->
            open_paren prec 2;
            print 2 f; print_string " / "; print 3 g;
            close_paren prec 2
      in print 0 exp
    ;;

    let e = Sum(Prod(Const 2.0, Var "x"), Const 1.0);;

    print_expr e; print_newline ();;

    print_expr (deriv e "x"); print_newline ();;
    #+end_src

*** 1.9  Standalone OCaml programs
    ocamlc -o fib  fib.ml
    #+begin_src caml
    (* File fib.ml *)
    let rec fib n =
      if n < 2
      then 1
      else fib (n-1) + fib (n-2)
    ;;

    let main () =
      let arg = int_of_string Sys.argv.(1) in
      print_int (fib arg);
      print_newline ();
      exit 0;;

    main ();;
    #+end_src

* Chapter 2  The module system

*** 2.1  Structures
    1. modules
       在这里 模块系统是一种命名空间的管理方式
    #+begin_src caml
    module PrioQueue  =
      struct
        type priority = int
        type 'a queue = Empty | Node of priority * 'a * 'a queue * 'a queue
        let empty = Empty
        let rec insert queue prio elt =
          match queue with
            Empty -> Node(prio, elt, Empty, Empty)
          | Node(p, e, left, right) ->
              if prio <= p
              then Node(prio, elt, insert right p e, left)
              else Node(p, e, insert right prio elt, left)
        exception Queue_is_empty
        let rec remove_top = function
            Empty -> raise Queue_is_empty
          | Node(prio, elt, left, Empty) -> left
          | Node(prio, elt, Empty, right) -> right
          | Node(prio, elt, (Node(lprio, lelt, _, _) as left),
                 (Node(rprio, relt, _, _) as right)) ->
                   if lprio <= rprio
                   then Node(lprio, lelt, remove_top left, right)
                   else Node(rprio, relt, left, remove_top right)
        let extract = function
            Empty -> raise Queue_is_empty
          | Node(prio, elt, _, _) as queue -> (prio, elt, remove_top queue)
      end;;

    PrioQueue.insert PrioQueue.empty 1 "hello";;
    #+end_src

*** 2.2  Signatures
    #+begin_src caml
    module type PRIOQUEUE =
      sig
        type priority = int         (* still concrete *)
        type 'a queue               (* now abstract *)
        val empty : 'a queue
        val insert : 'a queue -> int -> 'a -> 'a queue
        val extract : 'a queue -> int * 'a * 'a queue
        exception Queue_is_empty
      end;;

    module AbstractPrioQueue = (PrioQueue : PRIOQUEUE);;

    AbstractPrioQueue.remove_top;;

    AbstractPrioQueue.insert AbstractPrioQueue.empty 1 "hello";;
    #+end_src
