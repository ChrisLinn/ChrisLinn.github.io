* 題解

  - cicada-vm-in-js

* 討論 <2016-02-02>

  - x ::
       explainer 是否要保存在 jojo 中呢
       形如
       #+begin_src js
       def ("little-test-number", "integer", "integer", 4);

       def ("square", "->", null,
            [ new JO (primitive_function_explainer, name("dup")),
              new JO (primitive_function_explainer, name("mul")),
              new JO (primitive_function_explainer, name("end")),
            ]
           );

       def("little-test", "->", null,
           [ new JO (variable_explainer, name("little-test-number")),
             new JO (function_explainer, name("square")),
             new JO (primitive_function_explainer, name("simple-wirte")),
             new JO (primitive_function_explainer, name("bye")),
           ]
          );
       #+end_src
       特點是
       浪費內存
       編譯時需要把 explainer 安排好
       不同的 explainer 可以用來解釋不同的 literal
       這樣各種數據類型在 jojo 中的出現就解決了

  - k ::
       上面這種感覺類似 Subroutine Threaded Code (STC)
       而還可以使用古典的 Indirect Threaded Code (ITC)
       此時 jojo 中不保存 explainer
       而是單純保存 name

  - x ::
       對於
       上面的 三種簡單的 explainer 的情形
       不保存 explainer 算是很優雅的解法了
       但是當有 literal 的時候
       也就是
       不是從名字來找到數據的時候
       就不好處理了

  - k ::
       此時可以像以前一樣去實現特殊的 primitive_function
       這些 primitive_function 把 return_stack 後面的數據作爲 literal

  - x ::
       這次我選擇後 explainer 在 jojo 中的處理方式
       並把這些 explainer 稱作 instruction

  -----------------------------

  - x ::
       我發現
       如果想要使用 instruction
       那麼 每個 instruction data 所構成都 jo
       在有 eval 的同時還要有 type-eval
       設計底層語義 就是設計 instruction
       這樣就是說每個底層語義 都要考慮到其 類型意義

  - k ::
       我想所謂的對 instruction 的擴展可能是虛有的性質
       可能所設計的是一套固定的簡單的 instruction 而已
       並不能很好地在如此底層的語義上進行擴展

  - x ::
       在這個層次上 每次擴展的時候都要考慮類型 確實是必要的
       但是 我們先不考慮將來的擴展
       而考慮現在的模式匹配語義

  - k ::
       首先是 eval 然後是 type-eval

  - x ::
       兩種 eval 方式
       就是對同樣的結構化的數據的兩種處理方式
       完全是可以想像的
       jojo 的兩種 eval 很簡單
       重要的是 majo
       首先 eval
       unify 前項與棧中值 以選擇
       然後把選好的 jojo 入返回棧
       其次 type-eval
       每個分支分別處理
       每次處理就是
    1. 把 computed antecedent 入棧
       用 declared antecedent 匹配它 [unify 它]
    2. 然後看
       computed succedent 是否可以和
       declared succedent unify
    3. 注意每次 處理 'computed' 的時候
       都需要遞歸調用 type-eval
    4. 最後也許需要
       將分支情形 '加' 到一起
       然後做完全性檢查

* <2016-02-08>

  - x ::
       local_variable_map 應該是在運行時生成的
       我想到的處理方式是
       在 return_point 中做一個 local_variable_map field
       這樣就能 return_point 就是運行時用 jojo 生成的
       這樣就能達到效果了
       但是在 pattern match 的過程中還需要 undo binds
       而目前的這種設計是不利於 undo binds
       我還不知道如何處理 undo binds
       我能想到的方法之一是使用 undo record

  - k ::
       回憶之前的 little-prolog
       undo 就是 clear-determinacy
       用一個 undo-record 就能實現了
       只要在 每次 unification 失敗之後
       apply undo-record 就行了

  - x ::
       但是 這個 local_variable_map 不應該跟隨 r
       而應該跟隨 每個 local_variable
       這樣返回 local_variable 的時候 就能利用 native GC 來處理了
       也就是說每個 local_variable 都帶有一個
       local_variable_map 來告知應該在哪裏找到其值

  - k ::
       但是重要的是要能知道約束變元之間的等同關係
       其實就是對 scope 的處理
       我們之前使用的　一個 r 一個 scope 的方式
       並不能滿足 unification 的需要

  - x ::
       其實一個 r 一個 scope 的方式是合理的
       local_variable_map 跟隨 local_variable 也是合理的
       當遇到一個 local_variable 而 determinacy 不夠的時候
       就用當前 r 的 local_variable_map 補全 local_variable_map 這個域
       每次看到 local_variable 的時候
       如果見到 local_variable_map 這個域
       就優先使用這個域
       沒有這個域的時候 就用當前 r 的 local_variable_map
       這樣就能返回不確定的 local_variable 了
       而 apply undo-record 是在 unification 失敗時進行的
       在主要的流程中不必管理此類對 binding 的回收
  ---------------------
  - x ::
       我發現 primitive_function 因該被處理爲 -> 的 subtype
       但是 1 的類型是 { -> integer }
       也應該被看作是 以 -> 爲 type-constructor 的
       如何處理這一點呢
       還有一個難點在於 jo_unify 會 dispatch on typetag
       但是 array 的 typetag 是 ->
       而 primitive_function 的 typetag 也是 ->

  - k ::
       應該區分開來
       tag 應該細分到足以使底層的語義可以全部通過 dispatch 到 tag 來實現
       tag 就是 type constructor
       基本的 tag 有 prim jojo type integer pair 等等
       基本的 語義層次的 dispatch 有
    1. 關於執行
       return_stack interpreter
       在解釋 return_stack 中的 jojo 時
       應該如何處理每個 jo
    2. 關於檢查
       即 check 域
       ><><><
    3. 關於命名
       在解釋 jojo 時
       遇到 name 又有一層 dispatch
