* sokuza-kanren
  #+begin_src scheme
  ;;                    Quick miniKanren-like code

  ;; written at the meeting of a Functional Programming Group
  ;; (Toukyou/Shibuya, Apr 29, 2006), as a quick illustration of logic
  ;; programming.  The code is really quite trivial and unsophisticated:
  ;; it was written without any preparation whatsoever. The present file
  ;; adds comments and makes minor adjustments.

  ;; $Id: sokuza-kanren.scm,v 1.1 2006/05/10 23:12:41 oleg Exp oleg $


  ;; Point 1: `functions' that can have more (or less) than one result

  ;; As known from set theory, a binary relation xRy (where x in X, y in Y)
  ;; can be represented by a function: X -> PowerSet{Y}. As usual in
  ;; computer science, we interpret the set PowerSet{Y} as a multi-set
  ;; (realized as a regular scheme list). Compare with SQL, which likewise
  ;; uses multisets and sequences were sets are properly called for.
  ;; Also compare with Wadler's `representing failure as a list of successes.'

  ;; Thus, we represent a 'relation' (aka `non-deterministic function')
  ;; as a regular scheme function that returns a list of possible results.
  ;; Here, we use a regular list rather than a lazy list, just to be quick.

  ;; First, we define two primitive non-deterministic functions;
  ;; one of them yields no result whatsoever for any argument; the other
  ;; merely returns its argument as the sole result.

  (define (fail x) '())
  (define (succeed x) (list x))

  ;; We build more complex non-deterministic functions by combining
  ;; the existing ones with the help of the following two combinators.


  ;; (disj f1 f2) returns all the results of f1 and all the results of f2.
  ;; (disj f1 f2) returns no results only if neither f1 nor f2 returned
  ;; any. In that sense, it is analogous to the logical disjunction.
  (define (disj f1 f2)
    (lambda (x)
      (append (f1 x) (f2 x))))

  ;; (conj f1 f2) looks like a `functional composition' of f2 and f1.
  ;; Only (f1 x) may return several results, so we have to apply f2 to
  ;; each of them.
  ;; Obviously (conj fail f) and (conj f fail) are both equivalent to fail:
  ;; they return no results, ever. It that sense, conj is analogous to the
  ;; logical conjunction.
  (define (conj f1 f2)
    (lambda (x)
      (apply append (map f2 (f1 x)))))

  ;; conj 与 disj 所能处理的函数的输入是值输出是值的列表
  ;; 这对于处理二元关系来说足够了
  ;; 但是这样就失去了一些一致性
  ;; 我改用map处理函数 conj 与 disj 所处理的函数将是:
  ;; 输入列表然后返回列表

  ;; 因为递归调用而可能让输入与输出的列表返回无限个元素
  ;; 所以我必须用lazy-list来实现这些输入与输出
  ;; 我也许还必须实现``对角线法则''

  ;; Examples
  (define (cout . args)
    (for-each display args))
  (define nl #\newline)

  (cout "test1" nl
        ((disj
          (disj fail succeed)
          (conj
           (disj (lambda (x) (succeed (+ x 1)))
                 (lambda (x) (succeed (+ x 10))))
           (disj succeed succeed)))
         100)
        nl)
  ;; => (100 101 101 110 110)


  ;; Point 2: (Prolog-like) Logic variables

  ;; One may think of regular variables as `certain knowledge': they give
  ;; names to definite values.  A logic variable then stands for
  ;; `improvable ignorance'.  An unbound logic variable represents no
  ;; knowledge at all; in other words, it represents the result of a
  ;; measurement _before_ we have done the measurement. A logic variable
  ;; may be associated with a definite value, like 10. That means
  ;; definite knowledge.  A logic variable may be associated with a
  ;; semi-definite value, like (list X) where X is an unbound
  ;; variable. We know something about the original variable: it is
  ;; associated with the list of one element.  We can't say though what
  ;; that element is. A logic variable can be associated with another,
  ;; unbound logic variable. In that case, we still don't know what
  ;; precisely the original variable stands for. However, we can say that it
  ;; represents the same thing as the other variable. So, our
  ;; uncertainty is reduced.

  ;; We chose to represent logic variables as vectors:
  (define (var name) (vector name))
  (define var? vector?)

  ;; We implement associations of logic variables and their values
  ;; (aka, _substitutions_) as associative lists of (variable . value)
  ;; pairs.
  ;; One may say that a substitution represents our current knowledge
  ;; of the world.

  (define empty-subst '())
  (define (ext-s var value s)
    (cons (cons var value) s))

  ;; Find the value associated with var in substitution s.
  ;; Return var itself if it is unbound.
  ;; In miniKanren, this function is called 'walk'
  (define lookup
    (lambda (var s)
      (cond
       [(not (var? var)) var]
       [(assq var s) => (lambda (b) (lookup (cdr b) s))]
       [else var])))

  ;; There are actually two ways of implementing substitutions as
  ;; associative list.
  ;; If the variable x is associated with y and y is associated with 1,
  ;; we could represent this knowledge as
  ;; ((x . 1) (y . 1))
  ;; It is easy to lookup the value associated with the variable then,
  ;; via a simple assq. OTH, if we have the substitution ((x . y))
  ;; and we wish to add the association of y to 1, we have
  ;; to make rearrangements so to produce ((x . 1) (y . 1)).
  ;; OTH, we can just record the associations as we learn them, without
  ;; modifying the previous ones. If originally we knew ((x . y))
  ;; and later we learned that y is associated with 1, we can simply
  ;; prepend the latter association, obtaining ((y . 1) (x . y)).
  ;; So, adding new knowledge becomes fast. The lookup procedure becomes
  ;; more complex though, as we have to chase the chains of variables.
  ;; To obtain the value associated with x in the latter substitution, we
  ;; first lookup x, obtain y (another logic variable), then lookup y
  ;; finally obtaining 1.
  ;; We prefer the latter, incremental way of representing knowledge:
  ;; it is easier to backtrack if we later find out our
  ;; knowledge leads to a contradiction.


  ;; Unification is the process of improving knowledge: or, the process
  ;; of measurement. That measurement may uncover a contradiction though
  ;; (things are not what we thought them to be). To be precise, the
  ;; unification is the statement that two terms are the same. For
  ;; example, unification of 1 and 1 is successful -- 1 is indeed the
  ;; same as 1. That doesn't add however to our knowledge of the world. If
  ;; the logic variable X is associated with 1 in the current
  ;; substitution, the unification of X with 2 yields a contradiction
  ;; (the new measurement is not consistent with the previous
  ;; measurements/hypotheses).  Unification of an unbound logic variable
  ;; X and 1 improves our knowledge: the `measurement' found that X is
  ;; actually 1.  We record that fact in the new substitution.


  ;; return the new substitution, or #f on contradiction.
  (define (unify t1 t2 s)
    (let (;; find out what t1 actually is given our knowledge s
          (t1 (lookup t1 s))
          ;; find out what t2 actually is given our knowledge s
          (t2 (lookup t2 s)))
      (cond
        ((eq? t1 t2) s)           ;t1 and t2 are the same; no new knowledge
        ((var? t1)                ;t1 is an unbound variable
          (ext-s t1 t2 s))
        ((var? t2)                ;t2 is an unbound variable
          (ext-s t2 t1 s))
        ((and (pair? t1) (pair? t2)) ;if t1 is a pair, so must be t2
          (let ((s (unify (car t1) (car t2) s)))
            (and s (unify (cdr t1) (cdr t2) s))))
        ((equal? t1 t2) s)        ;t1 and t2 are really the same values
        (else #f))))


  ;; define a bunch of logic variables, for convenience
  (define vx (var 'x))
  (define vy (var 'y))
  (define vz (var 'z))
  (define vq (var 'q))

  (cout "test-u1" nl
        (unify vx vy empty-subst)
        nl)
  ;; => ((#(x) . #(y)))

  (cout "test-u2" nl
        (unify vx 1 (unify vx vy empty-subst))
        nl)
  ;; => ((#(y) . 1) (#(x) . #(y)))

  (cout "test-u3" nl
    (lookup vy (unify vx 1 (unify vx vy empty-subst)))
    nl)
  ;; => 1
  ;; when two variables are associated with each other,
  ;; improving our knowledge about one of them improves the knowledge of the
  ;; other

  (cout "test-u4" nl
    (unify (cons vx vy) (cons vy 1) empty-subst)
    nl)
  ;; => ((#(y) . 1) (#(x) . #(y)))
  ;; exactly the same substitution as in test-u2



  ;; Part 3: Logic system

  ;; logic programming 听起来很梦幻
  ;; 但是实现起来其实很简单
  ;; 它由下面的要点组成:
  ;; 多值函数, lattice-processing, lazy-list, a good interface

  ;; Now we can combine non-deterministic functions (Part 1) and
  ;; the representation of knowledge (Part 2) into a logic system.
  ;; We introduce a 'goal' -- a non-deterministic function that takes
  ;; a substitution and produces 0, 1 or more other substitutions (new
  ;; knowledge). In case the goal produces 0 substitutions, we say that the
  ;; goal failed. We will call any result produced by the goal an 'outcome'.

  ;; The functions 'succeed' and 'fail' defined earlier are obviously
  ;; goals.  The latter is the failing goal. OTH, 'succeed' is the
  ;; trivial successful goal, a tautology that doesn't improve our
  ;; knowledge of the world. We can now add another primitive goal, the
  ;; result of a `measurement'.  The quantum-mechanical connotations of
  ;; `the measurement' must be obvious by now.

  (define ==
    ;; return list-of-alist
    (lambda (t1 t2)
      (lambda (s)
        (cond
         [(unify t1 t2 s) => succeed]
         [else (fail s)]
         ))))

  ;; We also need a way to 'run' a goal,
  ;; to see what knowledge we can obtain starting from sheer ignorance
  (define (run g) (g empty-subst))


  ;; We can build more complex goals using lambda-abstractions and previously
  ;; defined combinators, conj and disj.
  ;; For example, we can define the function `choice' such that
  ;; (choice t1 a-list) is a goal that succeeds if t1 is an element of a-list.

  (define choice
    (lambda (var lst)
      (if (null? lst)
        fail
        (disj
         (== var (car lst))
         (choice var (cdr lst))))))

  (cout "test choice 1" nl
        (run (choice 2 '(1 2 3)))
        nl)
  ;; => (()) success

  (cout "test choice 2" nl
        (run (choice 10 '(1 2 3)))
        nl)
  ;; => ()
  ;; empty list of outcomes: 10 is not a member of '(1 2 3)

  (cout "test choice 3" nl
        (run (choice vx '(1 2 3)))
        nl)
  ;; => (((#(x) . 1)) ((#(x) . 2)) ((#(x) . 3)))
  ;; three outcomes

  ;; The name `choice' should evoke The Axiom of Choice...

  ;; Now we can write a very primitive program: find an element that is
  ;; common in two lists:

  (define (common-el l1 l2)
    (conj
     (choice vx l1)
     (choice vx l2)))

  ;; (define (disj f1 f2)
  ;;   ;; 增加 list-of-alist 的宽度
  ;;   ;; 失败的时候就不增加 list-of-alist 的宽度
  ;;   (lambda (x) (append (f1 x) (f2 x))))
  ;; (define (conj f1 f2)
  ;;   ;; 增加 list-of-alist 的深度
  ;;   ;; 失败的时候就消除 list-of-alist 中的一个 alist
  ;;   (lambda (x) (apply append (map f2 (f1 x)))))

  (define (common-3 l1 l2 l3)
    (conj
     (conj
      (choice vx l1)
      (choice vx l2))
     (choice vx l3)))
  ((common-3 '(1 2 3 4) '(2 3 4 5) '(3 4 5 6)) '())

  (cout "common-el-1" nl
        (run (common-el '(1 2 3) '(3 4 5)))
        nl)
  ;; => (((#(x) . 3)))

  (cout "common-el-2" nl
        (run (common-el '(1 2 3) '(3 4 1 7)))
        nl)
  ;; => (((#(x) . 1)) ((#(x) . 3)))
  ;; two elements are in common

  (cout "common-el-3" nl
    (run (common-el '(11 2 3) '(13 4 1 7)))
    nl)
  ;; => ()
  ;; nothing in common


  ;; Let us do something a bit more complex

  (define (conso a b l)
    (== (cons a b) l))

  ;; (conso a b l) is a goal that succeeds if in the current state
  ;; of the world, (cons a b) is the same as l.
  ;; That may, at first, sound like the meaning of cons. However, the
  ;; declarative formulation is more powerful, because a, b, or l might
  ;; be logic variables.

  ;; By running the goal which includes logic variables we are
  ;; essentially asking the question what the state of the world should
  ;; be so that (cons a b) could be the same as l.

  (cout "conso-1" nl
    (run (conso 1 '(2 3) vx))
    nl)
  ;; => (((#(x) 1 2 3))) === (((#(x) . (1 2 3))))

  (cout "conso-2" nl
    (run (conso vx vy (list 1 2 3)))
    nl)
  ;; => (((#(y) 2 3) (#(x) . 1)))
  ;; That looks now like 'cons' in reverse. The answer means that
  ;; if we replace vx with 1 and vy with (2 3), then (cons vx vy)
  ;; will be the same as '(1 2 3)

  ;; Terminology: (conso vx vy '(1 2 3)) is a goal (or, to be more precise,
  ;; an expression that evaluates to a goal). By itself, 'conso'
  ;; is a parameterized goal (or, abstraction over a goal):
  ;; conso === (lambda (x y z) (conso x y z))
  ;; We will call such an abstraction 'relation'.

  ;; Let us attempt a more complex relation: appendo
  ;; That is, (appendo l1 l2 l3) holds if the list l3 is the
  ;; concatenation of lists l1 and l2.
  ;; The first attempt:

  ;; In Haskell notation:
  ;; [] ++ l == l
  ;; (h:t) ++ l == h : (t ++ l)
  (define (apppendo l1 l2 l3)
    [disj
     ;; if l1 == '()
     [conj (== l1 '())
           (== l2 l3)]
     ;; if l1 =/= '()
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (apppendo t l2 l3p)]])])

  ;; If we run the following, we get into the infinite loop.
  ;; (cout "t1"
  ;;   (run (apppendo '(1) '(2) vq))
  ;;   nl)

  ;; It is instructive to analyze why. The reason is that
  ;; (apppendo t l2 l3p) is a function application in Scheme,
  ;; and so the (call-by-value) evaluator tries to find its value first,
  ;; before invoking (conso h t l1). But evaluating (apppendo t l2 l3p)
  ;; will again require the evaluation of (apppendo t1 l21 l3p1), etc.
  ;; So, we have to introduce eta-expansion. Now, the recursive
  ;; call to apppendo gets evaluated only when conj applies
  ;; (lambda (s) ((apppendo t l2 l3p) s)) to each result of (conso h l3p l3).
  ;; If the latter yields '() (no results), then appendo will not be
  ;; invoked. Compare that with the situation above, where appendo would
  ;; have been invoked anyway.

  (define (apppendo l1 l2 l3)
    [disj
     [conj (== l1 '())
           (== l2 l3)]
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (lambda (s)
           ;; protect-eager-rec-call
           ((apppendo t l2 l3p)
            s))]])])

  (cout "t1" nl
    (run (apppendo '(1) '(2) vq))
    nl)
  ;; => (((#(l3p) 2) (#(q) #(h) . #(l3p)) (#(t)) (#(h) . 1)))

  ;; That all appears to work, but the result is kind of ugly;
  ;; and all the eta-expansion spoils the code.

  ;; To hide the eta-expansion (that is, (lambda (s) ...) forms),
  ;; we have to introduce a bit of syntactic sugar:
  (define-syntax conj*
    (syntax-rules ()
      [(conj*) succeed]
      [(conj* g) g]
      [(conj* g gs ...)
       (conj g (lambda (s) ((conj* gs ...) s)))]))

  ;; Incidentally, for disj* we can use a regular function
  ;; (because we represent all the values yielded by a non-deterministic
  ;; function as a regular list rather than a lazy list). All branches
  ;; of disj will be evaluated anyway, in our present model.
  (define (disj* . gs)
    (if (null? gs)
      fail
      (disj (car gs)
            (apply disj* (cdr gs)))))

  ;; And so we can re-define appendo as follows. It does look
  ;; quite declarative, as the statement of two equations that
  ;; define what list concatenation is.

  (define (apppendo l1 l2 l3)
    (disj
     (conj*
      (== l1 '())
      (== l2 l3))
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       (conj*
        (conso h t l1)
        (conso h l3p l3)
        (apppendo t l2 l3p)))))


  ;; We also would like to make the result yielded by run more
  ;; pleasant to look at.
  ;; First of all, let us assume that the variable vq (if bound),
  ;; holds the answer to our inquiry. Thus, our new run will try to
  ;; find the value associated with vq in the final substitution.
  ;; However, the found value may itself contain logic variables.
  ;; We would like to replace them, too, with their associated values,
  ;; if any, so the returned value will be more informative.

  ;; We define a more diligent version of lookup, which replaces
  ;; variables with their values even if those variables occur deep
  ;; inside a term.
  (define (lookup* var s)
    (let ([v (lookup var s)])
      (cond
       [(var? v) v] ;; if lookup returned var, it is unbound
       [(pair? v)
         (cons (lookup* (car v) s)
               (lookup* (cdr v) s))]
       [else v])))

  ;; We can now redefine run as
  (define (run g)
    ;; 需要用map 是因为这已经破坏了alist的结构
    ;; 什么地方破坏了alist的结构?
    ;; 是conj 使得原来的alist变成了alist的list
    (map (lambda (s) (lookup* vq s)) (g empty-subst)))

  ;; 此时前面的某些test就通过不了
  ;; 对run的实现不正确

  ;; and we can re-run the test

  (cout "t1" nl
    (run (apppendo '(1) '(2) vq))
    nl)
  ;; => ((1 2))

  (cout "t2" nl
    (run (apppendo '(1) '(2) '(1)))
    nl)
  ;; => ()
  ;; That is, concatenation of '(1) and '(2) is not the same as '(1)

  (cout "t3" nl
    (run (apppendo '(1 2 3) vq '(1 2 3 4 5)))
    nl)
  ;; => ((4 5))


  (cout "t4" nl
    (run (apppendo vq '(4 5) '(1 2 3 4 5)))
    nl)
  ;; => ((1 2 3))

  (cout "t5" nl
    (run (apppendo vq vx '(1 2 3 4 5)))
    nl)
  ;; => (() (1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
  ;; All prefixes of '(1 2 3 4 5)


  (cout "t6" nl
    (run (apppendo vx vq '(1 2 3 4 5)))
    nl)
  ;; => ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5) ())
  ;; All suffixes of '(1 2 3 4 5)


  (cout "t7" nl
    (run (let ((x (var 'x)) (y (var 'y)))
           (conj* (apppendo x y '(1 2 3 4 5))
                  (== vq (list x y)))))
    nl)
  ;; => ((() (1 2 3 4 5)) ((1) (2 3 4 5)) ((1 2) (3 4 5))
  ;;     ((1 2 3) (4 5)) ((1 2 3 4) (5)) ((1 2 3 4 5) ()))
  ;; All the ways to split (1 2 3 4 5) into two complementary parts

  ;; For more detail, please see `The Reasoned Schemer'
  #+end_src
* guanxi
  #+begin_src scheme
  ;; knowledge == list-of-lattice
  ;; lattice == alist
  ;; goal: knowledge -> knowledge

  ;; notation: ``nlg'' denote ``knowledge''

  (define fail
    (lambda (nlg)
      '()))
  (define succeed
    (lambda (nlg)
      (map (lambda (x) x) nlg)))

  (define disj
    ;; 增加 knowledge 的宽度
    ;; 失败的时候就不增加 knowledge 的宽度
    (lambda (g1 g2)
      (lambda (nlg) (append (g1 nlg) (g2 nlg)))))
  (define conj
    ;; 增加 knowledge 的深度
    ;; 失败的时候就消除 knowledge 中的一个 lattice
    (lambda (g1 g2)
      (lambda (nlg)
        (let ([x (g1 nlg)])
          (if (null? x)
            '()
            (g2 x))))))


  (define (var name) (vector name))
  (define var? vector?)

  (define empty-lattice '())
  (define ext-lattice
    (lambda (var term lattice)
      (cons (cons var term) lattice)))

  (define lookup
    (lambda (var lattice)
      (cond
       [(not (var? var)) var]
       [(assq var lattice) => (lambda (b) (lookup (cdr b) lattice))]
       [else var])))

  (define (unify t1 t2 lattice)
    (let ([t1 (lookup t1 lattice)]
          [t2 (lookup t2 lattice)])
      (cond
       [(eq? t1 t2) lattice]
       [(var? t1)
        (ext-lattice t1 t2 lattice)]
       [(var? t2)
        (ext-lattice t2 t1 lattice)]
       [(and (pair? t1) (pair? t2))
        (let ((lattice (unify (car t1) (car t2) lattice)))
          (and lattice (unify (cdr t1) (cdr t2) lattice)))]
       [(equal? t1 t2) lattice]
       [else #f])))

  ;; == : term x term -> (nlg -> nlg)
  (define ==
    (lambda (t1 t2)
      (lambda (nlg)
        (cond
         [(null? nlg)
          (let ([lattice-or-fail-to-unify (unify t1 t2 '())])
            (if lattice-or-fail-to-unify
              (list lattice-or-fail-to-unify)
              '()))]
         [else
          (apply append
            (map (lambda (lattice-or-fail-to-unify)
                   (if lattice-or-fail-to-unify
                     (list lattice-or-fail-to-unify)
                     '()))
                 (map (lambda (lattice) (unify t1 t2 lattice)) nlg)))]))))

  (define (run g) (g '()))

  ((== 1 2) '())

  ((== (var 'b) 1)
   ((== (var 'c) 1)
    ((== (var 'a) 1) '())))

  ((== (var 'b) 1)
   ((== (var 'c) 1)
    ((== 1 2)
     ((== (var 'a) 1) '()))))

  (define choice
    ;; The name `choice' should evoke THE AXIOM OF CHOICE
    (lambda (var lst)
      (if (null? lst)
        fail
        (disj
         (== var (car lst))
         (choice var (cdr lst))))))

  (run (choice 2 '(1 2 3)))
  ;; => (()) success

  (run (choice 10 '(1 2 3)))
  ;; => ()
  ;; empty list of outcomes: 10 is not a member of '(1 2 3)

  (run (choice (var 'x) '(1 2 3)))
  ;; => (((#(x) . 1)) ((#(x) . 2)) ((#(x) . 3)))
  ;; three outcomes



  ;; Now we can write a very primitive program: find an element that is
  ;; common in two lists:



  (define (common-2 l1 l2)
    (let ([vx (var 'x)])
     (conj
      (choice vx l1)
      (choice vx l2))))

  (define (common-3 l1 l2 l3)
    (let ([vx (var 'x)])
      (conj
       (conj
        (choice vx l1)
        (choice vx l2))
       (choice vx l3))))

  (run (common-3 '(1 2 3 4) '(2 3 4 5) '(3 4 5 6)))
  ;; => (((#(x) . 3)) ((#(x) . 4)))

  (run (common-2 '(1 2 3) '(3 4 5)))
  ;; => (((#(x) . 3)))

  (run (common-2 '(1 2 3) '(3 4 1 7)))
  ;; => (((#(x) . 1)) ((#(x) . 3)))
  ;; two elements are in common

  (run (common-2 '(11 2 3) '(13 4 1 7)))
  ;; => ()
  ;; nothing in common


  ;; Let us do something a bit more complex

  (define (conso a b l)
    (== (cons a b) l))

  (run (conso 1 '(2 3) (var 'x)))
  ;; => (((#(x) 1 2 3))) === (((#(x) . (1 2 3))))

  (run (conso (var 'x) (var 'y) (list 1 2 3)))
  ;; => (((#(y) 2 3) (#(x) . 1)))
  ;; observing that 'cons' in reverse

  ;; Terminology: (conso vx vy '(1 2 3)) is a goal (or, to be more precise,
  ;; an expression that evaluates to a goal). By itself, 'conso'
  ;; is a parameterized goal (or, abstraction over a goal):
  ;; conso === (lambda (x y z) (conso x y z))
  ;; We will call such an abstraction 'relation'.
  ;; relation : thing1 x thing2 x ... -> goal

  ;; Let us attempt a more complex relation: appendo
  ;; That is, (appendo l1 l2 l3) holds if the list l3 is the
  ;; concatenation of lists l1 and l2.
  ;; The first attempt:

  ;; In Haskell notation:
  ;; [] ++ l == l
  ;; (h:t) ++ l == h : (t ++ l)
  (define (apppendo l1 l2 l3)
    [disj
     ;; if l1 == '()
     [conj (== l1 '())
           (== l2 l3)]
     ;; if l1 =/= '()
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (apppendo t l2 l3p)]])])

  ;; If we run the following, we get into the infinite loop.
  ;; (run (apppendo '(1) '(2) vq))

  ;; It is instructive to analyze why. The reason is that
  ;; (apppendo t l2 l3p) is a function application in Scheme,
  ;; and so the (call-by-value) evaluator tries to find its value first,
  ;; before invoking (conso h t l1). But evaluating (apppendo t l2 l3p)
  ;; will again require the evaluation of (apppendo t1 l21 l3p1), etc.
  ;; So, we have to introduce eta-expansion. Now, the recursive
  ;; call to apppendo gets evaluated only when conj applies
  ;; (lambda (s) ((apppendo t l2 l3p) s)) to each result of (conso h l3p l3).
  ;; If the latter yields '() (no results), then appendo will not be
  ;; invoked. Compare that with the situation above, where appendo would
  ;; have been invoked anyway.

  (define (apppendo l1 l2 l3)
    [disj
     [conj (== l1 '())
           (== l2 l3)]
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (lambda (s)
           ;; protect-eager-rec-call
           ((apppendo t l2 l3p)
            s))]])])

  (run (apppendo '(1) '(2) (var 'q)))
  ;; => (((#(l3p) 2) (#(q) #(h) . #(l3p)) (#(t)) (#(h) . 1)))

  ;; That all appears to work, but the result is kind of ugly;
  ;; and all the eta-expansion spoils the code.

  ;; To hide the eta-expansion (that is, (lambda (s) ...) forms),
  ;; we have to introduce a bit of syntactic sugar:
  (define-syntax conj*
    (syntax-rules ()
      [(conj*) succeed]
      [(conj* g) g]
      [(conj* g1 g2 ...)
       (conj g1 (lambda (s) ((conj* g2 ...) s)))]))

  ;; Incidentally, for disj* we can use a regular function
  ;; (because we represent all the values yielded by a non-deterministic
  ;; function as a regular list rather than a lazy list). All branches
  ;; of disj will be evaluated anyway, in our present model.
  (define (disj* . gs)
    (if (null? gs)
      fail
      (disj (car gs)
            (apply disj* (cdr gs)))))
  ;; (define-syntax disj*
  ;;   (syntax-rules ()
  ;;     [(disj*) fail]
  ;;     [(disj* g) g]
  ;;     [(disj* g1 g2 ...)
  ;;      (disj g1 (disj* g2 ...))]))

  ;; And so we can re-define appendo as follows. It does look
  ;; quite declarative, as the statement of two equations that
  ;; define what list concatenation is.

  (define (apppendo l1 l2 l3)
    (disj
     (conj*
      (== l1 '())
      (== l2 l3))
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       (conj*
        (conso h t l1)
        (conso h l3p l3)
        (apppendo t l2 l3p)))))

  (define-syntax begin°
    (syntax-rules ()
      [(_ [g11 g12 ...]
          [g21 g22 ...]
          ...)
       (disj*
        (conj* g11 g12 ...)
        (conj* g21 g22 ...)
        ...)]))

  (define (apppendo l1 l2 l3)
    (begin°
     [(== l1 '()) (== l2 l3)]
     [(let ([h (var 'h)]
            [t (var 't)]
            [l3p (var 'l3p)])
        (conj*
         (conso h t l1)
         (conso h l3p l3)
         (apppendo t l2 l3p)))]
     ))

  ;; We also would like to make the result yielded by run more
  ;; pleasant to look at.
  ;; First of all, let us assume that the variable vq (if bound),
  ;; holds the answer to our inquiry. Thus, our new run will try to
  ;; find the value associated with vq in the final substitution.
  ;; However, the found value may itself contain logic variables.
  ;; We would like to replace them, too, with their associated values,
  ;; if any, so the returned value will be more informative.

  ;; We define a more diligent version of lookup, which replaces
  ;; variables with their values even if those variables occur deep
  ;; inside a term.
  (define (lookup* var s)
    (let ([v (lookup var s)])
      (cond
       [(var? v) v] ;; if lookup returned var, it is unbound
       [(pair? v)
         (cons (lookup* (car v) s)
               (lookup* (cdr v) s))]
       [else v])))

  ;; We can now redefine run as
  (define vq (var 'q))
  (define (run-with-vq g)
    ;; 需要用map 是因为这已经破坏了alist的结构
    ;; 什么地方破坏了alist的结构?
    ;; 是conj 使得原来的alist变成了alist的list
    (map (lambda (s) (lookup* vq s)) (g empty-lattice)))


  ;; and we can re-run the test

  (run-with-vq (apppendo '(1) '(2) vq))
  ;; => ((1 2))

  (run-with-vq (apppendo '(1) '(2) '(1)))
  ;; => ()
  ;; That is, concatenation of '(1) and '(2) is not the same as '(1)

  (run-with-vq (apppendo '(1 2 3) vq '(1 2 3 4 5)))
  ;; => ((4 5))


  (run-with-vq (apppendo vq '(4 5) '(1 2 3 4 5)))
  ;; => ((1 2 3))

  (run-with-vq (apppendo vq (var 'x) '(1 2 3 4 5)))
  ;; => (() (1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
  ;; All prefixes of '(1 2 3 4 5)


  (run-with-vq (apppendo (var 'x) vq '(1 2 3 4 5)))
  ;; => ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5) ())
  ;; All suffixes of '(1 2 3 4 5)


  (run-with-vq (let ([x (var 'x)]
                     [y (var 'y)])
                 (conj* (apppendo x y '(1 2 3 4 5))
                        (== vq (list x y)))))
  ;; => ((() (1 2 3 4 5)) ((1) (2 3 4 5)) ((1 2) (3 4 5))
  ;;     ((1 2 3) (4 5)) ((1 2 3 4) (5)) ((1 2 3 4 5) ()))
  ;; All the ways to split (1 2 3 4 5) into two complementary parts

  ;; For more detail, please see `The Reasoned Schemer'
  #+end_src
* guanxi-lazy
  in order to be lazy we need to use:
  ~+~, ~map of lazy-list.scm
  and need to modify:
  ==, disy , ...

  knowledge == lazy-linear-list-of-lattices
  so (~? knowledge) ==> #t

  lattice == alist (which is not lazy)
  goal: knowledge -> knowledge
  #+begin_src scheme
  (define knowledge? ~?)
  (define empty-knowledge empty~)
  (define empty-knowledge? empty~?)

  (define fail (lambda (knowledge) empty-knowledge))
  (define succeed (lambda (knowledge) knowledge))

  (define disj
    ;; 增加 knowledge 的宽度
    ;; 失败的时候就不增加 knowledge 的宽度
    (lambda (g1 g2)
      (lambda (knowledge)
        (~+~ (g1 knowledge) (g2 knowledge)))))

  (define conj
    ;; 增加 knowledge 的深度
    ;; 失败的时候就消除 knowledge 中的一个 lattice
    (lambda (g1 g2)
      (lambda (knowledge)
        (let ([g1:knowledge (g1 knowledge)])
          (if (empty-knowledge? g1:knowledge)
            empty-knowledge
            (g2 g1:knowledge))))))


  (define var
    (lambda (name)
      (if (symbol? name)
        (vector name)
        (error 'var:mk "1st-arg must be symbol" name))))

  (define var?
    (lambda (x)
      (and (vector? x)
           (= 1 (vector-length x))
           (symbol? (vector-ref x 0)))))

  (define empty-lattice '())
  (define ext-lattice
    (lambda (var term lattice)
      (cons (cons var term) lattice)))

  (define lookup
    (lambda (var lattice)
      (cond
       [(not (var? var)) var]
       [(assq var lattice) => (lambda (b) (lookup (cdr b) lattice))]
       [else var])))

  (define unify
    (lambda (t1 t2 lattice)
      (let ([t1 (lookup t1 lattice)]
            [t2 (lookup t2 lattice)])
        (cond
         [(eq? t1 t2) lattice]
         [(var? t1)
          (ext-lattice t1 t2 lattice)]
         [(var? t2)
          (ext-lattice t2 t1 lattice)]
         [(and (pair? t1) (pair? t2))
          (let ([lattice (unify (car t1) (car t2) lattice)])
            (and lattice (unify (cdr t1) (cdr t2) lattice)))]
         [(equal? t1 t2) lattice]
         [else '<fail-to-unify>]))))

  ;; == : term x term -> (knowledge -> knowledge)
  (define ==
    (lambda (t1 t2)
      (lambda (knowledge)
        (if (~? knowledge)
          (if (empty-knowledge? knowledge)
            (~xlis (unify t1 t2  '()))
            (~map (lambda (lattice) (unify t1 t2 lattice)) knowledge
              ;; 上一次的<fail-to-unify>只会在下一次的复合作用中被剔除
              ;; 因此knowledge中总会有一些<fail-to-unify>
              ;; 即lattice可能是<fail-to-unify>
              [(lambda (u) (not (eq? u '<fail-to-unify>)))]))
          (error 'a-goal "the arg of a goal must be a ``knowledge''")))))


  (define-syntax conj*
    (syntax-rules ()
      [(conj*) succeed]
      [(conj* g) g]
      [(conj* g1 g2 ...)
       (conj g1 (lambda (s) ((conj* g2 ...) s)))]))

  ;; (define (disj* . gs)
  ;;   (if (null? gs)
  ;;     fail
  ;;     (disj (car gs)
  ;;           (apply disj* (cdr gs)))))
  (define-syntax disj*
    (syntax-rules ()
      [(disj*) fail]
      [(disj* g) g]
      [(disj* g1 g2 ...)
       (disj g1 (disj* g2 ...))]))

  (define-syntax begin°
    (syntax-rules ()
      [(_ [g11 g12 ...]
          [g21 g22 ...]
          ...)
       (disj*
        (conj* g11 g12 ...)
        (conj* g21 g22 ...)
        ...)]))

  ;; (define (lookup* var s)
  ;;   (let ([v (lookup var s)])
  ;;     (cond
  ;;      [(var? v) v] ;; if lookup returned var, it is unbound
  ;;      [(pair? v)
  ;;       (cons (lookup* (car v) s)
  ;;             (lookup* (cdr v) s))]
  ;;      [else v])))


  (define run
    (lambda (g)
      (take~ 100
        (g empty-knowledge))))












  ;; --------------------------------------------
  ;; 下面是三种空知识
  ;; 这样对吗?
  (run (conj
        (== 1 1)
        (== 1 1)))
  ;; ==> (())
  (run (conj
        (== 1 2)
        (== 1 1)))
  ;; ==> ()
  (run (== 1 2))
  ;; ==> (<fail-to-unify>)

  (run (== (var 'a) 1))
  (run (conj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== (var 'a) 1)))
  (run (conj
        (== (var 'b) 1)
        (== (var 'a) 1)))
  (run (conj
        (== 1 2)
        (== (var 'a) 1)))
  (run (conj
        (== (var 'a) 1)
        (== 1 1)))
  (run (conj
        (== 1 2)
        (== (var 'a) 1)))
  (run (disj
        (== (var 'c) 1)
        (== (var 'b) 1)))
  (run (conj
        (disj (== (var 'c) 1)
              (== (var 'b) 1))
        (== (var 'a) 1)))
  "bug-start"
  ------------------------------------------------------------
  (run (conj
        (== (var 'a) 1)
        (disj
         (== (var 'c) 1)
         (== (var 'b) 1))))

  there will be loop if i accept this to be ~
  #0=#(~
          [(#<procedure [char 305 of /home/xyh/scheme-toys/lazy-linear-list.scm]>)
           (#<procedure> #<procedure>)
           (#<procedure> #<procedure>)
           . #1=((#<procedure [char 2086 of /home/xyh/scheme-toys/lazy-linear-list.scm]>)
                 . #1#)]
        [(#<procedure>
          (#<procedure [char 305 of /home/xyh/scheme-toys/lazy-linear-list.scm]>)
          (#<procedure> #<procedure>)
          (#<procedure> #<procedure>) . #1#)]
        [#0#])
  -------------------------------------------------------------
  "bug-end"
  (run (conj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== 1 2)
        (== (var 'a) 1)
        ))
  (run (conj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== 1 1)
        (== (var 'a) 1)))
  (run (disj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== (var 'a) 1)))
  (run (disj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== 1 2)
        (== (var 'a) 1)))
  (run (disj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (== 1 1)
        (== (var 'a) 1)))
  "bug-start"
  --------------------------------------------
  (run (conj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (disj*
         (== (var 'c) 1)
         (== (var 'b) 1)
         (== 1 2)
         (== (var 'a) 1))))

  (run (conj*
        (== (var 'c) 1)
        (== (var 'b) 1)
        (disj*
         (== (var 'c) 1)
         (== (var 'b) 1)
         (== 1 1)
         (== (var 'a) 1))))
  ---------------------------------------------
  "bug-end"
  (define choice
    ;; The name `choice' should evoke THE AXIOM OF CHOICE
    (lambda (var lst)
      (if (null? lst)
        fail
        (disj
         (== var (car lst))
         (choice var (cdr lst))))))

  (define vx (var 'x))
  (run (disj*
        (== vx 1)
        (== vx 2)
        (== vx 3)
        fail))



  "test-here"
  ==================================================
  (run
      (== vx 3))
  (run
      (disj
       (== vx 1)
       (disj
        (== vx 3)
        (disj
         (== vx 4)
         fail))))

  (take~ 10 ((== vx 3)
             ((disj
               (== vx 3)
               (disj
                (== vx 4)
                fail)) empty-knowledge)))
  (run
      (lambda (k)
        ((== vx 3)
         ((disj
           (== vx 3)
           (disj
            (== vx 4)
            fail)) k))))
  (take~ 10 ((disj
              (== vx 3)
              (disj
               (== vx 4)
               fail)) empty-knowledge))

  "bug-start"
  ----------------------------------------------
  (take~ 30
    ((choice vx '(3 4))
     ((choice vx '(1 2)) empty-knowledge)))
  (take~ 30
         ((choice vx '(1 2))
          ((choice vx '(3 4)) '())))

  (run (choice 2 '(1 2 3)))
  ;; => (()) success

  (run (choice 10 '(1 2 3)))
  ;; => ()
  ;; empty list of outcomes: 10 is not a member of '(1 2 3)

  (run (choice (var 'x) '(1 2 3)))
  ;; => (((#(x) . 1)) ((#(x) . 2)) ((#(x) . 3)))
  ;; three outcomes


  ;; Now we can write a very primitive program: find an element that is
  ;; common in two lists:

  (define (common-2 l1 l2)
    (let ([vx (var 'x)])
     (conj
      (choice vx l1)
      (choice vx l2))))

  (define (common-3 l1 l2 l3)
    (let ([vx (var 'x)])
      (conj
       (conj
        (choice vx l1)
        (choice vx l2))
       (choice vx l3))))

  (run (common-3 '(1 2 3 4) '(2 3 4 5) '(3 4 5 6)))
  ;; => (((#(x) . 3)) ((#(x) . 4)))

  (run (common-2 '(1 2 3) '(3 4 5)))
  (define vx (var 'x))
  (take~ 30
         ((choice vx '(3 4 5))
          ((choice vx '(1 2 3)) '())))
  (take~ 30 ((choice vx '(1 2 3)) '()))

  (take~ 10 ((choice vx '(3 4 5)) '()))
  (take~ 10 ((choice vx '(1 2 3)) '()))

  ;; => (((#(x) . 3)))

  (run (common-2 '(1 2 3) '(3 4 1 7)))
  ;; => (((#(x) . 1)) ((#(x) . 3)))
  ;; two elements are in common

  (run (common-2 '(11 2 3) '(13 4 1 7)))
  ;; => ()
  ;; nothing in common


  ;; Let us do something a bit more complex

  (define (conso a b l)
    (== (cons a b) l))

  (run (conso 1 '(2 3) (var 'x)))
  ;; => (((#(x) 1 2 3))) === (((#(x) . (1 2 3))))

  (run (conso (var 'x) (var 'y) (list 1 2 3)))
  ;; => (((#(y) 2 3) (#(x) . 1)))
  ;; observing that 'cons' in reverse

  ;; Terminology: (conso vx vy '(1 2 3)) is a goal (or, to be more precise,
  ;; an expression that evaluates to a goal). By itself, 'conso'
  ;; is a parameterized goal (or, abstraction over a goal):
  ;; conso === (lambda (x y z) (conso x y z))
  ;; We will call such an abstraction 'relation'.
  ;; relation : thing1 x thing2 x ... -> goal

  ;; Let us attempt a more complex relation: appendo
  ;; That is, (appendo l1 l2 l3) holds if the list l3 is the
  ;; concatenation of lists l1 and l2.
  ;; The first attempt:

  ;; In Haskell notation:
  ;; [] ++ l == l
  ;; (h:t) ++ l == h : (t ++ l)
  (define (apppendo l1 l2 l3)
    [disj
     ;; if l1 == '()
     [conj (== l1 '())
           (== l2 l3)]
     ;; if l1 =/= '()
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (apppendo t l2 l3p)]])])

  ;; If we run the following, we get into the infinite loop.
  ;; (run (apppendo '(1) '(2) vq))

  ;; It is instructive to analyze why. The reason is that
  ;; (apppendo t l2 l3p) is a function application in Scheme,
  ;; and so the (call-by-value) evaluator tries to find its value first,
  ;; before invoking (conso h t l1). But evaluating (apppendo t l2 l3p)
  ;; will again require the evaluation of (apppendo t1 l21 l3p1), etc.
  ;; So, we have to introduce eta-expansion. Now, the recursive
  ;; call to apppendo gets evaluated only when conj applies
  ;; (lambda (s) ((apppendo t l2 l3p) s)) to each result of (conso h l3p l3).
  ;; If the latter yields '() (no results), then appendo will not be
  ;; invoked. Compare that with the situation above, where appendo would
  ;; have been invoked anyway.

  (define (apppendo l1 l2 l3)
    [disj
     [conj (== l1 '())
           (== l2 l3)]
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       [conj
        (conso h t l1)
        [conj
         (conso h l3p l3)
         (lambda (s)
           ;; protect-eager-rec-call
           ((apppendo t l2 l3p)
            s))]])])

  (run (apppendo '(1) '(2) (var 'q)))
  ;; => (((#(l3p) 2) (#(q) #(h) . #(l3p)) (#(t)) (#(h) . 1)))

  ;; That all appears to work, but the result is kind of ugly;
  ;; and all the eta-expansion spoils the code.

  ;; To hide the eta-expansion (that is, (lambda (s) ...) forms),
  ;; we have to introduce a bit of syntactic sugar:


  (define (apppendo l1 l2 l3)
    (disj
     (conj*
      (== l1 '())
      (== l2 l3))
     (let ([h (var 'h)]
           [t (var 't)]
           [l3p (var 'l3p)])
       (conj*
        (conso h t l1)
        (conso h l3p l3)
        (apppendo t l2 l3p)))))

  (define-syntax begin°
    (syntax-rules ()
      [(_ [g11 g12 ...]
          [g21 g22 ...]
          ...)
       (disj*
        (conj* g11 g12 ...)
        (conj* g21 g22 ...)
        ...)]))

  (define (apppendo l1 l2 l3)
    (begin°
     [(== l1 '()) (== l2 l3)]
     [(let ([h (var 'h)]
            [t (var 't)]
            [l3p (var 'l3p)])
        (conj*
         (conso h t l1)
         (conso h l3p l3)
         (apppendo t l2 l3p)))]
     ))

  ;; We also would like to make the result yielded by run more
  ;; pleasant to look at.
  ;; First of all, let us assume that the variable vq (if bound),
  ;; holds the answer to our inquiry. Thus, our new run will try to
  ;; find the value associated with vq in the final substitution.
  ;; However, the found value may itself contain logic variables.
  ;; We would like to replace them, too, with their associated values,
  ;; if any, so the returned value will be more informative.

  ;; We define a more diligent version of lookup, which replaces
  ;; variables with their values even if those variables occur deep
  ;; inside a term.
  (define (lookup* var s)
    (let ([v (lookup var s)])
      (cond
       [(var? v) v] ;; if lookup returned var, it is unbound
       [(pair? v)
         (cons (lookup* (car v) s)
               (lookup* (cdr v) s))]
       [else v])))

  ;; We can now redefine run as
  (define vq (var 'q))
  (define (run-with-vq g)
    ;; 需要用map 是因为这已经破坏了alist的结构
    ;; 什么地方破坏了alist的结构?
    ;; 是conj 使得原来的alist变成了alist的list
    (map (lambda (s) (lookup* vq s)) (g empty-lattice)))


  ;; and we can re-run the test

  (run-with-vq (apppendo '(1) '(2) vq))
  ;; => ((1 2))

  (run-with-vq (apppendo '(1) '(2) '(1)))
  ;; => ()
  ;; That is, concatenation of '(1) and '(2) is not the same as '(1)

  (run-with-vq (apppendo '(1 2 3) vq '(1 2 3 4 5)))
  ;; => ((4 5))


  (run-with-vq (apppendo vq '(4 5) '(1 2 3 4 5)))
  ;; => ((1 2 3))

  (run-with-vq (apppendo vq (var 'x) '(1 2 3 4 5)))
  ;; => (() (1) (1 2) (1 2 3) (1 2 3 4) (1 2 3 4 5))
  ;; All prefixes of '(1 2 3 4 5)


  (run-with-vq (apppendo (var 'x) vq '(1 2 3 4 5)))
  ;; => ((1 2 3 4 5) (2 3 4 5) (3 4 5) (4 5) (5) ())
  ;; All suffixes of '(1 2 3 4 5)


  (run-with-vq (let ([x (var 'x)]
                     [y (var 'y)])
                 (conj* (apppendo x y '(1 2 3 4 5))
                        (== vq (list x y)))))
  ;; => ((() (1 2 3 4 5)) ((1) (2 3 4 5)) ((1 2) (3 4 5))
  ;;     ((1 2 3) (4 5)) ((1 2 3 4) (5)) ((1 2 3 4 5) ()))
  ;; All the ways to split (1 2 3 4 5) into two complementary parts

  ;; For more detail, please see `The Reasoned Schemer'
  #+end_src
* simple-miniKanren
  == fresh conde

  a good starting point for exploratory hacking

  this is essentially a modernized, cleaned up version of the
  implementation in the reasoned schemer
*** mk
    #+begin_src scheme :result value :session *scheme* :scheme
    (define-syntax lambdag@
      (syntax-rules ()
        [(_ (p) e)
         (lambda (p) e)]))

    (define-syntax lambdaf@
      (syntax-rules ()
        [(_ () e)
         (lambda () e)]))

    (define-syntax run*
      (syntax-rules ()
        [(_ (x) g ...)
         (run #f (x) g ...)]))

    (define-syntax rhs
      (syntax-rules ()
        [(_ x) (cdr x)]))

    (define-syntax lhs
      (syntax-rules ()
        [(_ x) (car x)]))

    (define-syntax size-s
      (syntax-rules ()
        [(_ x) (length x)]))

    (define-syntax var
      (syntax-rules ()
        [(_ x) (vector x)]))

    (define-syntax var?
      (syntax-rules ()
        [(_ x) (vector? x)]))

    (define empty-s '())

    (define walk
      (lambda (u S)
        (cond
         ((and (var? u) (assq u S)) =>
          (lambda (pr) (walk (rhs pr) S)))
         (else u))))

    (define ext-s
      (lambda (x v s)
        (cons `(,x . ,v) s)))

    (define unify
      (lambda (u v s)
        (let ((u (walk u s))
              (v (walk v s)))
          (cond
            ((eq? u v) s)
            ((var? u) (ext-s-check u v s))
            ((var? v) (ext-s-check v u s))
            ((and (pair? u) (pair? v))
             (let ((s (unify
                        (car u) (car v) s)))
               (and s (unify
                        (cdr u) (cdr v) s))))
            ((equal? u v) s)
            (else #f)))))

    (define ext-s-check
      (lambda (x v s)
        (cond
          ((occurs-check x v s) #f)
          (else (ext-s x v s)))))

    (define occurs-check
      (lambda (x v s)
        (let ((v (walk v s)))
          (cond
            ((var? v) (eq? v x))
            ((pair? v)
             (or
               (occurs-check x (car v) s)
               (occurs-check x (cdr v) s)))
            (else #f)))))

    (define walk*
      (lambda (w s)
        (let ((v (walk w s)))
          (cond
            ((var? v) v)
            ((pair? v)
             (cons
               (walk* (car v) s)
               (walk* (cdr v) s)))
            (else v)))))

    (define reify-s
      (lambda (v s)
        (let ((v (walk v s)))
          (cond
            ((var? v)
             (ext-s v (reify-name (size-s s)) s))
            ((pair? v) (reify-s (cdr v)
                         (reify-s (car v) s)))
            (else s)))))

    (define reify-name
      (lambda (n)
        (string->symbol
          (string-append "_" "." (number->string n)))))

    (define reify
      (lambda (v s)
        (let ((v (walk* v s)))
          (walk* v (reify-s v empty-s)))))

    (define-syntax mzero
      (syntax-rules () ((_) #f)))

    (define-syntax inc
      (syntax-rules () ((_ e) (lambdaf@ () e))))

    (define-syntax unit
      (syntax-rules () ((_ a) a)))

    (define-syntax choice
      (syntax-rules () ((_ a f) (cons a f))))

    (define-syntax case-inf
      (syntax-rules ()
        ((_ e (() e0) ((f^) e1) ((a^) e2) ((a f) e3))
         (let ((a-inf e))
           (cond
             ((not a-inf) e0)
             ((procedure? a-inf)  (let ((f^ a-inf)) e1))
             ((not (and (pair? a-inf)
                        (procedure? (cdr a-inf))))
              (let ((a^ a-inf)) e2))
             (else (let ((a (car a-inf)) (f (cdr a-inf)))
                     e3)))))))

    (define-syntax run
      (syntax-rules ()
        ((_ n (x) g0 g ...)
         (take n
           (lambdaf@ ()
             ((fresh (x) g0 g ...
                (lambdag@ (s)
                  (cons (reify x s) '())))
              empty-s))))))

    (define take
      (lambda (n f)
        (if (and n (zero? n))
          '()
          (case-inf (f)
            (() '())
            ((f) (take n f))
            ((a) a)
            ((a f)
             (cons (car a)
               (take (and n (- n 1)) f)))))))

    (define ==
      (lambda (u v)
        (lambdag@ (s)
          (unify u v s))))

    (define-syntax fresh
      (syntax-rules ()
        ((_ (x ...) g0 g ...)
         (lambdag@ (s)
           (inc
             (let ((x (var 'x)) ...)
               (bind* (g0 s) g ...)))))))

    (define-syntax bind*
      (syntax-rules ()
        ((_ e) e)
        ((_ e g0 g ...) (bind* (bind e g0) g ...))))

    (define bind
      (lambda (a-inf g)
        (case-inf a-inf
          (() (mzero))
          ((f) (inc (bind (f) g)))
          ((a) (g a))
          ((a f) (mplus (g a) (lambdaf@ () (bind (f) g)))))))

    (define-syntax conde
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (s)
           (inc
             (mplus*
               (bind* (g0 s) g ...)
               (bind* (g1 s) g^ ...) ...))))))

    (define-syntax mplus*
      (syntax-rules ()
        ((_ e) e)
        ((_ e0 e ...) (mplus e0
                        (lambdaf@ () (mplus* e ...))))))

    (define mplus
      (lambda (a-inf f)
        (case-inf a-inf
          (() (f))
          ((f^) (inc (mplus (f) f^)))
          ((a) (choice a f))
          ((a f^) (choice a (lambdaf@ () (mplus (f) f^)))))))

    (define-syntax conda
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (s)
           (inc
             (ifa ((g0 s) g ...)
                  ((g1 s) g^ ...) ...))))))

    (define-syntax ifa
      (syntax-rules ()
        ((_) (mzero))
        ((_ (e g ...) b ...)
         (let loop ((a-inf e))
           (case-inf a-inf
             (() (ifa b ...))
             ((f) (inc (loop (f))))
             ((a) (bind* a-inf g ...))
             ((a f) (bind* a-inf g ...)))))))

    (define-syntax condu
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (s)
           (inc
             (ifu ((g0 s) g ...)
                  ((g1 s) g^ ...) ...))))))

    (define-syntax ifu
      (syntax-rules ()
        ((_) (mzero))
        ((_ (e g ...) b ...)
         (let loop ((a-inf e))
           (case-inf a-inf
             (() (ifu b ...))
             ((f) (inc (loop (f))))
             ((a) (bind* a-inf g ...))
             ((a f) (bind* (unit a) g ...)))))))

    (define-syntax project
      (syntax-rules ()
        ((_ (x ...) g g* ...)
         (lambdag@ (s)
           (let ((x (walk* x s)) ...)
             ((fresh () g g* ...) s))))))

    (define succeed (== #f #f))

    (define fail (== #f #t))

    (define onceo
      (lambda (g)
        (condu
          (g succeed)
          ((== #f #f) fail))))
    #+end_src
*** mkdefs
    #+begin_src scheme
    ;; (load "mk.scm")

    (define-syntax run1 (syntax-rules () ((_ (x) g0 g ...) (run 1 (x) g0 g ...))))
    (define-syntax run2 (syntax-rules () ((_ (x) g0 g ...) (run 2 (x) g0 g ...))))
    (define-syntax run3 (syntax-rules () ((_ (x) g0 g ...) (run 3 (x) g0 g ...))))
    (define-syntax run4 (syntax-rules () ((_ (x) g0 g ...) (run 4 (x) g0 g ...))))
    (define-syntax run5 (syntax-rules () ((_ (x) g0 g ...) (run 5 (x) g0 g ...))))
    (define-syntax run6 (syntax-rules () ((_ (x) g0 g ...) (run 6 (x) g0 g ...))))
    (define-syntax run7 (syntax-rules () ((_ (x) g0 g ...) (run 7 (x) g0 g ...))))
    (define-syntax run8 (syntax-rules () ((_ (x) g0 g ...) (run 8 (x) g0 g ...))))
    (define-syntax run9 (syntax-rules () ((_ (x) g0 g ...) (run 9 (x) g0 g ...))))
    (define-syntax run10 (syntax-rules () ((_ (x) g0 g ...) (run 10 (x) g0 g ...))))

    (define-syntax run11 (syntax-rules () ((_ (x) g0 g ...) (run 11 (x) g0 g ...))))
    (define-syntax run12 (syntax-rules () ((_ (x) g0 g ...) (run 12 (x) g0 g ...))))
    (define-syntax run13 (syntax-rules () ((_ (x) g0 g ...) (run 13 (x) g0 g ...))))
    (define-syntax run14 (syntax-rules () ((_ (x) g0 g ...) (run 14 (x) g0 g ...))))
    (define-syntax run15 (syntax-rules () ((_ (x) g0 g ...) (run 15 (x) g0 g ...))))
    (define-syntax run16 (syntax-rules () ((_ (x) g0 g ...) (run 16 (x) g0 g ...))))
    (define-syntax run17 (syntax-rules () ((_ (x) g0 g ...) (run 17 (x) g0 g ...))))
    (define-syntax run18 (syntax-rules () ((_ (x) g0 g ...) (run 18 (x) g0 g ...))))
    (define-syntax run19 (syntax-rules () ((_ (x) g0 g ...) (run 19 (x) g0 g ...))))
    (define-syntax run20 (syntax-rules () ((_ (x) g0 g ...) (run 20 (x) g0 g ...))))

    (define-syntax run21 (syntax-rules () ((_ (x) g0 g ...) (run 21 (x) g0 g ...))))
    (define-syntax run22 (syntax-rules () ((_ (x) g0 g ...) (run 22 (x) g0 g ...))))
    (define-syntax run23 (syntax-rules () ((_ (x) g0 g ...) (run 23 (x) g0 g ...))))
    (define-syntax run24 (syntax-rules () ((_ (x) g0 g ...) (run 24 (x) g0 g ...))))
    (define-syntax run25 (syntax-rules () ((_ (x) g0 g ...) (run 25 (x) g0 g ...))))
    (define-syntax run26 (syntax-rules () ((_ (x) g0 g ...) (run 26 (x) g0 g ...))))
    (define-syntax run27 (syntax-rules () ((_ (x) g0 g ...) (run 27 (x) g0 g ...))))
    (define-syntax run28 (syntax-rules () ((_ (x) g0 g ...) (run 28 (x) g0 g ...))))
    (define-syntax run29 (syntax-rules () ((_ (x) g0 g ...) (run 29 (x) g0 g ...))))
    (define-syntax run30 (syntax-rules () ((_ (x) g0 g ...) (run 30 (x) g0 g ...))))

    (define-syntax run31 (syntax-rules () ((_ (x) g0 g ...) (run 31 (x) g0 g ...))))
    (define-syntax run32 (syntax-rules () ((_ (x) g0 g ...) (run 32 (x) g0 g ...))))
    (define-syntax run33 (syntax-rules () ((_ (x) g0 g ...) (run 33 (x) g0 g ...))))
    (define-syntax run34 (syntax-rules () ((_ (x) g0 g ...) (run 34 (x) g0 g ...))))
    (define-syntax run35 (syntax-rules () ((_ (x) g0 g ...) (run 35 (x) g0 g ...))))
    (define-syntax run36 (syntax-rules () ((_ (x) g0 g ...) (run 36 (x) g0 g ...))))
    (define-syntax run37 (syntax-rules () ((_ (x) g0 g ...) (run 37 (x) g0 g ...))))
    (define-syntax run38 (syntax-rules () ((_ (x) g0 g ...) (run 38 (x) g0 g ...))))
    (define-syntax run39 (syntax-rules () ((_ (x) g0 g ...) (run 39 (x) g0 g ...))))
    (define-syntax run40 (syntax-rules () ((_ (x) g0 g ...) (run 40 (x) g0 g ...))))

    (define caro
      (lambda (p a)
        (fresh (d)
          (== (cons a d) p))))

    (define cdro
      (lambda (p d)
        (fresh (a)
          (== (cons a d) p))))

    (define conso
      (lambda (a d p)
        (== (cons a d) p)))

    (define nullo
      (lambda (x)
        (== '() x)))

    (define eqo
      (lambda (x y)
        (== x y)))

    (define pairo
      (lambda (p)
        (fresh (a d)
          (conso a d p))))

    (define membero
      (lambda (x l)
        (conde
          ((fresh (a)
             (caro l a)
             (== a x)))
          ((fresh (d)
             (cdro l d)
             (membero x d))))))

    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          ((fresh (a d res)
             (conso a d l)
             (rembero x d res)
             (conso a res out))))))

    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((fresh (a d res)
             (conso a d l)
             (conso a res out)
             (appendo d s res))))))

    (define flatteno
      (lambda (s out)
        (conde
          ((nullo s) (== '() out))
          ((pairo s)
           (fresh (a d res-a res-d)
             (conso a d s)
             (flatteno a res-a)
             (flatteno d res-d)
             (appendo res-a res-d out)))
          ((conso s '() out)))))

    (define anyo
      (lambda (g)
        (conde
          (g)
          ((anyo g)))))

    (define nevero (anyo fail))
    (define alwayso (anyo succeed))



    (define build-num
      (lambda (n)
        (cond
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2))))
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((zero? n) '()))))

    (define poso
      (lambda (n)
        (fresh (a d)
          (== `(,a . ,d) n))))

    (define >1o
      (lambda (n)
        (fresh (a ad dd)
          (== `(,a ,ad . ,dd) n))))

    (define full-addero
      (lambda (b x y r c)
        (conde
          ((== 0 b) (== 0 x) (== 0 y) (== 0 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 0 b) (== 1 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 1 x) (== 0 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 0 x) (== 1 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 1 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 1 b) (== 1 x) (== 1 y) (== 1 r) (== 1 c)))))

    (define addero
      (lambda (d n m r)
        (conde
          ((== 0 d) (== '() m) (== n r))
          ((== 0 d) (== '() n) (== m r)
           (poso m))
          ((== 1 d) (== '() m)
           (addero 0 n '(1) r))
          ((== 1 d) (== '() n) (poso m)
           (addero 0 '(1) m r))
          ((== '(1) n) (== '(1) m)
           (fresh (a c)
             (== `(,a ,c) r)
             (full-addero d 1 1 a c)))
          ((== '(1) n) (gen-addero d n m r))
          ((== '(1) m) (>1o n) (>1o r)
           (addero d '(1) n r))
          ((>1o n) (gen-addero d n m r)))))

    (define gen-addero
      (lambda (d n m r)
        (fresh (a b c e x y z)
          (== `(,a . ,x) n)
          (== `(,b . ,y) m) (poso y)
          (== `(,c . ,z) r) (poso z)
          (full-addero d a b c e)
          (addero e x y z))))

    (define pluso
      (lambda (n m k)
        (addero 0 n m k)))

    (define minuso
      (lambda (n m k)
        (pluso m k n)))

    (define *o
      (lambda (n m p)
        (conde
          ((== '() n) (== '() p))
          ((poso n) (== '() m) (== '() p))
          ((== '(1) n) (poso m) (== m p))
          ((>1o n) (== '(1) m) (== n p))
          ((fresh (x z)
             (== `(0 . ,x) n) (poso x)
             (== `(0 . ,z) p) (poso z)
             (>1o m)
             (*o x m z)))
          ((fresh (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(0 . ,y) m) (poso y)
             (*o m n p)))
          ((fresh (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(1 . ,y) m) (poso y)
             (odd-*o x n m p))))))

    (define odd-*o
      (lambda (x n m p)
        (fresh (q)
          (bound-*o q p n m)
          (*o x m q)
          (pluso `(0 . ,q) m p))))

    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((fresh (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))

    (define =lo
      (lambda (n m)
        (conde
          ((== '() n) (== '() m))
          ((== '(1) n) (== '(1) m))
          ((fresh (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (=lo x y))))))

    (define <lo
      (lambda (n m)
        (conde
          ((== '() n) (poso m))
          ((== '(1) n) (>1o m))
          ((fresh (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (<lo x y))))))

    (define <=lo
      (lambda (n m)
        (conde
          ((=lo n m))
          ((<lo n m)))))

    (define <o
      (lambda (n m)
        (conde
          ((<lo n m))
          ((=lo n m)
           (fresh (x)
             (poso x)
             (pluso n x m))))))

    (define <=o
      (lambda (n m)
        (conde
          ((== n m))
          ((<o n m)))))

    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (fresh (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((fresh (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((fresh (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((fresh (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((fresh (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((fresh (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))

    (define logo
     (lambda (n b q r)
       (conde
         ((== '(1) n) (poso b) (== '() q) (== '() r))
         ((== '() q) (<o n b) (pluso r '(1) n))
         ((== '(1) q) (>1o b) (=lo n b) (pluso r b n))
         ((== '(1) b) (poso q) (pluso r '(1) n))
         ((== '() b) (poso q) (== r n))
         ((== '(0 1) b)
          (fresh (a ad dd)
            (poso dd)
            (== `(,a ,ad . ,dd) n)
            (exp2 n '() q)
            (fresh (s)
              (splito n dd r s))))
         ((fresh (a ad add ddd)
            (conde
              ((== '(1 1) b))
              ((== `(,a ,ad ,add . ,ddd) b))))
          (<lo b n)
          (fresh (bw1 bw nw nw1 ql1 ql s)
            (exp2 b '() bw1)
            (pluso bw1 '(1) bw)
            (<lo q n)
            (fresh (q1 bwq1)
              (pluso q '(1) q1)
              (*o bw q1 bwq1)
              (<o nw1 bwq1))
              (exp2 n '() nw1)
              (pluso nw1 '(1) nw)
              (/o nw bw ql1 s)
              (pluso ql '(1) ql1)
              (<=lo ql q)
              (fresh (bql qh s qdh qd)
                (repeated-mul b ql bql)
                (/o nw bw1 qh s)
                (pluso ql qdh qh)
                (pluso ql qd q)
                (<=o qd qdh)
                (fresh (bqd bq1 bq)
                  (repeated-mul b qd bqd)
                  (*o bql bqd bq)
                  (*o b bq bq1)
                  (pluso bq r n)
                  (<o n bq1))))))))

    (define exp2
      (lambda (n b q)
        (conde
          ((== '(1) n) (== '() q))
          ((>1o n) (== '(1) q)
           (fresh (s)
             (splito n b s '(1))))
          ((fresh (q1 b2)
             (== `(0 . ,q1) q)
             (poso q1)
             (<lo b n)
             (appendo b `(1 . ,b) b2)
             (exp2 n b2 q1)))
          ((fresh (q1 nh b2 s)
             (== `(1 . ,q1) q)
             (poso q1)
             (poso nh)
             (splito n b s nh)
             (appendo b `(1 . ,b) b2)
             (exp2 nh b2 q1))))))

    (define repeated-mul
      (lambda (n q nq)
        (conde
          ((poso n) (== '() q) (== '(1) nq))
          ((== '(1) q) (== n nq))
          ((>1o q)
           (fresh (q1 nq1)
             (pluso q1 '(1) q)
             (repeated-mul n q1 nq1)
             (*o nq1 n nq))))))

    (define expo
      (lambda (b q n)
        (logo n b q '())))
    #+end_src
*** mktests
    #+begin_src scheme
    ;;; This file was generated by writeminikanren.pl
    ;;; Generated at 2007-10-25 15:24:42

    ;; (load "mk.scm")


    (define-syntax test-check
      (syntax-rules ()
        ((_ title tested-expression expected-result)
         (begin
           (cout "Testing " title nl)
           (let* ((expected expected-result)
                  (produced tested-expression))
             (or (equal? expected produced)
                 (errorf 'test-check
                   "Failed: ~a~%Expected: ~a~%Computed: ~a~%"
                   'tested-expression expected produced)))))))

    (define max-ticks 10)
    ;;; Will sez:  Uncomment the following line to properly test divergent code.
    ;;; (define max-ticks 10)
    (define max-ticks 10)
    ;;; Will sez:  Uncomment the following line to properly test divergent code.
    ;;; (define max-ticks 10000000)

    (define-syntax test-divergence
      (syntax-rules ()
        ((_ title tested-expression)
         (let ((max-ticks 1000000))
           (printf "Testing ~s (engine with ~s ticks fuel)\n" title max-ticks)
           ((make-engine (lambda () tested-expression))
            max-ticks
            (lambda (t v)
              (error title "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
            (lambda (e^) (void)))))))


    ;;; Redefine 'test-check' to make the file load quickly.
    '(define-syntax test-check
    (syntax-rules ()
    ((_ title tested-expression expected-result)
    (if #f #f))))

    (define nl (string #\newline))

    (define (cout . args)
      (for-each (lambda (x)
                  (if (procedure? x) (x) (display x)))
                args))

    (define errorf
      (lambda (tag . args)
        (printf "Failed: ~s: ~%" tag)
        (apply printf args)
        (error 'WiljaCodeTester "That's all, folks!")))

    ;;;  Max fuel for engines
    (define max-ticks 10)
    ;;; Will sez:  Uncomment the following line to properly test divergent code.
    ;;; (define max-ticks 10000000)


    (define-syntax run1 (syntax-rules () ((_ (x) g0 g ...) (run 1 (x) g0 g ...))))
    (define-syntax run2 (syntax-rules () ((_ (x) g0 g ...) (run 2 (x) g0 g ...))))
    (define-syntax run3 (syntax-rules () ((_ (x) g0 g ...) (run 3 (x) g0 g ...))))
    (define-syntax run4 (syntax-rules () ((_ (x) g0 g ...) (run 4 (x) g0 g ...))))
    (define-syntax run5 (syntax-rules () ((_ (x) g0 g ...) (run 5 (x) g0 g ...))))
    (define-syntax run6 (syntax-rules () ((_ (x) g0 g ...) (run 6 (x) g0 g ...))))
    (define-syntax run7 (syntax-rules () ((_ (x) g0 g ...) (run 7 (x) g0 g ...))))
    (define-syntax run8 (syntax-rules () ((_ (x) g0 g ...) (run 8 (x) g0 g ...))))
    (define-syntax run9 (syntax-rules () ((_ (x) g0 g ...) (run 9 (x) g0 g ...))))
    (define-syntax run10 (syntax-rules () ((_ (x) g0 g ...) (run 10 (x) g0 g ...))))

    (define-syntax run11 (syntax-rules () ((_ (x) g0 g ...) (run 11 (x) g0 g ...))))
    (define-syntax run12 (syntax-rules () ((_ (x) g0 g ...) (run 12 (x) g0 g ...))))
    (define-syntax run13 (syntax-rules () ((_ (x) g0 g ...) (run 13 (x) g0 g ...))))
    (define-syntax run14 (syntax-rules () ((_ (x) g0 g ...) (run 14 (x) g0 g ...))))
    (define-syntax run15 (syntax-rules () ((_ (x) g0 g ...) (run 15 (x) g0 g ...))))
    (define-syntax run16 (syntax-rules () ((_ (x) g0 g ...) (run 16 (x) g0 g ...))))
    (define-syntax run17 (syntax-rules () ((_ (x) g0 g ...) (run 17 (x) g0 g ...))))
    (define-syntax run18 (syntax-rules () ((_ (x) g0 g ...) (run 18 (x) g0 g ...))))
    (define-syntax run19 (syntax-rules () ((_ (x) g0 g ...) (run 19 (x) g0 g ...))))
    (define-syntax run20 (syntax-rules () ((_ (x) g0 g ...) (run 20 (x) g0 g ...))))

    (define-syntax run21 (syntax-rules () ((_ (x) g0 g ...) (run 21 (x) g0 g ...))))
    (define-syntax run22 (syntax-rules () ((_ (x) g0 g ...) (run 22 (x) g0 g ...))))
    (define-syntax run23 (syntax-rules () ((_ (x) g0 g ...) (run 23 (x) g0 g ...))))
    (define-syntax run24 (syntax-rules () ((_ (x) g0 g ...) (run 24 (x) g0 g ...))))
    (define-syntax run25 (syntax-rules () ((_ (x) g0 g ...) (run 25 (x) g0 g ...))))
    (define-syntax run26 (syntax-rules () ((_ (x) g0 g ...) (run 26 (x) g0 g ...))))
    (define-syntax run27 (syntax-rules () ((_ (x) g0 g ...) (run 27 (x) g0 g ...))))
    (define-syntax run28 (syntax-rules () ((_ (x) g0 g ...) (run 28 (x) g0 g ...))))
    (define-syntax run29 (syntax-rules () ((_ (x) g0 g ...) (run 29 (x) g0 g ...))))
    (define-syntax run30 (syntax-rules () ((_ (x) g0 g ...) (run 30 (x) g0 g ...))))

    (define-syntax run31 (syntax-rules () ((_ (x) g0 g ...) (run 31 (x) g0 g ...))))
    (define-syntax run32 (syntax-rules () ((_ (x) g0 g ...) (run 32 (x) g0 g ...))))
    (define-syntax run33 (syntax-rules () ((_ (x) g0 g ...) (run 33 (x) g0 g ...))))
    (define-syntax run34 (syntax-rules () ((_ (x) g0 g ...) (run 34 (x) g0 g ...))))
    (define-syntax run35 (syntax-rules () ((_ (x) g0 g ...) (run 35 (x) g0 g ...))))
    (define-syntax run36 (syntax-rules () ((_ (x) g0 g ...) (run 36 (x) g0 g ...))))
    (define-syntax run37 (syntax-rules () ((_ (x) g0 g ...) (run 37 (x) g0 g ...))))
    (define-syntax run38 (syntax-rules () ((_ (x) g0 g ...) (run 38 (x) g0 g ...))))
    (define-syntax run39 (syntax-rules () ((_ (x) g0 g ...) (run 39 (x) g0 g ...))))
    (define-syntax run40 (syntax-rules () ((_ (x) g0 g ...) (run 40 (x) g0 g ...))))

    (test-check "testc11.tex-1"
    (run* (q)
      fail)

    `())

    (test-check "testc11.tex-2"
    (run* (q)
      (== #t q))

    `(#t))

    (test-check "testc11.tex-3"
    (run* (q)
      fail
      (== #t q))

    `())

        (define g fail)


    (test-check "testc11.tex-4"
    (run* (q)
      succeed
      (== #t q))

    (list #t))

    (test-check "testc11.tex-5"
    (run* (q)
      succeed
      (== #t q))

    `(#t))

    (test-check "testc11.tex-6"
    (run* (r)
      succeed
      (== 'corn r))

    (list 'corn))

    (test-check "testc11.tex-7"
    (run* (r)
      succeed
      (== 'corn r))

    `(corn))

    (test-check "testc11.tex-8"
    (run* (r)
      fail
      (== 'corn r))

    `())

    (test-check "testc11.tex-9"
    (run* (q)
      succeed
      (== #f q))

    `(#f))

    (test-check "testc11.tex-10"
    (run* (x)
      (let ((x #f))
        (== #t x)))

    '())

    (test-check "testc11.tex-11"
    (run* (q)
      (fresh (x)
        (== #t x)
        (== #t q)))

    (list #t))

    (run* (q)
      (fresh (x)
        (== #t x)
        (== #t q)))


    (test-check "testc11.tex-12"
    (run* (q)
      (fresh (x)
        (== x #t)
        (== #t q)))

    (list #t))

    (test-check "testc11.tex-13"
    (run* (q)
      (fresh (x)
        (== x #t)
        (== q #t)))

    (list #t))

    (test-check "testc11.tex-14"
    (run* (x)
      succeed)

    (list `_.0))

    (test-check "testc11.tex-15"
    (run* (x)
      (let ((x #f))
        (fresh (x)
          (== #t x))))

    `(_.0))

    (test-check "testc11.tex-16"
    (run* (r)
      (fresh (x y)
        (== (cons x (cons y '())) r)))

    (list `(_.0 _.1)))

    (test-check "testc11.tex-17"
    (run* (s)
      (fresh (t u)
        (== (cons t (cons u '())) s)))

    (list `(_.0 _.1)))

    (test-check "testc11.tex-18"
    (run* (r)
      (fresh (x)
        (let ((y x))
          (fresh (x)
            (== (cons y (cons x (cons y '()))) r)))))

    (list `(_.0 _.1 _.0)))

    (test-check "testc11.tex-19"
    (run* (r)
      (fresh (x)
        (let ((y x))
          (fresh (x)
            (== (cons x (cons y (cons x '()))) r)))))

    (list `(_.0 _.1 _.0)))

    (test-check "testc11.tex-20"
    (run* (q)
      (== #f q)
      (== #t q))

    `())

    (test-check "testc11.tex-21"
    (run* (q)
      (== #f q)
      (== #f q))

    '(#f))

    (test-check "testc11.tex-22"
    (run* (q)
      (let ((x q))
        (== #t x)))

    (list #t))

    (test-check "testc11.tex-23"
    (run* (r)
      (fresh (x)
        (== x r)))

    (list `_.0))

    (test-check "testc11.tex-24"
    (run* (q)
      (fresh (x)
        (== #t x)
        (== x q)))

    (list #t))

    (test-check "testc11.tex-25"
    (run* (q)
      (fresh (x)
        (== x q)
        (== #t x)))

    (list #t))

    (run* (q)
      (fresh (x)
        (== #t x)
        (== x q)))


    (test-check "testc11.tex-26"
    (run* (q)
      (fresh (x)
        (== (eq? x q) q)))


        (list #f))


    (test-check "testc11.tex-27"
    (run* (q)
      (let ((x q))
        (fresh (q)
          (== (eq? x q) x))))

    (list #f))

    (test-check "testc11.tex-28"
    (cond
      (#f #t)
      (#t #f))

    #f)

    (test-check "testc11.tex-29"
    (cond
      (#f succeed)
      (#t fail))


        fail)


        (test-check "testc13.tex-fail1" (run* (q)


    (conde
      (fail succeed)
      (succeed fail))


        ) '())


        (test-check "testc13.tex-succeed1" (not (null? (run* (q)


    (conde
      (fail fail)
      (succeed succeed))


        ))) #t)


        (test-check "testc13.tex-succeed2" (not (null? (run* (q)


    (conde
      (succeed succeed)
      (succeed fail))


        ))) #t)


    (test-check "testc11.tex-30"
    (run* (x)
      (conde
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive oil))

    (test-check "testc11.tex-31"
    (run1 (x)
      (conde
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive))

    (test-check "testc11.tex-32"
    (run* (x)
      (conde
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        (succeed succeed)
        ((== 'oil x) succeed)))

    `(olive _.0 oil))

        (test-check "testc13.tex-conde1" (run* (x)


    (conde
      ((== 'olive x) succeed)
      (succeed succeed)
      ((== 'oil x) succeed))


        ) `(olive _.0 oil))


    (test-check "testc11.tex-33"
    (run2 (x)
      (conde
        ((== 'extra x) succeed)
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(extra olive))

    (test-check "testc11.tex-34"
    (run* (r)
      (fresh (x y)
        (== 'split x)
        (== 'pea y)
        (== (cons x (cons y '())) r)))

    (list `(split pea)))

    (test-check "testc11.tex-35"
    (run* (r)
      (fresh (x y)
        (conde
          ((== 'split x) (== 'pea y))
          ((== 'navy x) (== 'bean y)))
        (== (cons x (cons y '())) r)))

    `((split pea) (navy bean)))

    (test-check "testc11.tex-36"
    (run* (r)
      (fresh (x y)
        (conde
          ((== 'split x) (== 'pea y))
          ((== 'navy x) (== 'bean y)))
        (== (cons x (cons y (cons 'soup '()))) r)))

    `((split pea soup) (navy bean soup)))

    (define teacupo
      (lambda (x)
        (conde
          ((== 'tea x) succeed)
          ((== 'cup x) succeed))))


    (test-check "testc11.tex-37"
    (run* (x)
      (teacupo x))

    `(tea cup))

    (test-check "testc11.tex-38"
    (run* (r)
      (fresh (x y)
        (conde
          ((teacupo x) (== #t y) succeed)
          ((== #f x) (== #t y)))
        (== (cons x (cons y '())) r)))

    `((#f #t) (tea #t) (cup #t)))

    (test-check "testc11.tex-39"
    (run* (r)
      (fresh (x y z)
        (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x)))
        (== (cons y (cons z '())) r)))

    `((_.0 _.1) (_.0 _.1)))

    (test-check "testc11.tex-40"
    (run* (r)
      (fresh (x y z)
        (conde
          ((== y x) (fresh (x) (== z x)))
          ((fresh (x) (== y x)) (== z x)))
        (== #f x)
        (== (cons y (cons z '())) r)))

    `((#f _.0) (_.0 #f)))

    (test-check "testc11.tex-41"
    (run* (q)
      (let ((a (== #t q))
            (b (== #f q)))
       b))

    '(#f))

    (test-check "testc11.tex-42"
    (run* (q)
      (let ((a (== #t q))
            (b (fresh (x)
                 (== x q)
                 (== #f x)))
            (c (conde
                 ((== #t q) succeed)
                 (succeed (== #f q)))))
       b))

    '(#f))

    (test-check "testc12.tex-1"
    (let ((x (lambda (a) a))
          (y 'c))
      (x y))

    'c)

    (test-check "testc12.tex-2"
    (run* (r)
      (fresh (y x)
        (== `(,x ,y) r)))

    (list `(_.0 _.1)))

    (test-check "testc12.tex-3"
    (run* (r)
      (fresh (v w)
        (== (let ((x v) (y w)) `(,x ,y)) r)))

    `((_.0 _.1)))

    (test-check "testc12.tex-4"
    (car `(grape raisin pear))

    `grape)

    (test-check "testc12.tex-5"
    (car `(a c o r n))

    'a)


    (define caro
      (lambda (p a)
        (fresh (d)
          (== (cons a d) p))))


    (test-check "testc12.tex-6"
    (run* (r)
      (caro `(a c o r n) r))

    (list 'a))

    (test-check "testc12.tex-7" 'a

              (car

    `(a c o r n)

              ))


    (test-check "testc12.tex-8"
    (run* (q)
      (caro `(a c o r n) 'a)
      (== #t q))

    (list #t))

    (test-check "testc12.tex-9" 'a

              (car

    `(a c o r n)

              ))


    (test-check "testc12.tex-10"
    (run* (r)
      (fresh (x y)
        (caro `(,r ,y) x)
        (== 'pear x)))

    (list 'pear))


    (test-check "testc12.tex-11"
    (cons
      (car `(grape raisin pear))
      (car `((a) (b) (c))))

    `(grape a))

    (test-check "testc12.tex-12"
    (run* (r)
      (fresh (x y)
        (caro `(grape raisin pear) x)
        (caro `((a) (b) (c)) y)
        (== (cons x y) r)))

    (list `(grape a)))

    (test-check "testc12.tex-13"
    (cdr `(grape raisin pear))

    `(raisin pear))

    (test-check "testc12.tex-14"
    (car (cdr `(a c o r n)))

    'c)


    (define cdro
      (lambda (p d)
        (fresh (a)
          (== (cons a d) p))))


    (test-check "testc12.tex-15"
    (run* (r)
      (fresh (v)
        (cdro `(a c o r n) v)
        (caro v r)))

    (list 'c))


    (test-check "testc12.tex-16"
    (cons
      (cdr `(grape raisin pear))
      (car `((a) (b) (c))))

    `((raisin pear) a))

    (test-check "testc12.tex-17"
    (run* (r)
      (fresh (x y)
        (cdro `(grape raisin pear) x)
        (caro `((a) (b) (c)) y)
        (== (cons x y) r)))

    (list `((raisin pear) a)))

    (test-check "testc12.tex-18"
    (run* (q)
      (cdro '(a c o r n) '(c o r n))
      (== #t q))

    (list #t))

    (test-check "testc12.tex-19" `(c o r n)

       (cdr

    '(a c o r n)

       ))


    (test-check "testc12.tex-20"
    (run* (x)
      (cdro '(c o r n) `(,x r n)))

    (list 'o))

    (test-check "testc12.tex-21" `(o r n)

       (cdr

    `(c o r n)

       ))


    (test-check "testc12.tex-22"
    (run* (l)
      (fresh (x)
        (cdro l '(c o r n))
        (caro l x)
        (== 'a x)))

    (list `(a c o r n)))


    (define conso
      (lambda (a d p)
        (== (cons a d) p)))


    (test-check "testc12.tex-23"
    (run* (l)
      (conso '(a b c) '(d e) l))

    (list `((a b c) d e)))

    (test-check "testc12.tex-24"
    (run* (x)
      (conso x '(a b c) '(d a b c)))

    (list 'd))

    (test-check "testc12.tex-25" (cons 'd '(a b c))
    `(d a b c))

    (test-check "testc12.tex-26"
    (run* (r)
      (fresh (x y z)
        (== `(e a d ,x) r)
        (conso y `(a ,z c) r)))

    (list `(e a d c)))

    (test-check "testc12.tex-27"
    (run* (x)
      (conso x `(a ,x c) `(d a ,x c)))

    (list 'd))

             (define x 'd)


    (test-check "testc12.tex-28" (cons x `(a ,x c))
    `(d a ,x c))

    (test-check "testc12.tex-29"
    (run* (l)
      (fresh (x)
        (== `(d a ,x c) l)
        (conso x `(a ,x c) l)))

    (list `(d a d c)))

    (test-check "testc12.tex-30"
    (run* (l)
      (fresh (x)
        (conso x `(a ,x c) l)
        (== `(d a ,x c) l)))

    (list `(d a d c)))


    (test-check "testc12.tex-31"
    (run* (l)
      (fresh (d x y w s)
        (conso w '(a n s) s)
        (cdro l s)
        (caro l x)
        (== 'b x)
        (cdro l d)
        (caro d y)
        (== 'e y)))

    (list `(b e a n s)))

    (test-check "testc12.tex-32"
    (null? `(grape raisin pear))

    #f)

    (test-check "testc12.tex-33"
    (null? '())

    #t)


    (define nullo
      (lambda (x)
        (== '() x)))


    (test-check "testc12.tex-34"
    (run* (q)
      (nullo `(grape raisin pear))
      (== #t q))

    `())

    (test-check "testc12.tex-35"
    (run* (q)
      (nullo '())
      (== #t q))

    `(#t))

    (test-check "testc12.tex-36"
    (run* (x)
      (nullo x))

    `(()))


    (test-check "testc12.tex-37"
    (eq? 'pear 'plum)

    #f)

    (test-check "testc12.tex-38"
    (eq? 'plum 'plum)

    #t)


    (define eqo
      (lambda (x y)
        (== x y)))


    (test-check "testc12.tex-39"
    (run* (q)
      (eqo 'pear 'plum)
      (== #t q))

    `())

    (test-check "testc12.tex-40"
    (run* (q)
      (eqo 'plum 'plum)
      (== #t q))

    `(#t))


    (test-check "testc12.tex-41"
    (pair? `((split) . pea))

    #t)

    (test-check "testc12.tex-42"
    (pair? '())

    #f)

    (test-check "testc12.tex-43"
    (car `(pear))

    `pear)

    (test-check "testc12.tex-44"
    (cdr `(pear))

    `())

    (test-check "testc12.tex-45"
    (cons `(split) 'pea)

    `((split) . pea))

    (test-check "testc12.tex-46"
    (run* (r)
      (fresh (x y)
        (== (cons x (cons y 'salad)) r)))

    (list `(_.0 _.1 . salad)))

    (define pairo
      (lambda (p)
        (fresh (a d)
          (conso a d p))))


    (test-check "testc12.tex-47"
    (run* (q)
      (pairo (cons q q))
      (== #t q))

    `(#t))

    (test-check "testc12.tex-48"
    (run* (q)
      (pairo '())
      (== #t q))

    `())

    (test-check "testc12.tex-49"
    (run* (q)
      (pairo 'pair)
      (== #t q))

    `())

    (test-check "testc12.tex-50"
    (run* (x)
      (pairo x))

    (list `(_.0 . _.1)))

    (test-check "testc12.tex-51"
    (run* (r)
      (pairo (cons r 'pear)))

    (list `_.0))

    (define new-list?
      (lambda (l)
        (cond
          ((null? l) #t)
          ((pair? l) (new-list? (cdr l)))
          (else #f))))


    (test-check "testc14.tex-1"
    (new-list? `((a) (a b) c))

    #t)

    (test-check "testc14.tex-2"
    (new-list? `())

    #t)

    (test-check "testc14.tex-3"
    (new-list? 's)

    #f)

    (test-check "testc14.tex-4"
    (new-list? `(d a t e . s))

    #f)

    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (fresh (d)
             (cdro l d)
             (listo d)))
          ((== #f #f) fail))))


    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (fresh (d)
             (cdro l d)
             (listo d)))
          (succeed fail))))


    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (fresh (d)
             (cdro l d)
             (listo d))))))


    (test-check "testc14.tex-5"
    (run* (x)
      (listo `(a b ,x d)))

    (list `_.0))

    (test-check "testc14.tex-6"
    (run1 (x)
      (listo `(a b c . ,x)))

    (list `()))
    (define e (make-engine (lambda ()
    (run* (x)
      (listo `(a b c . ,x)))
    )))
    (printf "Testing testc14.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc14.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc14.tex-8"
    (run5 (x)
      (listo `(a b c . ,x)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3))
    )

    (define lol?
      (lambda (l)
        (cond
          ((null? l) #t)
          ((new-list? (car l)) (lol? (cdr l)))
          (else #f))))


    (define lolo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((fresh (a)
             (caro l a)
             (listo a))
           (fresh (d)
             (cdro l d)
             (lolo d))))))


    (test-check "testc14.tex-9"
    (run1 (l)
      (lolo l))

    `(()))

    (test-check "testc14.tex-10"
    (run* (q)
      (fresh (x y)
        (lolo `((a b) (,x c) (d ,y)))
        (== #t q)))

    (list #t))

    (test-check "testc14.tex-11"
    (run1 (q)
      (fresh (x)
        (lolo `((a b) . ,x))
        (== #t q)))

    (list #t))

    (test-check "testc14.tex-12"
    (run1 (x)
      (lolo `((a b) (c d) . ,x)))

    `(()))

    (test-check "testc14.tex-13"
    (run5 (x)
      (lolo `((a b) (c d) . ,x)))


    `(()
     (())
     ((_.0))
     (() ())
     ((_.0 _.1)))
    )

    (define twinso
      (lambda (s)
        (fresh (x y)
          (conso x y s)
          (conso x '() y))))


    (test-check "testc14.tex-14"
    (run* (q)
      (twinso '(tofu tofu))
      (== #t q))

    (list #t))

    (test-check "testc14.tex-15"
    (run* (z)
      (twinso `(,z tofu)))

    (list `tofu))

    (define loto
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((fresh (a)
             (caro l a)
             (twinso a))
           (fresh (d)
             (cdro l d)
             (loto d))))))


    (test-check "testc14.tex-16"
    (run1 (z)
      (loto `((g g) . ,z)))

    (list `()))

    (test-check "testc14.tex-17"
    (run5 (z)
      (loto `((g g) . ,z)))


    '(()
     ((_.0 _.0))
     ((_.0 _.0) (_.1 _.1))
     ((_.0 _.0) (_.1 _.1) (_.2 _.2))
     ((_.0 _.0) (_.1 _.1) (_.2 _.2) (_.3 _.3)))
    )

    (test-check "testc14.tex-18"
    (run5 (r)
      (fresh (w x y z)
        (loto `((g g) (e ,w) (,x ,y) . ,z))
        (== `(,w (,x ,y) ,z) r)))


    '((e (_.0 _.0) ())
     (e (_.0 _.0) ((_.1 _.1)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2) (_.3 _.3)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2) (_.3 _.3) (_.4 _.4))))
    )

    (test-check "testc14.tex-19"
    (run3 (out)
      (fresh (w x y z)
        (== `((g g) (e ,w) (,x ,y) . ,z) out)
        (loto out)))


    `(((g g) (e e) (_.0 _.0))
     ((g g) (e e) (_.0 _.0) (_.1 _.1))
     ((g g) (e e) (_.0 _.0) (_.1 _.1) (_.2 _.2)))
    )

    (define listofo
      (lambda (predo l)
        (conde
          ((nullo l) succeed)
          ((fresh (a)
             (caro l a)
             (predo a))
           (fresh (d)
             (cdro l d)
             (listofo predo d))))))


    (test-check "testc14.tex-20"
    (run3 (out)
      (fresh (w x y z)
        (== `((g g) (e ,w) (,x ,y) . ,z) out)
        (listofo twinso out)))


    `(((g g) (e e) (_.0 _.0))
     ((g g) (e e) (_.0 _.0) (_.1 _.1))
     ((g g) (e e) (_.0 _.0) (_.1 _.1) (_.2 _.2)))
    )

    (define loto
      (lambda (l)
        (listofo twinso l)))


    (define member?
      (lambda (x l)
        (cond
          ((null? l) #f)
          ((eq? (car l) x) #t)
          (else (member? x (cdr l))))))


    (test-check "testc14.tex-21"
    (member? 'olive `(virgin olive oil))

    #t)

    (define membero
      (lambda (x l)
        (conde
          ((nullo l) fail)
          ((fresh (a)
             (caro l a)
             (== a x))
           succeed)
          (succeed
            (fresh (d)
              (cdro l d)
              (membero x d))))))


    (test-check "testc14.tex-22"
    (run* (q)
      (membero 'olive `(virgin olive oil))
      (== #t q))

    (list #t))

    (test-check "testc14.tex-23"
    (run1 (y)
      (membero y `(hummus with pita)))

    (list `hummus))

    (test-check "testc14.tex-24"
    (run1 (y)
      (membero y `(with pita)))

    (list `with))

    (test-check "testc14.tex-25"
    (run1 (y)
      (membero y `(pita)))

    (list `pita))

    (test-check "testc14.tex-26"
    (run* (y)
      (membero y `()))

    `())

    (test-check "testc14.tex-27"
    (run* (y)
      (membero y `(hummus with pita)))

    `(hummus with pita))

    (test-check "testc14.tex-28"
    (run* (x)
      (membero 'e `(pasta ,x fagioli)))

    (list `e))

    (test-check "testc14.tex-29"
    (run1 (x)
      (membero 'e `(pasta e ,x fagioli)))

    (list `_.0))

    (test-check "testc14.tex-30"
    (run1 (x)
      (membero 'e `(pasta ,x e fagioli)))

    (list `e))

    (test-check "testc14.tex-31"
    (run* (r)
      (fresh (x y)
        (membero 'e `(pasta ,x fagioli ,y))
        (== `(,x ,y) r)))

    `((e _.0) (_.0 e)))

    (test-check "testc14.tex-32"
    (run1 (l)
      (membero 'tofu l))

    `((tofu . _.0)))
    (define e (make-engine (lambda ()
    (run* (l)
      (membero 'tofu l))
    )))
    (printf "Testing testc14.tex-33  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc14.tex-33 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc14.tex-34"
    (run5 (l)
      (membero 'tofu l))


    `((tofu . _.0)
     (_.0 tofu . _.1)
     (_.0 _.1 tofu . _.2)
     (_.0 _.1 _.2 tofu . _.3)
     (_.0 _.1 _.2 _.3 tofu . _.4))
    )

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x) (cdro l '()))
          ((fresh (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-35"
    (run5 (l)
      (pmembero 'tofu l))


    `((tofu)
     (_.0 tofu)
     (_.0 _.1 tofu)
     (_.0 _.1 _.2 tofu)
     (_.0 _.1 _.2 _.3 tofu))
    )

    (test-check "testc14.tex-36"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t))

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x)
           (conde
             ((cdro l '()))
             (succeed)))
          ((fresh (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-37"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t #t #t))

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x)
           (conde
             ((cdro l '()))
             ((fresh (a d)
                (cdro l `(,a . ,d))))))
          ((fresh (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-38"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t #t))

    (test-check "testc14.tex-39"
    (run12 (l)
      (pmembero 'tofu l))


    `((tofu)
     (tofu _.0 . _.1)
     (_.0 tofu)
     (_.0 tofu _.1 . _.2)
     (_.0 _.1 tofu)
     (_.0 _.1 tofu _.2 . _.3)
     (_.0 _.1 _.2 tofu)
     (_.0 _.1 _.2 tofu _.3 . _.4)
     (_.0 _.1 _.2 _.3 tofu)
     (_.0 _.1 _.2  _.3 tofu _.4 . _.5 )
     (_.0 _.1 _.2 _.3 _.4 tofu)
     (_.0 _.1 _.2 _.3 _.4 tofu _.5 . _.6))
    )

    (define mem
      (lambda (x l)
        (cond
          ((null? l) #f)
          ((eq? (car l) x) l)
          (else (mem x (cdr l))))))


    (test-check "testc15.tex-1"
    (mem 'tofu `(a b tofu d peas e))

    `(tofu d peas e))

    (test-check "testc15.tex-2"
    (mem 'tofu `(a b peas d peas e))

    #f)

    (test-check "testc15.tex-3"
    (run* (out)
      (== (mem 'tofu `(a b tofu d peas e)) out))

    (list `(tofu d peas e)))

    (test-check "testc15.tex-4"
    (mem 'peas
      (mem 'tofu `(a b tofu d peas e)))

    `(peas e))

    (test-check "testc15.tex-5"
    (mem 'tofu
      (mem 'tofu `(a b tofu d tofu e)))

    `(tofu d tofu e))

    (test-check "testc15.tex-6"
    (mem 'tofu
      (cdr (mem 'tofu `(a b tofu d tofu e))))

    `(tofu e))

    (define memo
      (lambda (x l out)
        (conde
          ((nullo l) fail)
          ((fresh (a)
             (caro l a)
             (== a x))
           (== l out))
          (succeed
            (fresh (d)
              (cdro l d)
              (memo x d out))))))


    (define memo
      (lambda (x l out)
        (conde
          ((fresh (a)
             (caro l a)
             (== a x))
           (== l out))
          ((fresh (d)
             (cdro l d)
             (memo x d out))))))


    (define memo
      (lambda (x l out)
        (conde
          ((caro l x) (== l out))
          ((fresh (d)
             (cdro l d)
             (memo x d out))))))


    (test-check "testc15.tex-7"
    (run1 (out)
      (memo 'tofu `(a b tofu d tofu e) out))

    `((tofu d tofu e)))

    (test-check "testc15.tex-8"
    (run1 (out)
      (fresh (x)
        (memo 'tofu `(a b ,x d tofu e) out)))

    `((tofu d tofu e)))

    (test-check "testc15.tex-9"
    (run* (r)
      (memo r
        `(a b tofu d tofu e)
        `(tofu d tofu e)))

    (list `tofu))

    (test-check "testc15.tex-10"
    (run* (q)
      (memo 'tofu '(tofu e) '(tofu e))
      (== #t q))

    (list #t))

    (test-check "testc15.tex-11"
    (run* (q)
      (memo 'tofu '(tofu e) '(tofu))
      (== #t q))

    `())

    (test-check "testc15.tex-12"
    (run* (x)
      (memo 'tofu '(tofu e) `(,x e)))

    (list `tofu))

    (test-check "testc15.tex-13"
    (run* (x)
      (memo 'tofu '(tofu e) `(peas ,x)))

    `())

    (test-check "testc15.tex-14"
    (run* (out)
      (fresh (x)
        (memo 'tofu `(a b ,x d tofu e) out)))

    `((tofu d tofu e) (tofu e)))

    (test-check "testc15.tex-15"
    (run12 (z)
      (fresh (u)
        (memo 'tofu `(a b tofu d tofu e . ,z) u)))


    `(_.0
     _.0
     (tofu . _.0)
     (_.0 tofu . _.1)
     (_.0 _.1 tofu . _.2)
     (_.0 _.1 _.2 tofu . _.3)
     (_.0 _.1 _.2 _.3 tofu . _.4)
     (_.0 _.1 _.2 _.3 _.4 tofu . _.5)
     (_.0 _.1 _.2 _.3 _.4 _.5 tofu . _.6)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 tofu . _.7)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 _.7 tofu . _.8)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 _.7 _.8 tofu . _.9))
    )

    (define rember
      (lambda (x l)
        (cond
          ((null? l) '())
          ((eq? (car l) x) (cdr l))
          (else
            (cons (car l)
              (rember x (cdr l)))))))


    (test-check "testc15.tex-16"
    (rember 'peas '(a b peas d peas e))

    `(a b d peas e))

    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((fresh (a)
             (caro l a)
             (== a x))
           (cdro l out))
          ((fresh (res)
             (fresh (d)
               (cdro l d)
               (rembero x d res))
             (fresh (a)
               (caro l a)
               (conso a res out)))))))


    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          ((fresh (res)
             (fresh (d)
               (cdro l d)
               (rembero x d res))
             (fresh (a)
               (caro l a)
               (conso a res out)))))))


    (fresh (res)
      (fresh (d)
        (cdro l d)
        (rembero x d res))
      (fresh (a)
        (caro l a)
        (conso a res out)))


    (fresh (a d res)
      (cdro l d)
      (rembero x d res)
      (caro l a)
      (conso a res out))


    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          (


    (fresh (a d res)
      (conso a d l)
      (rembero x d res)
      (conso a res out))


      ))))


    (test-check "testc15.tex-17"
    (run1 (out)
      (fresh (y)
        (rembero 'peas `(a b ,y d peas e) out)))

    `((a b d peas e)))

    (test-check "testc15.tex-18"
    (run* (out)
      (fresh (y z)
        (rembero y `(a b ,y d ,z e) out)))


    `((b a d _.0 e)
     (a b d _.0 e)
     (a b d _.0 e)
     (a b d _.0 e)
     (a b _.0 d e)
     (a b e d _.0)
     (a b _.0 d _.1 e))
    )

    (test-check "testc15.tex-19"
    (run* (r)
      (fresh (y z)
        (rembero y `(,y d ,z e) `(,y d e))
        (== `(,y ,z) r)))


    `((d d)
     (d d)
     (_.0 _.0)
     (e e))
    )

    (test-check "testc15.tex-20"
    (run13 (w)
      (fresh (y z out)
        (rembero y `(a b ,y d ,z . ,w) out)))


    `(_.0
     _.0
     _.0
     _.0
     _.0
     ()
     (_.0 . _.1)
     (_.0)
     (_.0 _.1 . _.2)
     (_.0 _.1)
     (_.0 _.1 _.2 . _.3)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3 . _.4))
    )

    (define surpriseo
      (lambda (s)
        (rembero s '(a b c) '(a b c))))


    (test-check "testc15.tex-21"
    (run* (r)
      (== 'd r)
      (surpriseo r))

    (list 'd))

    (test-check "testc15.tex-22"
    (run* (r)
      (surpriseo r))

    `(_.0))

    (test-check "testc15.tex-23"
    (run* (r)
      (== 'b r)
      (surpriseo r))

    `(b))

    (define new-append
      (lambda (l s)
        (cond
          ((null? l) s)
          (else (cons (car l)
                  (new-append (cdr l) s))))))


    (test-check "testc16.tex-1"
    (new-append `(a b c) `(d e))

    `(a b c d e))

    (test-check "testc16.tex-2"
    (new-append '(a b c) '())

    `(a b c))

    (test-check "testc16.tex-3"
    (new-append '() '(d e))

    `(d e))

    (test-check "testc16.tex-4"
    (new-append '(d e) 'a)

    `(d e . a))

    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((fresh (a d res)
             (caro l a)
             (cdro l d)
             (appendo d s res)
             (conso a res out))))))


    (test-check "testc16.tex-5"
    (run* (x)
      (appendo
        '(cake)
        '(tastes yummy)
        x))

    (list `(cake tastes yummy)))

    (test-check "testc16.tex-6"
    (run* (x)
      (fresh (y)
        (appendo
          `(cake with ice ,y)
          '(tastes yummy)
          x)))

    (list `(cake with ice _.0 tastes yummy)))

    (test-check "testc16.tex-7"
    (run* (x)
      (fresh (y)
        (appendo
          '(cake with ice cream)
          y
          x)))

    (list `(cake with ice cream . _.0)))

    (test-check "testc16.tex-8"
    (run1 (x)
      (fresh (y)
        (appendo `(cake with ice . ,y) '(d t) x)))

    (list `(cake with ice d t)))

    (test-check "testc16.tex-9"
    (run1 (y)
      (fresh (x)
        (appendo `(cake with ice . ,y) '(d t) x)))


      (list '()))


    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((fresh (a d res)
             (conso a d l)
             (appendo d s res)
             (conso a res out))))))


    (test-check "testc16.tex-10"
    (run5 (x)
      (fresh (y)
        (appendo `(cake with ice . ,y) '(d t) x)))


    `((cake with ice d t)
     (cake with ice _.0 d t)
     (cake with ice _.0 _.1 d t)
     (cake with ice _.0 _.1 _.2 d t)
     (cake with ice _.0 _.1 _.2 _.3 d t))
    )

    (test-check "testc16.tex-11"
    (run5 (y)
      (fresh (x)
        (appendo `(cake with ice . ,y) '(d t) x)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3))
    )

     (define y

    `(_.0 _.1 _.2)

     )


    (test-check "testc16.tex-12"
    `(cake with ice . ,y)


    `(cake with ice . (_.0 _.1 _.2))
    )

    (test-check "testc16.tex-13"
    (run5 (x)
      (fresh (y)
        (appendo
          `(cake with ice . ,y)
          `(d t . ,y)
          x)))


    `((cake with ice d t)
     (cake with ice _.0 d t _.0)
     (cake with ice _.0 _.1 d t _.0 _.1)
     (cake with ice _.0 _.1 _.2 d t _.0 _.1 _.2)
     (cake with ice _.0 _.1 _.2 _.3 d t _.0 _.1 _.2 _.3))
    )

    (test-check "testc16.tex-14"
    (run* (x)
      (fresh (z)
        (appendo
          `(cake with ice cream)
          `(d t . ,z)
          x)))


    `((cake with ice cream d t . _.0))
    )

    (test-check "testc16.tex-15"
    (run6 (x)
      (fresh (y)
        (appendo x y `(cake with ice d t))))


    `(()
     (cake)
     (cake with)
     (cake with ice)
     (cake with ice d)
     (cake with ice d t))
    )

    (test-check "testc16.tex-16"
    (run6 (y)
      (fresh (x)
        (appendo x y `(cake with ice d t))))


    `((cake with ice d t)
     (with ice d t)
     (ice d t)
     (d t)
     (t)
     ())
    )

      (define appendxyquestion
        (lambda ()


    (run6 (r)
      (fresh (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))


      ))
    (define appendxyanswer


    `((() (cake with ice d t))
     ((cake) (with ice d t))
     ((cake with) (ice d t))
     ((cake with ice) (d t))
     ((cake with ice d) (t))
     ((cake with ice d t) ()))


      )
      (test-check "appendxy"
        (appendxyquestion)
        appendxyanswer)

    (define e (make-engine (lambda ()
    (run7 (r)
      (fresh (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))
    )))
    (printf "Testing testc16.tex-17  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc16.tex-17 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((fresh (a d res)
             (conso a d l)
             (conso a res out)
             (appendo d s res))))))


    (test-check "testc16.tex-18"
    (run7 (r)
      (fresh (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))


      appendxyanswer)


    (test-check "testc16.tex-19"
    (run7 (x)
      (fresh (y z)
        (appendo x y z)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3)
     (_.0 _.1 _.2 _.3 _.4)
     (_.0 _.1 _.2 _.3 _.4 _.5))
    )

    (test-check "testc16.tex-20"
    (run7 (y)
      (fresh (x z)
        (appendo x y z)))


    `(_.0
     _.0
     _.0
     _.0
     _.0
     _.0
     _.0)
    )

    (test-check "testc16.tex-21"
    (run7 (z)
      (fresh (x y)
        (appendo x y z)))


    `(_.0
     (_.0 . _.1)
     (_.0 _.1 . _.2)
     (_.0 _.1 _.2 . _.3)
     (_.0 _.1 _.2 _.3 . _.4)
     (_.0 _.1 _.2 _.3 _.4 . _.5)
     (_.0 _.1 _.2 _.3 _.4 _.5 . _.6))
    )

    (test-check "testc16.tex-22"
    (run7 (r)
      (fresh (x y z)
        (appendo x y z)
        (== `(,x ,y ,z) r)))


    `((() _.0 _.0)
     ((_.0) _.1 (_.0 . _.1))
     ((_.0 _.1) _.2 (_.0 _.1 . _.2))
     ((_.0 _.1 _.2) _.3 (_.0 _.1 _.2 . _.3))
     ((_.0 _.1 _.2 _.3) _.4 (_.0 _.1 _.2 _.3 . _.4))
     ((_.0 _.1 _.2 _.3 _.4) _.5 (_.0 _.1 _.2 _.3 _.4 . _.5))
     ((_.0 _.1 _.2 _.3 _.4 _.5) _.6 (_.0 _.1 _.2 _.3 _.4 _.5 . _.6)))
    )

    (define swappendo
      (lambda (l s out)
        (conde
          ((fresh (a d res)
             (conso a d l)
             (conso a res out)
             (swappendo d s res)))
          ((nullo l) (== s out)))))


    (test-check "testc16.tex-23"
    (run7 (r)
      (fresh (x y z)
        (swappendo x y z)
        (== `(,x ,y ,z) r)))


    `((() _.0 _.0)
     ((_.0) _.1 (_.0 . _.1))
     ((_.0 _.1) _.2 (_.0 _.1 . _.2))
     ((_.0 _.1 _.2) _.3 (_.0 _.1 _.2 . _.3))
     ((_.0 _.1 _.2 _.3) _.4 (_.0 _.1 _.2 _.3 . _.4))
     ((_.0 _.1 _.2 _.3 _.4) _.5 (_.0 _.1 _.2 _.3 _.4 . _.5))
     ((_.0 _.1 _.2 _.3 _.4 _.5) _.6 (_.0 _.1 _.2 _.3 _.4 _.5 . _.6)))
    )

    (define unwrap
      (lambda (x)
        (cond
          ((pair? x) (unwrap (car x)))
          (else x))))


    (test-check "testc16.tex-24"
    (unwrap '((((pizza)))))

    `pizza)

    (test-check "testc16.tex-25"
    (unwrap '((((pizza pie) with)) extra cheese))

    `pizza)

    (define unwrapo
      (lambda (x out)
        (conde
          ((pairo x)
           (fresh (a)
             (caro x a)
             (unwrapo a out)))
          ((== x out)))))


    (test-check "testc16.tex-26"
    (run* (x)
      (unwrapo '(((pizza))) x))


    `((((pizza)))
     ((pizza))
     (pizza)
     pizza)
      )

    (test-check "testc16.tex-27"
    (run1 (x)
      (unwrapo x 'pizza))


    `(pizza)
    )

    (test-check "testc16.tex-28"
    (run1 (x)
      (unwrapo `((,x)) 'pizza))


    `(pizza)
    )

    (test-check "testc16.tex-29"
    (run5 (x)
      (unwrapo x 'pizza))


    `(pizza
     (pizza . _.0)
     ((pizza . _.0) . _.1)
     (((pizza . _.0) . _.1) . _.2)
     ((((pizza . _.0) . _.1) . _.2) . _.3))
    )

    (test-check "testc16.tex-30"
    (run5 (x)
      (unwrapo x '((pizza))))


    `(((pizza))
     (((pizza)) . _.0)
     ((((pizza)) . _.0) . _.1)
     (((((pizza)) . _.0) . _.1) . _.2)
     ((((((pizza)) . _.0) . _.1) . _.2) . _.3))
    )

    (test-check "testc16.tex-31"
    (run5 (x)
      (unwrapo `((,x)) 'pizza))


    `(pizza
     (pizza . _.0)
     ((pizza . _.0) . _.1)
     (((pizza . _.0) . _.1) . _.2)
     ((((pizza . _.0) . _.1) . _.2) . _.3))
    )

    (define flatten
      (lambda (s)
        (cond
          ((null? s) '())
          ((pair? s)
           (new-append
             (flatten (car s))
             (flatten (cdr s))))
          (else (cons s '())))))


    (test-check "testc16.tex-32"
    (flatten '((a b) c))

    `(a b c))

    (define flatteno
      (lambda (s out)
        (conde
          ((nullo s) (== '() out))
          ((pairo s)
           (fresh (a d res-a res-d)
             (conso a d s)
             (flatteno a res-a)
             (flatteno d res-d)
             (appendo res-a res-d out)))
          ((conso s '() out)))))


    (test-check "testc16.tex-33"
    (run10 (x)
      (flatteno '((a b) c) x))


    `((((a b) c))
     ((a b) (c))
     ((a b) c)
     (a (b) (c))
     ((a b) c ())
     (a (b) c)
     (a (b) c ())
     (a b (c))
     (a b () (c))
     (a b c))
    )

    (test-check "testc16.tex-34"
    (run10 (x)
      (flatteno '(a (b c)) x))


    `(((a (b c)))
     (a ((b c)))
     (a (b c))
     (a (b c) ())
     (a b (c))
     (a b (c) ())
     (a b c)
     (a b c ())
     (a b c ())
     (a b c () ()))
    )

    (test-check "testc16.tex-35"
    (run* (x)
      (flatteno '(a) x))


    `(((a))
     (a)
     (a ()))
    )

    (test-check "testc16.tex-36"
    (run* (x)
      (flatteno '((a)) x))


    `((((a)))
     ((a))
     ((a) ())
     (a)
     (a ())
     (a ())
     (a () ()))
    )

    (test-check "testc16.tex-37"
    (run* (x)
      (flatteno '(((a))) x))


    `(((((a))))
     (((a)))
     (((a)) ())
     ((a))
     ((a) ())
     ((a) ())
     ((a) () ())
     (a)
     (a ())
     (a ())
     (a () ())
     (a ())
     (a () ())
     (a () ())
     (a () () ()))
    )

      (define flattenogrumblequestion
        (lambda ()


    (run* (x)
      (flatteno '((a b) c) x))


      ))
    (define flattenogrumbleanswer


    `((((a b) c))
     ((a b) (c))
     ((a b) c)
     (a (b) (c))
     ((a b) c ())
     (a (b) c)
     (a (b) c ())
     (a b (c))
     (a b () (c))
     (a b c)
     (a b c ())
     (a b () c)
     (a b () c ()))


      )
      (test-check "flattenogrumble"
        (flattenogrumblequestion)
        flattenogrumbleanswer)

    (define e (make-engine (lambda ()
    (run* (x)
      (flatteno x '(a b c)))
    )))
    (printf "Testing testc16.tex-38  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc16.tex-38 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc16.tex-39"
    (length
      (run* (x)
        (flatteno '((((a (((b))) c))) d) x)))

    574)

    (define strangeo
      (fresh ()
        strangeo))

    (define e (make-engine (lambda ()
    (run1 (x)
      strangeo)
    )))
    (printf "Testing testc17.tex-1  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-1 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-2"
    (run1 (q)
      (conde
        (strangeo)
        (succeed)))

    `(_.0))

    (define strangero
      (conde
        (strangero (conde
                     (strangero)
                     (succeed)))
        (succeed)))


    (test-check "testc17.tex-3"
    (run5 (q)
      strangero)

    `(_.0 _.0 _.0 _.0 _.0))

    (define strangesto
      (lambda (x y)
        (conde
          ((strangesto y x) (== #f y))
          ((== #f x)))))


    (test-check "testc17.tex-4"
    (run5 (q)
      (fresh (x y)
        (strangesto x y)
        (== `(,x ,y) q)))

    `((#f _.0) (_.0 #f) (#f #f) (#f #f) (#f #f)))

    (define any*
      (lambda (g)
        (conde
          (g)
          ((any* g)))))


    (define never (any* fail))

    (define e (make-engine (lambda ()
    (run1 (q)
      never
      (== #t q))
    )))
    (printf "Testing testc17.tex-5  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-5 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (run1 (q)
      fail
      never)


    (define always (any* succeed))


    (test-check "testc17.tex-6"
    (run1 (q)
      always
      (== #t q))

    (list #t))
    (define e (make-engine (lambda ()
    (run* (q)
      always
      (== #t q))
    )))
    (printf "Testing testc17.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-8"
    (run5 (q)
      always
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-9"
    (run5 (q)
      (== #t q)
      always)

    `(#t #t #t #t #t))

    (define salo
      (lambda (g)
        (conde
          (succeed)
          (g))))


    (test-check "testc17.tex-10"
    (run1 (q)
      (salo always)
      (== #t q))

    `(#t))

    (test-check "testc17.tex-11"
    (run1 (q)
      (salo never)
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run* (q)
      (salo never)
      (== #t q))
    )))
    (printf "Testing testc17.tex-12  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-12 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (salo never)
      fail
      (== #t q))
    )))
    (printf "Testing testc17.tex-13  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-13 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      always
      fail
      (== #t q))
    )))
    (printf "Testing testc17.tex-14  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-14 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-15"
    (run1 (q)
      (conde
        ((== #f q) always)
        ((== #t q)))
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run2 (q)
      (conde
        ((== #f q) always)
        ((== #t q)))
      (== #t q))
    )))
    (printf "Testing testc17.tex-16  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-16 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-17"
    (run5 (q)
      (conde
        ((== #f q) always)
        ((any* (== #t q))))
      (== #t q))


    `(#t #t #t #t #t)
    )

    (test-check "testc17.tex-18"
    (run5 (q)
      (conde
        (always)
        (never))
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-19"
    (run1 (q)
      (fresh ()
        (conde
          ((== #f q))
          ((== #t q)))
        always)
      (== #t q))

    `(#t))

    (test-check "testc17.tex-20"
    (run5 (q)
      (fresh ()
        (conde
          ((== #f q))
          ((== #t q)))
        always)
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-21"
    (run5 (q)
      (fresh ()
        (conde
          ((== #t q))
          ((== #f q)))
        always)
      (== #t q))

    `(#t #t #t #t #t))

    (define bit-xoro
      (lambda (x y r)
        (conde
          ((== 0 x) (== 0 y) (== 0 r))
          ((== 0 x) (== 1 y) (== 1 r))
          ((== 1 x) (== 0 y) (== 1 r))
          ((== 1 x) (== 1 y) (== 0 r)))))


    (test-check "testc20.tex-1"
    (run* (s)
      (fresh (x y)
        (bit-xoro x y 0)
        (== `(,x ,y) s)))


    `((0 0)
     (1 1))
    )

    (test-check "testc20.tex-2"
    (run* (s)
      (fresh (x y)
        (bit-xoro x y 1)
        (== `(,x ,y) s)))


    `((0 1)
     (1 0))
    )

    (test-check "testc20.tex-3"
    (run* (s)
      (fresh (x y r)
        (bit-xoro x y r)
        (== `(,x ,y ,r) s)))


    `((0 0 0)
     (0 1 1)
     (1 0 1)
     (1 1 0))
    )

    (define bit-ando
      (lambda (x y r)
        (conde
          ((== 0 x) (== 0 y) (== 0 r))
          ((== 1 x) (== 0 y) (== 0 r))
          ((== 0 x) (== 1 y) (== 0 r))
          ((== 1 x) (== 1 y) (== 1 r)))))


    (test-check "testc20.tex-4"
    (run* (s)
      (fresh (x y)
        (bit-ando x y 1)
        (== `(,x ,y) s)))


    `((1 1))
    )

    (define half-addero
      (lambda (x y r c)
        (fresh ()
          (bit-xoro x y r)
          (bit-ando x y c))))


    (test-check "testc20.tex-5"
    (run* (r)
      (half-addero 1 1 r 1))

    (list 0))

    (test-check "testc20.tex-6"
    (run* (s)
      (fresh (x y r c)
        (half-addero x y r c)
        (== `(,x ,y ,r ,c) s)))


    `((0 0 0 0)
     (0 1 1 0)
     (1 0 1 0)
     (1 1 0 1))
      )

    (define full-addero
      (lambda (b x y r c)
        (fresh (w xy wz)
          (half-addero x y w xy)
          (half-addero w b r wz)
          (bit-xoro xy wz c))))


    (test-check "testc20.tex-7"
    (run* (s)
      (fresh (r c)
        (full-addero 0 1 1 r c)
        (== `(,r ,c) s)))

    (list `(0 1)))

    (define full-addero
      (lambda (b x y r c)
        (conde
          ((== 0 b) (== 0 x) (== 0 y) (== 0 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 0 b) (== 1 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 1 x) (== 0 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 0 x) (== 1 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 1 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 1 b) (== 1 x) (== 1 y) (== 1 r) (== 1 c)))))


    (test-check "testc20.tex-8"
    (run* (s)
      (fresh (r c)
        (full-addero 1 1 1 r c)
        (== `(,r ,c) s)))

    (list `(1 1)))

    (test-check "testc20.tex-9"
    (run* (s)
      (fresh (b x y r c)
        (full-addero b x y r c)
        (== `(,b ,x ,y ,r ,c) s)))


    `((0 0 0 0 0)
     (1 0 0 1 0)
     (0 1 0 1 0)
     (1 1 0 0 1)
     (0 0 1 1 0)
     (1 0 1 0 1)
     (0 1 1 0 1)
     (1 1 1 1 1))
    )


    (define build-num
      (lambda (n)
        (cond
          ((zero? n) '())
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2)))))))


    (test-check "testc20.tex-10" `(1 0 1)

        (build-num

    5

        ))


    (test-check "testc20.tex-11" `(1 1 1)

        (build-num

    7

        ))

    (test-check "nine" (build-num
    9

        )

    `(1 0 0 1)

        )

    (test-check "six" (build-num
    6

        )

    `(0 1 1)

        )

    (test-check "nineteen" (build-num
    19

        )

    `(1 1 0 0 1)

        )

    (test-check "biggie" (build-num
    17290

        )

    `(0 1 0 1 0 0 0 1 1 1 0 0 0 0 1)

        )


    (test-check "testc20.tex-12" (build-num 0)
    `())

    (test-check "testc20.tex-13" (build-num 36)
    `(0 0 1 0 0 1))

    (test-check "testc20.tex-14" (build-num 19)
    `(1 1 0 0 1))


    (define build-num
      (lambda (n)
        (cond
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2))))
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((zero? n) '()))))


    (define poso
      (lambda (n)
        (fresh (a d)
          (== `(,a . ,d) n))))


    (test-check "testc20.tex-15"
    (run* (q)
      (poso '(0 1 1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-16"
    (run* (q)
      (poso '(1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-17"
    (run* (q)
      (poso '())
      (== #t q))

    `())

    (test-check "testc20.tex-18"
    (run* (r)
      (poso r))

    (list `(_.0 . _.1)))

    (define >1o
      (lambda (n)
        (fresh (a ad dd)
          (== `(,a ,ad . ,dd) n))))


    (test-check "testc20.tex-19"
    (run* (q)
      (>1o '(0 1 1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-20"
    (run* (q)
      (>1o '(0 1))
      (== #t q))

    `(#t))

    (test-check "testc20.tex-21"
    (run* (q)
      (>1o '(1))
      (== #t q))

    `())

    (test-check "testc20.tex-22"
    (run* (q)
      (>1o '())
      (== #t q))

    `())

    (test-check "testc20.tex-23"
    (run* (r)
      (>1o r))

    (list
    `(_.0 _.1 . _.2)
    ))


    (define addero
      (lambda (d n m r)
        (conde
          ((== 0 d) (== '() m) (== n r))
          ((== 0 d) (== '() n) (== m r)
           (poso m))
          ((== 1 d) (== '() m)
           (addero 0 n '(1) r))
          ((== 1 d) (== '() n) (poso m)
           (addero 0 '(1) m r))
          ((== '(1) n) (== '(1) m)
           (fresh (a c)
             (== `(,a ,c) r)
             (full-addero d 1 1 a c)))
          ((== '(1) n) (gen-addero d n m r))
          ((== '(1) m) (>1o n) (>1o r)
           (addero d '(1) n r))
          ((>1o n) (gen-addero d n m r)))))

    (define gen-addero
      (lambda (d n m r)
        (fresh (a b c e x y z)
          (== `(,a . ,x) n)
          (== `(,b . ,y) m) (poso y)
          (== `(,c . ,z) r) (poso z)
          (full-addero d a b c e)
          (addero e x y z))))


    (test-check "testc20.tex-24"
    (run3 (s)
      (fresh (x y r)
        (addero 0 x y r)
        (== `(,x ,y ,r) s)))


    `((_.0 () _.0)
     (() (_.0 . _.1) (_.0 . _.1))
     ((1) (1) (0 1)))
     )

    (test-check "testc20.tex-25"
    (run22 (s)
      (fresh (x y r)
        (addero 0 x y r)
        (== `(,x ,y ,r) s)))


    `((_.0 () _.0)
     (() (_.0 . _.1) (_.0 . _.1))
     ((1) (1) (0 1))
     ((1) (0 _.0 . _.1) (1 _.0 . _.1))
     ((1) (1 1) (0 0 1))
     ((0 _.0 . _.1) (1) (1 _.0 . _.1))
     ((1) (1 0 _.0 . _.1) (0 1 _.0 . _.1))
     ((0 1) (0 1) (0 0 1))
     ((1) (1 1 1) (0 0 0 1))
     ((1 1) (1) (0 0 1))
     ((1) (1 1 0 _.0 . _.1) (0 0 1 _.0 . _.1))
     ((1 1) (0 1) (1 0 1))
     ((1) (1 1 1 1) (0 0 0 0 1))
     ((1 0 _.0 . _.1) (1) (0 1 _.0 . _.1))
     ((1) (1 1 1 0 _.0 . _.1) (0 0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1) (0 0 0 0 0 1))
     ((1 1 1) (1) (0 0 0 1))
     ((1) (1 1 1 1 0 _.0 . _.1) (0 0 0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1 1) (0 0 0 0 0 0 1))
     ((0 1) (1 1) (1 0 1))
     ((1 1 0 _.0 . _.1) (1) (0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1 0 _.0 . _.1) (0 0 0 0 0 1 _.0 . _.1)))
    )



    (test-check "testc20.tex-26"
    (run* (s)
      (gen-addero 1 '(0 1 1) '(1 1) s))

    (list `(0 1 0 1)))

    (test-check "testc20.tex-27"
    (run* (s)
      (fresh (x y)
        (addero 0 x y '(1 0 1))
        (== `(,x ,y) s)))


    `(((1 0 1) ())
     (() (1 0 1))
     ((1) (0 0 1))
     ((0 0 1) (1))
     ((1 1) (0 1))
     ((0 1) (1 1)))
    )

    (run* (s)
      (fresh (x y)
        (addero 0 x y '(1 0 1))
        (== `(,x ,y) s)))


    (define pluso
      (lambda (n m k)
        (addero 0 n m k)))


    (run* (s)
      (fresh (x y)
        (pluso x y '(1 0 1))
        (== `(,x ,y) s)))


    (test-check "testc20.tex-28"
    (run* (s)
      (fresh (x y)
        (pluso x y '(1 0 1))
        (== `(,x ,y) s)))


    `(((1 0 1) ())
     (() (1 0 1))
     ((1) (0 0 1))
     ((0 0 1) (1))
     ((1 1) (0 1))
     ((0 1) (1 1)))
    )

    (define minuso
      (lambda (n m k)
        (pluso m k n)))


    (test-check "testc20.tex-29"
    (run* (q)
      (minuso '(0 0 0 1) '(1 0 1) q))


    `((1 1))
    )

    (test-check "testc20.tex-30"
    (run* (q)
      (minuso '(0 1 1) '(0 1 1) q))


    `(())
    )

    (test-check "testc20.tex-31"
    (run* (q)
      (minuso '(0 1 1) '(0 0 0 1) q))


    `()
    )


    (define *o
      (lambda (n m p)
        (conde
          ((== '() n) (== '() p))
          ((poso n) (== '() m) (== '() p))
          ((== '(1) n) (poso m) (== m p))
          ((>1o n) (== '(1) m) (== n p))
          ((fresh (x z)
             (== `(0 . ,x) n) (poso x)
             (== `(0 . ,z) p) (poso z)
             (>1o m)
             (*o x m z)))
          ((fresh (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(0 . ,y) m) (poso y)
             (*o m n p)))
          ((fresh (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(1 . ,y) m) (poso y)
             (odd-*o x n m p))))))

    (define odd-*o
      (lambda (x n m p)
        (fresh (q)
          (bound-*o q p n m)
          (*o x m q)
          (pluso `(0 . ,q) m p))))

    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((fresh (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))


    (test-check "testc21.tex-1"
    (run34 (t)
      (fresh (x y r)
        (*o x y r)
        (== `(,x ,y ,r) t)))


    `((() _.0 ())
     ((_.0 . _.1) () ())
     ((1) (_.0 . _.1) (_.0 . _.1))
     ((_.0 _.1 . _.2) (1) (_.0 _.1 . _.2))
     ((0 1) (_.0 _.1 . _.2) (0 _.0 _.1 . _.2))
     ((0 0 1) (_.0 _.1 . _.2) (0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 1) (0 1 _.0 . _.1))
     ((0 0 0 1) (_.0 _.1 . _.2) (0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 1) (0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 1) (0 0 1 _.0 . _.1))
     ((0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 1) (0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 1) (0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 1) (0 0 0 1 _.0 . _.1))
     ((1 1) (1 1) (1 0 0 1))
     ((0 0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 0 0 1 _.0 . _.1) (0 1) (0 0 0 0 1 _.0 . _.1))
     ((1 1) (1 0 1) (1 1 1 1))
     ((0 1 1) (1 1) (0 1 0 0 1))
     ((1 1) (1 1 1) (1 0 1 0 1))
     ((1 1) (0 1 1) (0 1 0 0 1))
     ((0 0 0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 0 0 1 _.0 . _.1) (0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((1 0 1) (1 1) (1 1 1 1))
     ((0 0 0 0 1 _.0 . _.1) (0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 1 1) (1 0 1) (0 1 1 1 1))
     ((0 0 1 1) (1 1) (0 0 1 0 0 1))
     ((1 1) (1 0 0 1) (1 1 0 1 1)))
    )

    (test-check "testc21.tex-2"
    (run* (p)
      (*o '(0 1) '(0 0 1) p))

    (list `(0 0 0 1)))



    (define bound-*o
      (lambda (q p n m)
        succeed))


    (test-check "testc21.tex-3"
    (run1 (t)
      (fresh (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))

    (list `((1) (1))))
    (define e (make-engine (lambda ()
    (run2 (t)
      (fresh (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))
    )))
    (printf "Testing testc21.tex-4  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-4 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((fresh (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))



    (test-check "testc21.tex-5"
    (run2 (t)
      (fresh (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))

    `(((1) (1))))

    (test-check "testc21.tex-6"
    (run* (p)
      (*o '(1 1 1) '(1 1 1 1 1 1) p))

    (list `(1 0 0 1 1 1 0 1 1)))

    (define =lo
      (lambda (n m)
        (conde
          ((== '() n) (== '() m))
          ((== '(1) n) (== '(1) m))
          ((fresh (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (=lo x y))))))


    (test-check "testc21.tex-7"
    (run* (t)
      (fresh (w x y)
        (=lo `(1 ,w ,x . ,y) '(0 1 1 0 1))
        (== `(,w ,x ,y) t)))

    (list `(_.0 _.1 (_.2 1))))

    (test-check "testc21.tex-8"
    (run* (b)
      (=lo '(1) `(,b)))

    (list 1))

    (test-check "testc21.tex-9"
    (run* (n)
      (=lo `(1 0 1 . ,n) '(0 1 1 0 1)))

    (list
    `(_.0 1)
    ))

    (test-check "testc21.tex-10"
    (run5 (t)
      (fresh (y z)
        (=lo `(1 . ,y) `(1 . ,z))
        (== `(,y ,z) t)))


    `((() ())
     ((1) (1))
     ((_.0 1) (_.1 1))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1)))
    )

    (test-check "testc21.tex-11"
    (run5 (t)
      (fresh (y z)
        (=lo `(1 . ,y) `(0 . ,z))
        (== `(,y ,z) t)))


    `(((1) (1))
     ((_.0 1) (_.1 1))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 1)))
    )

    (test-check "testc21.tex-12"
    (run5 (t)
      (fresh (y z)
        (=lo `(1 . ,y) `(0 1 1 0 1 . ,z))
        (== `(,y ,z) t)))


    `(((_.0 _.1 _.2 1) ())
     ((_.0 _.1 _.2 _.3 1) (1))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 1))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 1))
     ((_.0 _.1 _.2 _.3 _.4 _.5 _.6 1) (_.7 _.8 _.9 1)))
    )

    (define <lo
      (lambda (n m)
        (conde
          ((== '() n) (poso m))
          ((== '(1) n) (>1o m))
          ((fresh (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (<lo x y))))))


    (test-check "testc21.tex-13"
    (run8 (t)
      (fresh (y z)
        (<lo `(1 . ,y) `(0 1 1 0 1 . ,z))
        (== `(,y ,z) t)))


    `((() _.0)
     ((1) _.0)
     ((_.0 1) _.1)
     ((_.0 _.1 1) _.2)
     ((_.0 _.1 _.2 1) (_.3 . _.4))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 . _.6))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 . _.8))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 _.8 _.9 . _.10)))
    )
    (define e (make-engine (lambda ()
    (run1 (n)
      (<lo n n))
    )))
    (printf "Testing testc21.tex-14  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-14 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define <=lo
      (lambda (n m)
        (conde
          ((=lo n m))
          ((<lo n m)))))


    (test-check "testc21.tex-15"
    (run8 (t)
      (fresh (n m)
        (<=lo n m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (1))
     (() (_.0 . _.1))
     ((1) (_.0 _.1 . _.2))
     ((_.0 1) (_.1 1))
     ((_.0 1) (_.1 _.2 _.3 . _.4))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1)))
    )

    (test-check "testc21.tex-16"
    (run1 (t)
      (fresh (n m)
        (<=lo n m)
        (*o n '(0 1) m)
        (== `(,n ,m) t)))

    (list `(() ())))

    (test-check "testc21.tex-17"
    (run10 (t)
      (fresh (n m)
        (<=lo n m)
        (*o n '(0 1) m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (0 1))
     ((0 1) (0 0 1))
     ((1 1) (0 1 1))
     ((1 _.0 1) (0 1 _.0 1))
     ((0 0 1) (0 0 0 1))
     ((0 1 1) (0 0 1 1))
     ((1 _.0 _.1 1) (0 1 _.0 _.1 1))
     ((0 1 _.0 1) (0 0 1 _.0 1))
     ((0 0 0 1) (0 0 0 0 1)))
    )

    (test-check "testc21.tex-18"
    (run15 (t)
      (fresh (n m)
        (<=lo n m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (1))
     (() (_.0 . _.1))
     ((1) (_.0 _.1 . _.2))
     ((_.0 1) (_.1 1))
     ((_.0 1) (_.1 _.2 _.3 . _.4))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1))
     ((_.0 _.1 1) (_.2 _.3 _.4 _.5 . _.6))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 _.6 _.7 . _.8))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 _.8 _.9 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 _.8 _.9 . _.10))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 _.8 _.9 _.10 _.11 1))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 _.8 _.9 _.10 _.11 . _.12)))
    )

    (define <o
      (lambda (n m)
        (conde
          ((<lo n m))
          ((=lo n m)
           (fresh (x)
             (poso x)
             (pluso n x m))))))


    (define <=o
      (lambda (n m)
        (conde
          ((== n m))
          ((<o n m)))))


    (test-check "testc21.tex-19"
    (run* (q)
      (<o '(1 0 1) '(1 1 1))
      (== #t q))

    (list #t))

    (test-check "testc21.tex-20"
    (run* (q)
      (<o '(1 1 1) '(1 0 1))
      (== #t q))

    `())

    (test-check "testc21.tex-21"
    (run* (q)
      (<o '(1 0 1) '(1 0 1))
      (== #t q))

    `())

    (test-check "lessthanequalo-1"
      (run* (q)
        (<=o '(1 0 1) '(1 0 1))
        (== #t q))

    `(#t))

    (test-check "testc21.tex-22"
    (run6 (n)
      (<o n `(1 0 1)))


    `(() (1) (_.0 1) (0 0 1))
    )

    (test-check "testc21.tex-23"
    (run6 (m)
      (<o `(1 0 1) m))


    `((_.0 _.1 _.2 _.3 . _.4) (0 1 1) (1 1 1))
    )
    (define e (make-engine (lambda ()
    (run* (n)
      (<o n n))
    )))
    (printf "Testing testc21.tex-24  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-24 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (fresh (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((fresh (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((fresh (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((fresh (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((fresh (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((fresh (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))


    (test-check "testc21.tex-25"
    (run6 (t)
      (fresh (n m q r)
        (/o n m q r)
        (== `(,n ,m ,q ,r) t)))


    `((() (_.0 . _.1) () ())
     ((1) (_.0 _.1 . _.2) () (1))
     ((_.0 1) (_.1 _.2 _.3 . _.4) () (_.0 1))
     ((_.0 _.1 1) (_.2 _.3 _.4 _.5 . _.6) () (_.0 _.1 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 _.6 _.7 . _.8) () (_.0 _.1 _.2 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 _.8 _.9 . _.10) () (_.0 _.1 _.2 _.3 1)))
    )





    (define /o
      (lambda (n m q r)
        (conde
          ((== '() q) (== n r) (<o n m))
          ((== '(1) q) (== '() r) (== n m)
           (<o r m))
          ((<o m n) (<o r m)
           (fresh (mq)
             (<=lo mq n)
             (*o m q mq)
             (pluso mq r n))))))



      (define /otest1
        (lambda ()


    (run3 (t)
      (fresh (y z)
        (/o `(1 0 . ,y) '(0 1) z '())
        (== `(,y ,z) t)))


      ))
    (define e (make-engine /otest1))
    (printf "Testing testc23.tex-/otest1  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-/otest1 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (fresh (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((fresh (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((fresh (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((fresh (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((fresh (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((fresh (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))


    (define logo
     (lambda (n b q r)
       (conde
         ((== '(1) n) (poso b) (== '() q) (== '() r))
         ((== '() q) (<o n b) (pluso r '(1) n))
         ((== '(1) q) (>1o b) (=lo n b) (pluso r b n))
         ((== '(1) b) (poso q) (pluso r '(1) n))
         ((== '() b) (poso q) (== r n))
         ((== '(0 1) b)
          (fresh (a ad dd)
            (poso dd)
            (== `(,a ,ad . ,dd) n)
            (exp2 n '() q)
            (fresh (s)
              (splito n dd r s))))
         ((fresh (a ad add ddd)
            (conde
              ((== '(1 1) b))
              ((== `(,a ,ad ,add . ,ddd) b))))
          (<lo b n)
          (fresh (bw1 bw nw nw1 ql1 ql s)
            (exp2 b '() bw1)
            (pluso bw1 '(1) bw)
            (<lo q n)
            (fresh (q1 bwq1)
              (pluso q '(1) q1)
              (*o bw q1 bwq1)
              (<o nw1 bwq1))
              (exp2 n '() nw1)
              (pluso nw1 '(1) nw)
              (/o nw bw ql1 s)
              (pluso ql '(1) ql1)
              (<=lo ql q)
              (fresh (bql qh s qdh qd)
                (repeated-mul b ql bql)
                (/o nw bw1 qh s)
                (pluso ql qdh qh)
                (pluso ql qd q)
                (<=o qd qdh)
                (fresh (bqd bq1 bq)
                  (repeated-mul b qd bqd)
                  (*o bql bqd bq)
                  (*o b bq bq1)
                  (pluso bq r n)
                  (<o n bq1))))))))


    (define exp2
      (lambda (n b q)
        (conde
          ((== '(1) n) (== '() q))
          ((>1o n) (== '(1) q)
           (fresh (s)
             (splito n b s '(1))))
          ((fresh (q1 b2)
             (== `(0 . ,q1) q)
             (poso q1)
             (<lo b n)
             (appendo b `(1 . ,b) b2)
             (exp2 n b2 q1)))
          ((fresh (q1 nh b2 s)
             (== `(1 . ,q1) q)
             (poso q1)
             (poso nh)
             (splito n b s nh)
             (appendo b `(1 . ,b) b2)
             (exp2 nh b2 q1))))))


    (define repeated-mul
      (lambda (n q nq)
        (conde
          ((poso n) (== '() q) (== '(1) nq))
          ((== '(1) q) (== n nq))
          ((>1o q)
           (fresh (q1 nq1)
             (pluso q1 '(1) q)
             (repeated-mul n q1 nq1)
             (*o nq1 n nq))))))


    (test-check "testc21.tex-26"
    (run* (r)
      (logo '(0 1 1 1) '(0 1) '(1 1) r))

    (list `(0 1 1)))


     '(printf "This next test takes several minutes to run!\n")


    '(test-check "testc21.tex-27"
    (run9 (s)
      (fresh (b q r)
        (logo '(0 0 1 0 0 0 1) b q r)
        (>1o q)
        (== `(,b ,q ,r) s)))


    `((() (_.0 _.1 . _.2) (0 0 1 0 0 0 1))
     ((1) (_.0  _.1 . _.2) (1 1 0 0 0 0 1))
     ((0 1) (0 1 1) (0 0 1))
     ((1 1) (1 1) (1 0 0 1 0 1))
     ((0 0 1) (1 1) (0 0 1))
     ((0 0 0 1) (0 1) (0 0 1))
     ((1 0 1) (0 1) (1 1 0 1 0 1))
     ((0 1 1) (0 1) (0 0 0 0 0 1))
     ((1 1 1) (0 1) (1 1 0 0 1)))
    )

    (define expo
      (lambda (b q n)
        (logo n b q '())))


    '(test-check "testc21.tex-28"
    (run* (t)
      (expo '(1 1) '(1 0 1) t))

    (list `(1 1 0 0 1 1 1 1)))

     (define u (var 'u))

     (define v (var 'v))

     (define w (var 'w))


     (define x (var 'x))

     (define y (var 'y))

     (define z (var 'z))


    (test-check "testc22.tex-1"
    (rhs `(,z . b))

    'b)

    (test-check "testc22.tex-2"
    (rhs `(,z . ,w))

    w)

    (test-check "testc22.tex-3"
    (rhs `(,z . (,x e ,y)))

    `(,x e ,y))


    (test-check "testc22.tex-4"
    (walk z `((,z . a) (,x . ,w) (,y . ,z)))

    'a)

    (test-check "testc22.tex-5"
    (walk y `((,z . a) (,x . ,w) (,y . ,z)))

    'a)

    (test-check "testc22.tex-6"
    (walk x `((,z . a) (,x . ,w) (,y . ,z)))

    w)

    (test-check "testc22.tex-7"
    (walk w `((,z . a) (,x . ,w) (,y . ,z)))

    w)

    (test-check "testc22.tex-8"
    (walk u `((,x . b) (,w . (,x e ,x)) (,u . ,w)))

    `(,x e ,x))


    (test-check "testc22.tex-9"
    (walk y (ext-s x 'e `((,z . ,x) (,y . ,z))))

    'e)

    (test-check "testc22.tex-10"
    (walk y `((,x . e)))

    y)

    (test-check "testc22.tex-11"
    (walk x `((,y . ,z) (,x . ,y)))

    z)

    (test-check "testc22.tex-12"
    (walk x (ext-s y z `((,x . ,y))))

    z)

    (test-check "testc22.tex-13"
    (walk x (ext-s z 'b `((,y . ,z) (,x . ,y))))

    'b)

    (test-check "testc22.tex-14"
    (walk x (ext-s z w `((,y . ,z) (,x . ,y))))

    w)


    (test-check "testc22.tex-15"
    (occurs-check z u
      `((,x . (a ,y)) (,w . (,x e ,x)) (,u . ,w) (,y . (,z))))

    #t)



    (test-check "testc22.tex-16"
    (walk* x
      `((,y . (a ,z c)) (,x . ,y) (,z . a)))

    `(a a c))

    (test-check "testc22.tex-17"
    (walk* x
      `((,y . (,z ,w c)) (,x . ,y) (,z . a)))

    `(a ,w c))

    (test-check "testc22.tex-18"
    (walk* y
      `((,y . (,w ,z c)) (,v . b) (,x . ,v) (,z . ,x)))

    `(,w b c))



    (test-check "testc22.tex-19"
    (run* (q)
      (== #f q)
      (project (q)
        (== (not (not q)) q)))

    '(#f))



    (test-check "testc22.tex-20"
    (let ((r (walk* `(,x ,y ,z) empty-s)))
      (walk* r (reify-s r empty-s)))

    `(_.0 _.1 _.2))

    (test-check "testc22.tex-21"
    (let ((r `(,u (,v (,w ,x) ,y) ,x)))
      (walk* r (reify-s r empty-s)))

    `(_.0 (_.1 (_.2 _.3) _.4) _.3))

    (test-check "testc22.tex-22"
    (let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . a))))
      (let ((r (walk* x s)))
        (walk* r (reify-s r empty-s))))

    `(a _.0 c _.0))

    (test-check "testc22.tex-23"
    (let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . ,u))))
      (let ((r (walk* x s)))
        (walk* r (reify-s r empty-s))))

    `(_.0 _.1 c _.1))


    (test-check "testc22.tex-24"
    (let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . a))))
      (reify x s))

    `(a _.0 c _.0))
    (define e (make-engine (lambda ()
    (run1 (x)
      (== `(,x) x))
    )))
    (printf "Testing testc22.tex-25  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-25 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (test-check "testc22.tex-28"
    (run1 (x)
      (== `(,x) x))

    `())
    (define e (make-engine (lambda ()
    (run1 (x)
      (fresh (y z)
        (== x z)
        (== `(a b ,z) y)
        (== x y)))
    )))
    (printf "Testing testc22.tex-29  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-29 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc22.tex-30"
    (run1 (x)
      (fresh (y z)
        (== x z)
        (== `(a b ,z) y)
        (== x y)))
    `())
    (define e (make-engine (lambda ()
    (run1 (x)
      (== `(,x) x))
    )))
    (printf "Testing testc22.tex-31  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-31 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


        (test-check "testc23.tex-fail1" (run* (q)


    (conda
      (fail succeed)
      (fail))


        ) '())


        (test-check "testc23.tex-succeed1" (not (null? (run* (q)


    (conda
      (fail succeed)
      (succeed))


        ))) #t)


        (test-check "testc23.tex-succeed1" (not (null? (run* (q)


    (conda
      (succeed fail)
      (succeed))


        ))) #f)


        (test-check "testc23.tex-succeed2" (not (null? (run* (q)


    (conda
      (succeed succeed)
      (fail))


        ))) #t)


    (test-check "testc23.tex-1"
    (run* (x)
      (conda
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive))

    (test-check "testc23.tex-2"
    (run* (x)
      (conda
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `())

    (test-check "testc23.tex-3"
    (run* (q)
      (fresh (x y)
        (== 'split x)
        (== 'pea y)
        (conda
          ((== 'split x) (== x y))
          (succeed)))
      (== #t q))

    `())

    (test-check "testc23.tex-4"
    (run* (q)
      (fresh (x y)
        (== 'split x)
        (== 'pea y)
        (conda
          ((== x y) (== 'split x))
          (succeed)))
      (== #t q))

    (list #t))

    (define notpastao
      (lambda (x)
        (conda
          ((== 'pasta x) fail)
          (succeed))))


    (test-check "testc23.tex-5"
    (run* (x)
      (conda
        ((notpastao x) fail)
        ((== 'spaghetti x))))

    '(spaghetti))

    (test-check "testc23.tex-6"
    (run* (x)
      (== 'spaghetti x)
      (conda
        ((notpastao x) fail)
        ((== 'spaghetti x))))

    '())
    (define e (make-engine (lambda ()
    (run* (q)
      (conda
        (always succeed)
        (fail))
      (== #t q))
    )))
    (printf "Testing testc23.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc23.tex-8"
    (run* (q)
      (condu
        (always succeed)
        (fail))
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run* (q)
      (condu
        (succeed always)
        (fail))
      (== #t q))
    )))
    (printf "Testing testc23.tex-9  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-9 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (conda
        (always succeed)
        (fail))
      fail
      (== #t q))
    )))
    (printf "Testing testc23.tex-10  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-10 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc23.tex-11"
    (run1 (q)
      (condu
        (always succeed)
        (fail))
      fail
      (== #t q))

    `())

    (define onceo
      (lambda (g)
        (condu
          (g succeed))))


    (test-check "testc23.tex-12"
    (run* (x)
      (onceo (teacupo x)))

    `(tea))

    (test-check "testc23.tex-13"
    (run1 (q)
      (onceo (salo never))
      fail)

    `())

    (test-check "testc23.tex-14"
    (run* (r)
      (conde
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f tea cup))

    (test-check "testc23.tex-15"
    (run* (r)
      (conda
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(tea cup))

    (test-check "testc23.tex-16"
    (run* (r)
      (== #f r)
      (conda
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f))

    (test-check "testc23.tex-17"
    (run* (r)
      (== #f r)
      (condu
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f))

    (define bumpo
      (lambda (n x)
        (conde
          ((== n x) succeed)
          ((fresh (m)
             (minuso n '(1) m)
             (bumpo m x))))))


    (test-check "testc23.tex-18"
    (run* (x)
      (bumpo '(1 1 1) x))


    `((1 1 1)
     (0 1 1)
     (1 0 1)
     (0 0 1)
     (1 1)
     (0 1)
     (1)
     ())
    )

    (define gen&testo
      (lambda (op i j k)
        (onceo
          (fresh (x y z)
            (op x y z)
            (== i x)
            (== j y)
            (== k z)))))


    (test-check "testc23.tex-19"
    (run* (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(1 1 1))
      (== #t q))

    (list
    #t
    ))
    (define e (make-engine (lambda ()
    (run1 (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(0 1 1)))
    )))
    (printf "Testing testc23.tex-20  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-20 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(0 1 1)))
    )))
    (printf "Testing testc23.tex-21  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-21 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define enumerateo
      (lambda (op r n)
        (fresh (i j k)
          (bumpo n i)
          (bumpo n j)
          (op i j k)
          (gen&testo op i j k)
          (== `(,i ,j ,k) r))))


    (test-check "testc23.tex-22"
    (run* (s)
      (enumerateo pluso s '(1 1)))


    `(((1 1) (1 1) (0 1 1))
     ((1 1) (0 1) (1 0 1))
     ((1 1) () (1 1))
     ((0 1) (1 1) (1 0 1))
     ((1 1) (1) (0 0 1))
     ((1) (1 1) (0 0 1))
     ((0 1) (0 1) (0 0 1))
     (() (1 1) (1 1))
     ((0 1) () (0 1))
     ((0 1) (1) (1 1))
     ((1) (0 1) (1 1))
     ((1) (1) (0 1))
     ((1) () (1))
     (() (0 1) (0 1))
     (() (1) (1))
     (() () ()))
    )

    (run* (s)
      (enumerateo pluso s '(1 1)))


    '(test-check "testc23.tex-23"
    (run1 (s)
      (enumerateo pluso s '(1 1 1)))


    `(((1 1 1) (1 1 1) (0 1 1 1)))
    )







    ;;;  Will's toys:

    (define proof-that-fresh-needs-an-inc
      (fresh ()
        proof-that-fresh-needs-an-inc))

    (test-check 'proof-that-run-needs-an-inc
      (run 1 (q)
        (conde
          (proof-that-fresh-needs-an-inc)
          (succeed)))
      '(_.0))

    (define proof-that-fresh-needs-an-inc-with-conda
      (conda
        (proof-that-fresh-needs-an-inc)))

    (test-check 'proof-that-run-needs-an-inc-with-conde-and-conda
      (run 1 (q)
        (conde
          (proof-that-fresh-needs-an-inc)
          (succeed)))
      '(_.0))

    (define proof-that-fresh-needs-an-inc-with-conda
      (fresh ()
        (conda
          (proof-that-fresh-needs-an-inc succeed))))

    (test-check 'proof-that-run-needs-an-inc-with-conde
      (run 1 (q)
        (conde
          (proof-that-fresh-needs-an-inc succeed)
          (succeed)))
      '(_.0))

    (test-check 'why-conde-must-also-have-an-inc
      ((make-engine
         (lambda ()
           (run 5 (q)
             (letrec ((f (fresh ()
                           (conde
                             (f (conde
                                  (f)
                                  (succeed)))
                             (succeed)))))
               f))))
       100000
       (lambda (x y) y)
       list)
      '(_.0 _.0 _.0 _.0 _.0))


    ;;;  Define 'test-check' once again, for the end-user.
    (define-syntax test-check
      (syntax-rules ()
        ((_ title tested-expression expected-result)
         (begin
           (cout "Testing " title nl)
           (let* ((expected expected-result)
                  (produced tested-expression))
             (or (equal? expected produced)
                 (errorf 'test-check
                   "Failed: ~a~%Expected: ~a~%Computed: ~a~%"
                   'tested-expression expected produced)))))))
    #+end_src
* other-books
  #+begin_src scheme
  (define any°
    (lambda (g)
      (begin°
       [g]
       [(any° g)])))
  (run 5 (q)
    (begin°
     [(any° (== #f q))]
     [(== #t q)]
     ))
  (run 9 (q)
    (any°
     (begin°
      [(== 1 q)]
      [(== 2 q)]
      [(== 3 q)]
      )))
  (define always°
    (any° (== #f #f)))

  ;; loop
  ;; (run 1 (x)
  ;;   (== #t x)
  ;;   always°
  ;;   (== #f x))
  (run 5 (x)
    (begin°
     [(== #t x)]
     [(== #f x)])
    always°
    (== #f x))
  (run 5 (x)
    (begin°
     [(== #t x)]
     [(== #f x)])
    always°
    (== #t x))

  (run 5 (x)
    (begin°
     [(== 1 x)]
     [(== 2 x)]
     [(== 3 x)])
    ;; begin°所引入的``代入事件''出了begin°之后就会被忘记
    ;; 但是run内的其他``代入事件''会被记住
    (== 1 x))
  (run 5 (x)
    (begin°
     [(== 1 x)]
     [(== 2 x)]
     [(== 3 x)]
     [always°])
    ;; begin°所引入的``代入事件''出了begin°之后就会被忘记
    ;; 但是run内的其他``代入事件''会被记住
    (== 9 x))
  (run 5 (x)
    (begin°
     [(== 1 x)]
     [(== 2 x)]
     [(== 3 x)])
    (== 2 x))
  (run 5 (x)
    (begin°
     [(== 1 x)]
     [(== 2 x)]
     [(== 3 x)])
    (== 1 x)
    (== 2 x))
  (run 5 (x)
    (== 1 x)
    (== 2 x))

  (run 5 (x)
    (begin°
     [(== #t x)]
     [(== #f x)]))
  (run 5 (x)
    (begin°
     [(== #t x)]
     [(== #f x)])
    (== #f x)
    (== #t x))

  ;; 4 will loop
  (run 3 (q)
    (let ([never° (any° (== #f #t))])
      (begin°
       [(== 1 q)]
       [never°]
       [(begin°
         [(== 2 q)]
         [never°]
         [(== 3 q)]
         )])))
  (run 3 (q)
    (begin°
     [(begin°
       [(== 1 q)]
       [(== 2 q)]
       )]
     [(== 3 q)]
     ))


  (define append
    (lambda (l s)
      (cond [(null? l) s]
            [(pair? l)
             (cons (car l)
                   (append (cdr l) s))]
            )))
  (define append
    (lambda (l s)
      (pmatch `(,l ,s)
        [`(() ,s) s]
        [`((,a . ,d) ,s)
         (let ([rec (append d s)])
           (cons a rec))]
        )))
  (define append
    (lambda (l s)
      (pmatch `(,l ,s)
        [`(() ,s) s]
        [`((,a . ,d) ,s)
         (let ([rec (append d s)])
           (cons a rec))]
        )))

  #+end_src
* alphaKanren
  #+begin_src scheme
  ;; Complete, revised implementation of alphaKanren, an embedding of nominal
  ;; logic programming in R5RS-compliant Scheme.
  ;;
  ;; This implementation is from the revised version of:
  ;;
  ;; alphaKanren: A Fresh Name in Nominal Logic Programming
  ;; William E. Byrd and Daniel P. Friedman
  ;;
  ;; first presented in the Proceedings of the 2007 Workshop on Scheme and
  ;; Functional Programming, Universite Laval Technical Report DIUL-RT-0701,
  ;; pp. 79-90.
  ;;
  ;; Revised:  26 February 2008

  ;;; Remove ' on the next line when debugging.
  '(define-syntax lambda
    (let ()
      (import scheme)
      (syntax-rules ()
        [(_ args b b* ...)
         (case-lambda
           [args b b* ...]
           [others (error 'apply "incorrect args ~s for ~s"
                          others '(lambda args b b* ...))])])))

  (define-syntax testit
    (syntax-rules ()
      ((_ exp val) (tester 'exp exp val))))

  (define tester
    (lambda (exp v val)
      (cond
        ((equal? v val) (write 'okay) (newline))
        (else
          (error 'testit
            "This expression: ~s did not have this value: ~s,
            but instead had this value: ~s" exp val v)))))

  (define-syntax pmatch
    (syntax-rules (else guard)
      ((_ (op arg ...) cs ...)
       (let ((v (op arg ...)))
         (pmatch v cs ...)))
      ((_ v) (if #f #f))
      ((_ v (else e0 e ...)) (begin e0 e ...))
      ((_ v (pat (guard g ...) e0 e ...) cs ...)
       (let ((fk (lambda () (pmatch v cs ...))))
         (ppat v pat
           (if (and g ...) (begin e0 e ...) (fk))
           (fk))))
      ((_ v (pat e0 e ...) cs ...)
       (let ((fk (lambda () (pmatch v cs ...))))
         (ppat v pat (begin e0 e ...) (fk))))))

  (define-syntax ppat
    (syntax-rules (_ quote unquote)
      ((_ v _ kt kf) kt)
      ((_ v () kt kf) (if (null? v) kt kf))
      ((_ v (quote lit) kt kf)
       (if (equal? v (quote lit)) kt kf))
      ((_ v (unquote var) kt kf) (let ((var v)) kt))
      ((_ v (x . y) kt kf)
       (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
      ((_ v lit kt kf) (if (equal? v (quote lit)) kt kf))))

  (define-syntax mv-let
    (syntax-rules ()
      ((_ ((x ...) e) b0 b ...)
       (pmatch e ((,x ...) b0 b ...)))))

  (define-syntax tie
    (syntax-rules ()
      ((_ a t) `(tie-tag ,a ,t))))

  (define var
    (lambda ()
      (letrec ((s (list 'susp-tag '() (lambda () s))))
        s)))

  (define unify
    (lambda (eqns sigma nabla fk)
      (let ((eqns (apply-subst sigma eqns)))
        (mv-let ((sigma^ delta) (apply-sigma-rules eqns fk))
          (unifyhash delta (compose-subst sigma sigma^) nabla fk)))))

  (define unifyhash
    (lambda (delta sigma nabla fk)
      (let ((delta (apply-subst sigma delta))
            (nabla (apply-subst sigma nabla)))
        (let ((delta (delta-union nabla delta)))
          `(,sigma ,(apply-nabla-rules delta fk))))))

  (define apply-sigma-rules
    (lambda (eqns fk)
      (cond
        ((null? eqns) `(,empty-sigma ,empty-delta))
        (else
         (let ((eqn (car eqns)) (eqns (cdr eqns)))
           (mv-let ((eqns sigma delta) (or (sigma-rules eqn eqns) (fk)))
             (mv-let ((sigma^ delta^) (apply-sigma-rules eqns fk))
               `(,(compose-subst sigma sigma^) ,(delta-union delta^ delta)))))))))

  (define apply-nabla-rules
    (lambda (delta fk)
      (cond
        ((null? delta) empty-nabla)
        (else
         (let ((c (car delta)) (delta (cdr delta)))
           (mv-let ((delta nabla) (or (nabla-rules c delta) (fk)))
             (delta-union nabla (apply-nabla-rules delta fk))))))))

  (define untagged?
    (lambda (x)
      (not (memv x '(tie-tag nom-tag susp-tag)))))

  (define sigma-rules
    (lambda (eqn eqns)
      (pmatch eqn
        ((,c . ,c^)
         (guard (not (pair? c)) (equal? c c^))
         `(,eqns ,empty-sigma ,empty-delta))
         (((tie-tag ,a ,t) . (tie-tag ,a^ ,t^))
          (guard (eq? a a^))
          `(((,t . ,t^) . ,eqns) ,empty-sigma ,empty-delta))
         (((tie-tag ,a ,t) . (tie-tag ,a^ ,t^))
          (guard (not (eq? a a^)))
          (let ((u^ (apply-pi `((,a ,a^)) t^)))
            `(((,t . ,u^) . ,eqns) ,empty-sigma ((,a . ,t^)))))
         (((nom-tag _) . (nom-tag _))
          (guard (eq? (car eqn) (cdr eqn)))
          `(,eqns ,empty-sigma ,empty-delta))
         (((susp-tag ,pi ,x) . (susp-tag ,pi^ ,x^))
          (guard (eq? (x) (x^)))
          (let ((delta (map (lambda (a) `(,a . ,(x)))
                               (disagreement-set pi pi^))))
            `(,eqns ,empty-sigma ,delta)))
         (((susp-tag ,pi ,x) . ,t)
          (guard (not (occurs-check (x) t)))
          (let ((sigma `((,(x) . ,(apply-pi (reverse pi) t)))))
            `(,(apply-subst sigma eqns) ,sigma ,empty-delta)))
         ((,t . (susp-tag ,pi ,x))
          (guard (not (occurs-check (x) t)))
          (let ((sigma `((,(x) . ,(apply-pi (reverse pi) t)))))
            `(,(apply-subst sigma eqns) ,sigma ,empty-delta)))
         (((,t1 . ,t2) . (,t1^ . ,t2^))
          (guard (untagged? t1) (untagged? t1^))
          `(((,t1 . ,t1^) (,t2 . ,t2^) . ,eqns) ,empty-sigma ,empty-delta))
         (else #f))))

  (define apply-pi
    (lambda (pi v)
      (pmatch v
        (,c (guard (not (pair? c))) c)
        ((tie-tag ,a ,t) (tie (apply-pi pi a) (apply-pi pi t)))
        ((nom-tag _)
         (let loop ((v v) (pi pi))
           (if (null? pi) v (apply-swap (car pi) (loop v (cdr pi))))))
        ((susp-tag ,pi^ ,x)
         (let ((pi `(,@pi . ,pi^)))
           (if (null? pi) (x) `(susp-tag ,pi ,x))))
        ((,a . ,d) `(,(apply-pi pi a) . ,(apply-pi pi d))))))

  (define apply-swap
    (lambda (swap a)
      (pmatch swap
        ((,a1 ,a2)
         (cond
           ((eq? a a2) a1)
           ((eq? a a1) a2)
           (else a))))))

  (define nabla-rules
    (lambda (d delta)
      (pmatch d
        ((,a . ,c)
         (guard (not (pair? c)))
         `(,delta ,empty-nabla))
        ((,a . (tie-tag ,a^ ,t))
         (guard (eq? a^ a))
         `(,delta ,empty-nabla))
        ((,a . (tie-tag ,a^ ,t))
         (guard (not (eq? a^ a)))
         `(((,a . ,t) . ,delta) ,empty-nabla))
        ((,a . (nom-tag _))
         (guard (not (eq? a (cdr d))))
         `(,delta ,empty-nabla))
        ((,a . (susp-tag ,pi ,x))
         `(,delta ((,(apply-pi (reverse pi) a) . ,(x)))))
        ((,a . (,t1 . ,t2))
         (guard (untagged? t1))
         `(((,a . ,t1) (,a . ,t2) . ,delta) ,empty-nabla))
        (else #f))))

  (define disagreement-set
    (lambda (pi pi^)
      (filter
        (lambda (a) (not (eq? (apply-pi pi a) (apply-pi pi^ a))))
        (remove-duplicates
          (append (apply append pi) (apply append pi^))))))

  (define occurs-check
    (lambda (x v)
      (pmatch v
        (,c (guard (not (pair? c))) #f)
        ((tie-tag _ ,t) (occurs-check x t))
        ((nom-tag _) #f)
        ((susp-tag _ ,x^) (eq? (x^) x))
        ((,x^ . ,y^) (or (occurs-check x x^) (occurs-check x y^)))
        (else #f))))

  (define compose-subst
    (lambda (sigma tau)
      (let ((sigma^ (map
                      (lambda (a) `(,(car a) . ,(apply-subst tau (cdr a))))
                      sigma)))
        (append
          (filter (lambda (a) (not (assq (car a) sigma^))) tau)
          (filter (lambda (a) (not (eq? (car a) (cdr a)))) sigma^)))))

  (define apply-subst
    (lambda (sigma v)
      (pmatch v
        (,c (guard (not (pair? c))) c)
        ((tie-tag ,a ,t) `(tie-tag ,a ,(apply-subst sigma t)))
        ((nom-tag _) v)
        ((susp-tag ,pi ,x) (apply-pi pi (get (x) sigma)))
        ((,x . ,y) `(,(apply-subst sigma x) . ,(apply-subst sigma y))))))

  (define delta-union
    (lambda (delta delta^)
      (pmatch delta
        (() delta^)
        ((,d . ,delta) (if (term-member? d delta^)
                         (delta-union delta delta^)
                         (cons d (delta-union delta delta^)))))))

  (define term-member?
    (lambda (v v*)
      (pmatch v*
        (() #f)
        ((,v^ . ,v*)
         (or (term-equal? v^ v) (term-member? v v*))))))

  (define term-equal?
    (lambda (u v)
      (pmatch `(,u ,v)
        ((,c ,c^) (guard (not (pair? c)) (not (pair? c^)))
         (equal? c c^))
        (((tie-tag ,a ,t) (tie-tag ,a^ ,t^))
         (and (eq? a a^) (term-equal? t t^)))
        (((nom-tag _) (nom-tag _)) (eq? u v))
        (((susp-tag ,pi ,x) (susp-tag ,pi^ ,x^))
         (and (eq? (x) (x^)) (null? (disagreement-set pi pi^))))
        (((,x . ,y) (,x^ . ,y^))
         (and (term-equal? x x^) (term-equal? y y^)))
        (else #f))))

  (define-syntax choice
    (syntax-rules ()
      ((_ a f) (cons a f))))

  (define-syntax inc
    (syntax-rules ()
      ((_ e) (lambdaf@ () e))))

  (define-syntax case-inf
    (syntax-rules ()
      ((_ a-inf (() e0) ((f^) e1) ((a^) e2) ((a f) e3))
       (pmatch a-inf
         (#f e0)
         (,f^ (guard (procedure? f^)) e1)
         (,a^ (guard (not
                       (and (pair? a^)
                            (procedure? (cdr a^)))))
              e2)
         ((,a . ,f) e3)))))

  (define-syntax lambdag@
    (syntax-rules () ((_ (p) e) (lambda (p) e))))

  (define-syntax lambdaf@
    (syntax-rules () ((_ () e) (lambda () e))))

  (define-syntax run
    (syntax-rules ()
      ((_ n (x) g0 g ...)
       (take n (lambdaf@ ()
                 ((exists (x) g0 g ...
                    (lambdag@ (p)
                      (cons (reify x p) '())))
                  `(,empty-sigma ,empty-nabla)))))))

  (define take
    (lambda (n f)
      (if (and n (zero? n))
        '()
        (case-inf (f)
          (() '())
          ((f) (take n f))
          ((a) a)
          ((a f) (cons (car a)
                   (take (and n (- n 1)) f)))))))

  (define-syntax run*
    (syntax-rules ()
      ((_ (x) g0 g ...)
       (run #f (x) g0 g ...))))

  (define empty-sigma '())
  (define empty-delta '())
  (define empty-nabla '())

  (define unifier
    (lambda (fn set)
      (lambdag@ (p)
        (mv-let ((sigma nabla) p)
          (call/cc (lambda (fk) (fn set sigma nabla (lambda () (fk #f)))))))))

  (define ==
    (lambda (u v)
      (unifier unify `((,u . ,v)))))

  (define hash
    (lambda (a t)
      (unifier unifyhash `((,a . ,t)))))

  (define-syntax exists
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (p)
         (inc
           (let ((x (var)) ...)
             (bind* (g0 p) g ...)))))))

  (define-syntax fresh
    (syntax-rules ()
      ((_ (a ...) g0 g ...)
       (lambdag@ (p)
         (inc
           (let ((a (nom 'a)) ...)
             (bind* (g0 p) g ...)))))))

  (define nom
    (lambda (a)
      `(nom-tag ,(symbol->string a))))

  (define-syntax bind*
    (syntax-rules ()
      ((_ e) e)
      ((_ e g0 g ...)
       (let ((a-inf e))
         (and a-inf (bind* (bind a-inf g0) g ...))))))

  (define bind
    (lambda (a-inf g)
      (case-inf a-inf
        (() #f)
        ((f) (inc (bind (f) g)))
        ((a) (g a))
        ((a f) (mplus (g a) (lambdaf@ () (bind (f) g)))))))

  (define mplus
    (lambda (a-inf f)
      (case-inf a-inf
        (() (f))
        ((f^) (inc (mplus (f) f^)))
        ((a) (choice a f))
        ((a f^) (choice a (lambdaf@ () (mplus (f) f^)))))))

  (define-syntax conde
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (p)
         (inc
           (mplus* (bind* (g0 p) g ...)
                   (bind* (g1 p) g^ ...)
                   ...))))))

  (define-syntax mplus*
    (syntax-rules ()
      ((_ e) e)
      ((_ e0 e ...) (mplus e0 (lambdaf@ () (mplus* e ...))))))

  (define-syntax conda
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (p)
         (inc (ifa ((g0 p) g ...)
                   ((g1 p) g^ ...) ...))))))

  (define-syntax ifa
    (syntax-rules ()
      ((_) #f)
      ((_ (e g ...) b ...)
       (let loop ((a-inf e))
         (case-inf a-inf
           (() (ifa b ...))
           ((f) (inc (loop (f))))
           ((a) (bind* a-inf g ...))
           ((a f) (bind* a-inf g ...)))))))

  (define-syntax condu
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (p)
         (inc (ifu ((g0 p) g ...)
                   ((g1 p) g^ ...) ...))))))

  (define-syntax ifu
    (syntax-rules ()
      ((_) #f)
      ((_ (e g ...) b ...)
       (let loop ((a-inf e))
         (case-inf a-inf
           (() (ifu b ...))
           ((f) (inc (loop (f))))
           ((a) (bind* a-inf g ...))
           ((a f) (bind* a g ...)))))))

  (define-syntax project
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (p)
         (mv-let ((sigma nabla) p)
           (let ((x (apply-subst sigma x)) ...)
             (bind* (g0 p) g ...)))))))

  (define reify
    (lambda (x p)
      (mv-let ((sigma nabla) p)
        (let* ((v (get x sigma))
               (s (reify-s v))
               (v (apply-reify-s v s)))
          (let ((nabla (filter (lambda (a)
                                 (and (symbol? (car a))
                                      (symbol? (cdr a))))
                         (apply-reify-s nabla s))))
            (cond
              ((null? nabla) v)
              (else `(,v : ,nabla))))))))

  (define apply-reify-s
    (lambda (v s)
      (pmatch v
        (,c (guard (not (pair? c))) c)
        ((tie-tag ,a ,t)
         `(tie-tag ,(get a s) ,(apply-reify-s t s)))
        ((nom-tag _) (get v s))
        ((susp-tag () _) (get v s))
        ((susp-tag ,pi ,x)
         `(susp-tag
            ,(map (lambda (swap)
                    (pmatch swap
                      ((,a ,b) `(,(get a s) ,(get b s)))))
               pi)
            ,(get (x) s)))
        ((,a . ,d)
         `(,(apply-reify-s a s) . ,(apply-reify-s d s))))))

  (define reify-s
    (letrec
      ((r-s (lambda (v s)
              (pmatch v
                (,c (guard (not (pair? c))) s)
                ((tie-tag ,a ,t) (r-s t (r-s a s)))
                ((nom-tag ,n)
                 (cond
                   ((assq v s) s)
                   ((assp nom? s)
                    => (lambda (p)
                         (cons `(,v . ,(reify-n (cdr p))) s)))
                   (else (cons `(,v . a.0) s))))
                ((susp-tag () _)
                 (cond
                   ((assq v s) s)
                   ((assp var? s)
                    => (lambda (p)
                         (cons `(,v . ,(reify-n (cdr p))) s)))
                   (else (cons `(,v . _.0) s))))
                ((susp-tag ,pi ,x)
                 (r-s (x) (r-s pi s)))
                ((,a . ,d) (r-s d (r-s a s)))))))
        (lambda (v)
          (r-s v '()))))

  (define nom?
    (lambda (x)
      (pmatch x
        ((nom-tag _) #t)
        (else #f))))

  (define var?
    (lambda (x)
      (pmatch x
        ((susp-tag () _) #t)
        (else #f))))

  (define reify-n
    (lambda (a)
      (let ((str* (string->list (symbol->string a))))
        (let ((c* (memv #\. str*)))
          (let ((rn (string->number (list->string (cdr c*)))))
            (let ((n-str (number->string (+ rn 1))))
              (string->symbol
                (string-append
                  (string (car str*)) "." n-str))))))))

  (define get
    (lambda (x s)
      (cond
        ((assq x s) => cdr)
        (else x))))

  (define assp
    (lambda (p s)
      (cond
        ((null? s) #f)
        ((p (car (car s))) (car s))
        (else (assp p (cdr s))))))

  (define filter
    (lambda (p s)
      (cond
        ((null? s) '())
        ((p (car s)) (cons (car s) (filter p (cdr s))))
        (else (filter p (cdr s))))))

  (define remove-duplicates
    (lambda (s)
      (cond
        ((null? s) '())
        ((memq (car s) (cdr s)) (remove-duplicates (cdr s)))
        (else (cons (car s) (remove-duplicates (cdr s)))))))

  ;; ;;; This is what we give students.

  ;; '(define-syntax pmatch
  ;;   (syntax-rules (else guard)
  ;;     ((_ (rator rand ...) cs ...)
  ;;      (let ((v (rator rand ...)))
  ;;        (pmatch v cs ...)))
  ;;     ((_ v) (error 'pmatch "failed: ~s" v))
  ;;     ((_ v (else e0 e ...)) (begin e0 e ...))
  ;;     ((_ v (pat (guard g ...) e0 e ...) cs ...)
  ;;      (let ((fk (lambda () (pmatch v cs ...))))
  ;;        (ppat v pat (if (and g ...) (begin e0 e ...) (fk)) (fk))))
  ;;     ((_ v (pat e0 e ...) cs ...)
  ;;      (let ((fk (lambda () (pmatch v cs ...))))
  ;;        (ppat v pat (begin e0 e ...) (fk))))))

  (define-syntax ppat
    (syntax-rules (_ quote unquote)
      ((_ v _ kt kf) kt)
      ((_ v () kt kf) (if (null? v) kt kf))
      ((_ v (quote lit) kt kf)
       (if (equal? v (quote lit)) kt kf))
      ((_ v (unquote var) kt kf) (let ((var v)) kt))
      ((_ v (x . y) kt kf)
       (if (pair? v)
         (let ((vx (car v)) (vy (cdr v)))
           (ppat vx x (ppat vy y kt kf) kf))
         kf))
      ((_ v lit kt kf) (if (equal? v (quote lit)) kt kf))))

  ;;;; And now the tests from the old alphamk.scm

  (define h
    (lambda (x y)
      (pmatch `(,x . ,y)
        ((,a . ,b) (guard (number? a) (number? b)) (+ a b))
        ((_ . ,c) (guard (number? c)) (* c c))
        (else (* x x)))))

  (testit
   (list (h 1 2) (h 'w 5) (h 6 'w))
   '(3 25 36))

  (testit
   (run 1 (q) (exists (x y z) (== x z) (== 3 y)))
   '(_.0))

  (testit
   (run 1 (q) (exists (x y) (== x q) (== 3 y)))
   '(_.0))

  (testit
    (run 1 (y)
      (exists (x z)
        (== x z)
        (== 3 y)))
   '(3))

  (testit
   (run 1 (q)
    (exists (x z)
      (== x z)
      (== 3 z)
      (== q x)))
   '(3))

  (testit
    (run 1 (y)
     (exists (x y)
       (== 4 x)
       (== x y))
     (== 3 y))
    '(3))

  (testit
    (run 1 (x) (== 4 3))
    '())

  (testit
   (run 2 (q)
    (exists (x y z)
      (conde
        ((== `(,x ,y ,z ,x) q))
        ((== `(,z ,y ,x ,z) q)))))
   '((_.0 _.1 _.2 _.0)
     (_.0 _.1 _.2 _.0)))

  (testit
   (run 5 (q)
    (let loop ()
      (conde
        ((== #f q))
        ((== #t q))
        ((loop)))))
   '(#f #t #f #t #f))

  (define anyo
    (lambda (g)
      (conde
        (g)
        ((anyo g)))))

  (testit
   (run 5 (q)
    (conde
      ((anyo (== #f q)))
      ((== #t q))))
   '(#t #f #f #f #f))

  (testit
   (run 10 (q)
     (anyo
      (conde
        ((== 1 q))
        ((== 2 q))
        ((== 3 q)))))
   '(1 2 3 1 2 3 1 2 3 1))

  (testit
   (run 3 (q)
    (let ((nevero (anyo (== #f #t))))
      (conde
        ((== 1 q))
        (nevero)
        ((conde
           ((== 2 q))
           (nevero)
           ((== 3 q)))))))
   '(1 2 3))

  (testit
    (run* (q) (fresh (a) (== a a)))
    '(_.0))

  (testit
   (run* (q) (fresh (a) (== a 5)))
   '())

  (testit
    (run* (q) (fresh (a b) (== a b)))
    '())

  (testit
    (run* (q) (fresh (a b) (== b q)))
    '(a.0))

  (testit
   (run* (q)
    (exists (x y z)
      (fresh (a)
        (== x a)
        (fresh (a b)
          (== y a)
          (== `(,x ,y ,z ,a ,b) q)))))
    '((a.0 a.1 _.0 a.1 a.2)))

  (testit
   (run* (q)
    (fresh (a b)
      (== (tie a `(foo ,a 3 ,b)) q)))
   '((tie-tag a.0 (foo a.0 3 a.1))))

  (testit
    (run* (q) (fresh (a b) (== `(foo ,a ,a) `(foo ,b ,b))))
    '())

  (testit
    (run* (q) (fresh (a b) (== (tie a a) (tie b b))))
    '(_.0))

  (testit
   (run* (q) (fresh (a b) (== (tie a q) (tie b b))))
   '(a.0))

  (testit
   (run* (q)
    (exists (t u)
      (fresh (a b c d)
        (== `(lam ,(tie a `(lam ,(tie b `(var ,a))))) t)
        (== `(lam ,(tie c `(lam ,(tie d `(var ,c))))) u)
        (== t u))))
   '(_.0))

  (testit
   (run* (q)
    (exists (t u)
      (fresh (a b c d)
        (== `(lam ,(tie a `(lam ,(tie b `(var ,a))))) t)
        (== `(lam ,(tie c `(lam ,(tie d `(var ,d))))) u)
        (== t u))))
   '())

  (testit
   (run* (q) (fresh (a) (hash a a)))
   '())

  (testit
   (run* (q) (fresh (a) (hash a 5)))
   '(_.0))

  (testit
   (run* (q) (fresh (a) (hash a (tie a a))))
   '(_.0))

  (testit
   (run* (q) (fresh (a b) (hash a (tie b a))))
   '())

  (testit
   (run* (k)
    (exists (t)
      (fresh (a)
        (hash a k)
        (== `(5 ,(tie a a) ,t) k))))
   '(((5 (tie-tag a.0 a.0) _.0) : ((a.0 . _.0)))))

  (testit
   (run* (k)
    (exists (t)
      (fresh (a)
        (hash a k)
        (== `(5 ,(tie a a) ,t) k)
        (== `(foo ,a 7) t))))
   '())

  (testit
   (run* (k)
    (exists (t)
      (fresh (a b)
        (== (tie a (tie b t)) k)
        (hash a t)
        (== `((,a ,b) ,b) t))))
   '())

  (testit
   (run* (k)
    (exists (t)
      (fresh (a b)
        (== (tie a (tie b t)) k)
        (hash a t)
        (== `(,b ,(tie a `(,a (,b ,b)))) t))))
   '((tie-tag a.0 (tie-tag a.1 (a.1 (tie-tag a.0 (a.0 (a.1 a.1))))))))

  (testit
   (run* (q)
    (exists (k1 k2 t u)
      (fresh (a b c d)
        (== (tie a (tie b t)) k1)
        (hash a t)
        (== (tie c (tie d u)) k2)
        (hash c u)
        (== k1 k2)
        (== `(,k1 ,k2) q))))
   '((((tie-tag a.0 (tie-tag a.1 (susp-tag ((a.1 a.2) (a.0 a.3)) _.0)))
      (tie-tag a.3 (tie-tag a.2 _.0)))
     :
     ((a.3 . _.0) (a.1 . _.0) (a.0 . _.0)))))

  (testit
   (run* (q)
    (exists (k1 k2 t u)
      (fresh (a b c d)
        (== (tie a (tie b t)) k1)
        (hash a t)
        (== `(,b ,b) t)
        (== (tie c (tie d u)) k2)
        (hash c u)
        (== `(,d ,d) u)
        (== k1 k2)
        (== `(,k1 ,k2) q))))
   '(((tie-tag a.0 (tie-tag a.1 (a.1 a.1)))
      (tie-tag a.2 (tie-tag a.3 (a.3 a.3))))))

  (testit
   (run* (q)
     (fresh (a b)
       (exists (x y)
         (== (tie a (tie a x)) (tie a (tie b y)))
         (== `(,x ,y) q))))
   '((((susp-tag ((a.0 a.1)) _.0) _.0) : ((a.0 . _.0)))))

  (testit
   (run* (q)
    (fresh (a b)
      (exists (x y)
        (conde
          ((== (tie a (tie b `(,x ,b))) (tie b (tie a `(,a ,x)))))
          ((== (tie a (tie b `(,y ,b))) (tie b (tie a `(,a ,x)))))
          ((== (tie a (tie b `(,b ,y))) (tie b (tie a `(,a ,x)))))
          ((== (tie a (tie b `(,b ,y))) (tie a (tie a `(,a ,x))))))
        (== `(,x ,y) q))))
   '((a.0 a.1)
    (_.0 (susp-tag ((a.0 a.1)) _.0))
    ((_.0 (susp-tag ((a.0 a.1)) _.0)) : ((a.0 . _.0)))))

  (define substo
    (lambda (e new a out)
      (conde
        ((== `(var ,a) e) (== new out))
        ((exists (y)
           (== `(var ,y) e)
           (== `(var ,y) out)
           (hash a y)))
        ((exists (rator ratorres rand randres)
           (== `(app ,rator ,rand) e)
           (== `(app ,ratorres ,randres) out)
           (substo rator new a ratorres)
           (substo rand new a randres)))
        ((exists (body bodyres)
           (fresh (c)
             (== `(lam ,(tie c body)) e)
             (== `(lam ,(tie c bodyres)) out)
             (hash c a)
             (hash c new)
             (substo body new a bodyres)))))))

  (testit
   (run* (x)
    (fresh (a b)
      (substo `(lam ,(tie a `(var ,b))) `(var ,a) b x)))
   '((lam (tie-tag a.0 (var a.1)))))

  (testit
   (run* (q)
    (fresh (a b)
      (substo
        `(lam ,(tie a `(app (var ,a) (var ,b)))) b a q)))
   '((lam (tie-tag a.0 (app (var a.0) (var a.1))))))


  (define typo
    (lambda (g e te)
      (conde
        ((exists (x)
           (== `(var ,x) e)
           (lookupo x te g)))
        ((exists (rator trator rand trand)
           (== `(app ,rator ,rand) e)
           (== `(-> ,trand ,te) trator)
           (typo g rator trator)
           (typo g rand trand)))
        ((exists (e^ te^ trand g^)
           (fresh (b)
             (== `(lam ,(tie b e^)) e)
             (== `(-> ,trand ,te^) te)
             (hash b g)
             (== `((,b . ,trand) . ,g) g^)
             (typo g^ e^ te^))))
        ((exists (rator t-val)
           (== `(C ,rator) e)
           (typo g rator `(-> (-> ,te ,t-val) ,t-val)))))))

  (define !-c
    (lambda (gamma exp type)
      (exists (m a b)
        (== `(c ,m) exp)
        (== a type)
        (!- gamma m `(-> (-> ,a ,b) ,b)))))

  (define lookupo
    (lambda (x tx g)
      (exists (a d)
        (== `(,a . ,d) g)
        (conde
          ((== `(,x . ,tx) a))
          ((exists (x^ tx^)
             (== `(,x^ . ,tx^) a)
             (hash x x^)
             (lookupo x tx d)))))))

  (testit
   (run* (q)
    (fresh (c d)
      (typo '() `(lam ,(tie c `(lam ,(tie d `(var ,c))))) q)))
   '((-> _.0 (-> _.1 _.0))))

  '(testit
   (run* (q)
    (fresh (c d)
      (typo '() `(lam ,(tie c `(lam ,(tie d `(var ,c))))) q)))
   '(((-> _.0 (-> _.1 _.0)) : ((b.0 . _.0)))))

  (testit
  (run* (q)
    (fresh (c)
      (typo '() `(lam ,(tie c `(app (var ,c) (var ,c)))) q)))
   '())

  (testit
   (run 3 (q) (typo '() q '(-> int int)))
   '((lam (tie-tag a.0 (var a.0)))
    (app (lam (tie-tag a.0 (var a.0)))
         (lam (tie-tag a.1 (var a.1))))
    (lam (tie-tag
           a.0
           (app (lam (tie-tag a.1 (var a.1))) (var a.0))))))

  (testit
   (run* (q)
    (exists (x y z)
      (fresh (a)
        (hash a x)
        (== `(,y ,z) x)
        (== `(,x ,a) q))))
   '((((_.0 _.1) a.0) : ((a.0 . _.0) (a.0 . _.1)))))
  #+end_src
* canonical-miniKanren
  - CORE LANGUAGE
    - Logical operators:
      ==
      fresh
      conde
    - Interface operators:
      run
      run*
  - EXTENDED LANGUAGE
    - Constraint operators:
      =/=
      symbolo
      numbero
      absento
  #+begin_src scheme
  (define c->S (lambda (c) (car c)))

  (define c->D (lambda (c) (cadr c)))

  (define c->A (lambda (c) (caddr c)))

  (define c->T (lambda (c) (cadddr c)))

  (define empty-c '(() () () ()))

  (define-syntax lambdag@
    (syntax-rules (:)
      [(_ (c) e) (lambda (c) e)]
      [(_ (c : S D A T) e)
       (lambda (c)
         (let ((S (c->S c))
               (D (c->D c))
               (A (c->A c))
               (T (c->T c)))
           e))]))

  (define mzero (lambda () #f))

  (define unit (lambdag@ (c) c))

  (define choice (lambda (c f) (cons c f)))

  (define-syntax lambdaf@
    (syntax-rules ()
      [(_ () e)
       (lambda () e)]))

  (define-syntax inc
    (syntax-rules ()
      [(_ e)
       (lambdaf@ () e)]))

  (define empty-f (lambdaf@ () (mzero)))

  (define-syntax case-inf
    (syntax-rules ()
      ((_ e (() e0) ((f^) e1) ((c^) e2) ((c f) e3))
       (let ((c-inf e))
         (cond
           ((not c-inf) e0)
           ((procedure? c-inf)  (let ((f^ c-inf)) e1))
           ((not (and (pair? c-inf)
                   (procedure? (cdr c-inf))))
            (let ((c^ c-inf)) e2))
           (else (let ((c (car c-inf)) (f (cdr c-inf)))
                   e3)))))))

  (define-syntax run
    (syntax-rules ()
      ((_ n (x) g0 g ...)
       (take n
         (lambdaf@ ()
           ((fresh (x) g0 g ...
              (lambdag@ (final-c)
                (let ((z ((reify x) final-c)))
                  (choice z empty-f))))
            empty-c))))))

  (define-syntax run*
    (syntax-rules ()
      [(_ (x) g ...)
       (run #f (x) g ...)]))

  (define take
    (lambda (n f)
      (cond
        ((and n (zero? n)) '())
        (else
         (case-inf (f)
           (() '())
           ((f) (take n f))
           ((c) (cons c '()))
           ((c f) (cons c (take (and n (- n 1)) f))))))))

  (define-syntax fresh
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (c)
         (inc (let ((x (var 'x)) ...)
                (bind* (g0 c) g ...)))))))

  (define-syntax bind*
    (syntax-rules ()
      ((_ e) e)
      ((_ e g0 g ...) (bind* (bind e g0) g ...))))

  (define bind
    (lambda (c-inf g)
      (case-inf c-inf
        (() (mzero))
        ((f) (inc (bind (f) g)))
        ((c) (g c))
        ((c f) (mplus (g c) (lambdaf@ () (bind (f) g)))))))

  (define mplus
    (lambda (c-inf f)
      (case-inf c-inf
        (() (f))
        ((f^) (inc (mplus (f) f^)))
        ((c) (choice c f))
        ((c f^) (choice c (lambdaf@ () (mplus (f) f^)))))))

  (define-syntax conde
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (c) (inc (mplus* (bind* (g0 c) g ...)
                                  (bind* (g1 c) g^ ...) ...))))))

  (define-syntax mplus*
    (syntax-rules ()
      ((_ e) e)
      ((_ e0 e ...) (mplus e0 (lambdaf@ () (mplus* e ...))))))

  (define-syntax case-value
    (syntax-rules ()
      ((_ u ((t1) e0) ((at dt) e1) ((t2) e2))
       (let ((t u))
         (cond
           ((var? t) (let ((t1 t)) e0))
           ((pair? t) (let ((at (car t)) (dt (cdr t))) e1))
           (else (let ((t2 t)) e2)))))))

  (define make-tag-A
    (lambda (tag pred)
      (lambda (u)
        (lambdag@ (c : S D A T)
          (case-value (walk u S)
            ((x) (cond
                   ((make-tag-A+ x tag pred c S D A T) =>
                    unit)
                   (else (mzero))))
            ((au du) (mzero))
            ((u) (cond
                   ((pred u) (unit c))
                   (else (mzero)))))))))

  (define make-tag-A+
    (lambda (u tag pred c S D A T)
      (cond
        ((ext-A (walk u S) tag pred S A) =>
         (lambda (A+)
           (cond
             ((null? A+) c)
             (else (let ((D (subsume A+ D))
                         (A (append A+ A)))
                     (subsume-A S D A T))))))
        (else #f))))

  (define subsume-A
    (lambda (S D A T)
      (let ((x* (rem-dups (map lhs A))))
        (subsume-A+ x* S D A T))))

  (define subsume-A+
    (lambda (x* S D A T)
      (cond
        ((null? x*) `(,S ,D ,A ,T))
        (else (let ((x (car x*)))
                (let ((D/T (update-D/T x S D A T)))
                  (let ((D (car D/T)) (T (cdr D/T)))
                    `(,S ,D ,A ,T))))))))

  (define ext-A
    (lambda (x tag pred S A)
      (cond
        ((null? A) `((,x . (,tag . ,pred))))
        (else
         (let ((a (car A)) (A (cdr A)))
           (let ((a-tag (pr->tag a)))
             (cond
               ((eq? (walk (lhs a) S) x)
                (cond
                  ((tag=? a-tag tag) '())
                  (else #f)))
               (else (ext-A x tag pred S A)))))))))

  (define symbolo (make-tag-A 'sym symbol?))

  (define numbero (make-tag-A 'num number?))

  (define booleano
    (lambda (x)
      (conde
        ((== #f x))
        ((== #t x)))))

  (define pr->tag (lambda (pr) (car (rhs pr))))

  (define pr->pred (lambda (pr) (cdr (rhs pr))))

  (define =/=
    (lambda (u v)
      (lambdag@ (c : S D A T)
        (cond
          ((unify u v S) => (post-unify-=/= S D A T))
          (else (unit c))))))

  (define post-unify-=/=
    (lambda (S D A T)
      (lambda (S+)
        (cond
          ((eq? S+ S) (mzero))
          (else (let ((D+ (list (prefix-S S+ S))))
                  (let ((D+ (subsume A D+)))
                    (let ((D+ (subsume T D+)))
                      (let ((D (append D+ D)))
                        (unit `(,S ,D ,A ,T)))))))))))

  (define prefix-S
    (lambda (S+ S)
      (cond
        ((eq? S+ S) '())
        (else (cons (car S+) (prefix-S (cdr S+) S))))))

  (define subsume
    (lambda (A/T D)
      (remp (lambda (d) (exists (subsumed-pr? A/T) d))
        D)))

  (define subsumed-pr?
    (lambda (A/T)
      (lambda (pr-d)
        (let ((u (rhs pr-d)))
          (cond
            ((var? u) #f)
            (else
             (let ((pr (assq (lhs pr-d) A/T)))
               (and pr
                 (let ((tag (pr->tag pr)))
                   (cond
                     ((and (tag? tag)
                           (tag? u)
                           (tag=? u tag)))
                     (((pr->pred pr) u) #f)
                     (else #t)))))))))))

  (define ==
    (lambda (u v)
      (lambdag@ (c : S D A T)
        (cond
          ((unify u v S) =>
           (post-unify-== c S D A T))
          (else (mzero))))))

  (define post-unify-==
    (lambda (c S D A T)
      (lambda (S+)
        (cond
          ((eq? S+ S) (unit c))
          ((verify-D D S+) =>
           (lambda (D)
             (cond
               ((post-verify-D S+ D A T) => unit)
               (else (mzero)))))
          (else (mzero))))))

  (define verify-D
    (lambda (D S)
      (cond
        ((null? D) '())
        ((verify-D (cdr D) S) =>
         (lambda (D+)
           (verify-D+ (car D) D+ S)))
        (else #f))))

  (define verify-D+
    (lambda (d D S)
      (cond
        ((unify* d S) =>
         (lambda (S+)
           (cond
             ((eq? S+ S) #f)
             (else (cons (prefix-S S+ S) D)))))
        (else D))))

  (define post-verify-D
    (lambda (S D A T)
      (cond
        ((verify-A A S) =>
         (post-verify-A S D T))
        (else #f))))

  (define verify-A
    (lambda (A S)
      (cond
        ((null? A) '())
        ((verify-A (cdr A) S) =>
         (lambda (A0)
           (let ((u (walk (lhs (car A)) S))
                 (tag (pr->tag (car A)))
                 (pred (pr->pred (car A))))
             (cond
               ((var? u)
                (cond
                  ((ext-A u tag pred S A0) =>
                   (lambda (A+)
                     (append A+ A0)))
                  (else #f)))
               (else (and (pred u) A0))))))
        (else #f))))

  (define post-verify-A
    (lambda (S D T)
      (lambda (A)
        (let ((D (subsume A D)))
          (cond
            ((verify-T T S) => (post-verify-T S D A))
            (else #f))))))

  (define verify-T
    (lambda (T S)
      (cond
        ((null? T) '())
        ((verify-T (cdr T) S) => (verify-T+ (lhs (car T)) T S))
        (else #f))))

  (define verify-T+
    (lambda (x T S)
      (lambda (T0)
        (let ((tag (pr->tag (car T)))
              (pred (pr->pred (car T))))
          (case-value (walk x S)
            ((x) (cond
                   ((ext-T+ x tag pred S T0) =>
                    (lambda (T+) (append T+ T0)))
                   (else #f)))
            ((au du) (cond
                       (((verify-T+ au T S) T0) =>
                        (verify-T+ du T S))
                       (else #f)))
            ((u) (and (pred u) T0)))))))

  (define post-verify-T
    (lambda (S D A)
      (lambda (T)
        (subsume-T T S (subsume T D) A '()))))

  (define subsume-T
    (lambda (T+ S D A T)
      (let ((x* (rem-dups (map lhs A))))
        (subsume-T+ x* T+ S D A T))))

  (define subsume-T+
    (lambda (x* T+ S D A T)
      (cond
        ((null? x*)
         (let ((T (append T+ T)))
           `(,S ,D ,A ,T)))
        (else
         (let ((x (car x*)) (x* (cdr x*)))
           (let ((D/T (update-D/T x S D A T+)))
             (let ((D (car D/T)) (T+ (cdr D/T)))
               (subsume-T+ x* T+ S D A T))))))))

  (define update-D/T
    (lambda (x S D A T)
      (cond
        ((null? A)
         (let ((T (remp (lambda (t)
                          (eq? (lhs t) x))
                    T)))
           `(,D . ,T)))
        (else
         (let ((a (car A)))
           (cond
             ((and (eq? (lhs a) x)
                (or (tag=? (pr->tag a) 'sym)
                    (tag=? (pr->tag a) 'num)))
              (update-D/T+ x '() S D T))
             (else
              (update-D/T x S D (cdr A) T))))))))

  (define update-D/T+
    (lambda (x T+ S D T)
      (cond
        ((null? T)
         `(,D . ,T+))
        (else
         (let ((t (car T))
               (T (cdr T)))
           (cond
             ((eq? (lhs t) x)
              (let ((D (ext-D x (pr->tag t) D S)))
                (update-D/T+ x T+ S D T)))
             (else
              (let ((T+ (cons t T+)))
                (update-D/T+ x T+ S D T)))))))))

  (define ext-D
    (lambda (x tag D S)
      (cond
        ((exists
           (lambda (d)
             (and (null? (cdr d))
               (let ((y (lhs (car d)))
                     (u (rhs (car d))))
                 (and
                   (eq? (walk y S) x)
                   (tag? u)
                   (tag=? u tag)))))
           D)
         D)
        (else (cons `((,x . ,tag)) D)))))

  (define absento
    (lambda (tag u)
      (cond
        ((not (tag? tag)) fail)
        (else
         (lambdag@ (c : S D A T)
           (cond
             ((absento+ u tag c S D A T) => unit)
             (else (mzero))))))))

  (define absento+
    (lambda (u tag c S D A T)
      (case-value (walk u S)
        ((x)
         (let ((T+ (ext-T x tag S T)))
           (cond
             ((null? T+) c)
             (else
              (let ((D (subsume T+ D)))
                (subsume-T T+ S D A T))))))
        ((au du)
         (let ((c (absento+ au tag c S D A T)))
           (and c
             (let ((S (c->S c))
                   (D (c->D c))
                   (A (c->A c))
                   (T (c->T c)))
               (absento+ du tag c S D A T)))))
        ((u)
         (cond
           ((and (tag? u) (tag=? u tag)) #f)
           (else c))))))

  (define ext-T
    (lambda (x tag S T)
      (cond
        ((null? T)
         (let ((pred (make-pred-T tag)))
           `((,x . (,tag . ,pred)))))
        (else
         (let ((t (car T)) (T (cdr T)))
           (let ((t-tag (pr->tag t)))
             (cond
               ((eq? (walk (lhs t) S) x)
                (cond
                  ((tag=? t-tag tag) '())
                  (else (ext-T x tag S T))))
               ((tag=? t-tag tag)
                (let ((t-pred (pr->pred t)))
                  (ext-T+ x tag t-pred S T)))
               (else (ext-T x tag S T)))))))))

  (define ext-T+
    (lambda (x tag pred S T)
      (cond
        ((null? T) `((,x . (,tag . ,pred))))
        (else
         (let ((t (car T)))
           (let ((t-tag (pr->tag t)))
             (cond
               ((eq? (walk (lhs t) S) x)
                (cond
                  ((tag=? t-tag tag) '())
                  (else
                   (ext-T+ x tag pred S
                     (cdr T)))))
               (else
                (ext-T+ x tag pred S
                  (cdr T))))))))))

  (define make-pred-T
    (lambda (tag)
      (lambda (x)
        (not (and (tag? x) (tag=? x tag))))))

  (define tag?
    (lambda (tag)
      (symbol? tag)))

  (define tag=?
    (lambda (tag1 tag2)
      (eq? tag1 tag2)))

  (define var (lambda (dummy) (vector dummy)))

  (define var? (lambda (x) (vector? x)))

  (define rem-dups
    (lambda (x*)
      (cond
        ((null? x*) '())
        ((memq (car x*) (cdr x*))
         (rem-dups (cdr x*)))
        (else (cons (car x*)
                (rem-dups (cdr x*)))))))

  (define lhs (lambda (pr) (car pr)))

  (define rhs (lambda (pr) (cdr pr)))

  (define succeed (== #f #f))

  (define fail (== #f #t))

  (define walk
    (lambda (u S)
      (cond
        ((and (var? u) (assq u S)) =>
         (lambda (pr) (walk (rhs pr) S)))
        (else u))))

  (define unify
    (lambda (u v S)
      (let ((u (walk u S)) (v (walk v S)))
        (cond
          ((and (pair? u) (pair? v))
           (let ((S (unify (car u) (car v) S)))
             (and S (unify (cdr u) (cdr v) S))))
          (else (unify-nonpair u v S))))))

  (define unify-nonpair
    (lambda (u v S)
      (cond
        ((eq? u v) S)
        ((var? u) (ext-S u v S))
        ((var? v) (ext-S v u S))
        ((equal? u v) S)
        (else #f))))

  (define ext-S
    (lambda (x v S)
      (case-value v
        ((y) (cons `(,x . ,y) S))
        ((au du) (cond
                   ((occurs-check x v S) #f)
                   (else (cons `(,x . ,v) S))))
        ((v) (cons `(,x . ,v) S)))))

  (define occurs-check
    (lambda (x v S)
      (case-value (walk v S)
        ((y) (eq? y x))
        ((av dv) (or (occurs-check x av S)
                     (occurs-check x dv S)))
        ((v) #f))))

  (define walk*
    (lambda (v S)
      (case-value (walk v S)
        ((x) x)
        ((av dv)
         (cons (walk* av S) (walk* dv S)))
        ((v) v))))

  (define reify-S
    (lambda (v S)
      (case-value (walk v S)
        ((x) (let ((n (length S)))
               (let ((name (reify-name n)))
                 (cons `(,x . ,name) S))))
        ((av dv) (let ((S (reify-S av S)))
                   (reify-S dv S)))
        ((v) S))))

  (define reify-name
    (lambda (n)
      (string->symbol
        (string-append "_" "." (number->string n)))))

  (define reify
    (lambda (x)
      (lambda (c)
        (let ((S (c->S c)) (D (c->D c))
              (A (c->A c)) (T (c->T c)))
          (let ((v (walk* x S)))
            (let ((S (reify-S v '())))
              (reify+ v S
                (let ((D (remp
                           (lambda (d) (anyvar? d S))
                           D)))
                  (rem-subsumed D))
                (remp
                  (lambda (a)
                    (var? (walk (lhs a) S)))
                  A)
                (remp
                  (lambda (t)
                    (var? (walk (lhs t) S)))
                  T))))))))

  (define reify+
    (lambda (v S D A T)
      (let ((D (subsume A D)))
        (let ((A (map (lambda (a)
                        (let ((x (lhs a))
                              (tag (pr->tag a)))
                          `(,x . ,tag)))
                      A))
              (T (map (lambda (t)
                        (let ((x (lhs t))
                              (tag (pr->tag t)))
                          `(,x . ,tag)))
                      T)))
          (form (walk* v S)
                (walk* D S)
                (walk* A S)
                (rem-subsumed-T (walk* T S)))))))

  (define form
    (lambda (v D A T)
      (let ((fd (drop-dot-D (sorter (map sorter D))))
            (fa (sorter (map sort-part (partition* A))))
            (ft (drop-dot-T (sorter T))))
        (let ((fb (append ft fa)))
          (cond
            ((and (null? fd) (null? fb)) v)
            ((null? fd) `(,v . ,fb))
            ((null? fb) `(,v . ((=/= . ,fd))))
            (else `(,v (=/= . ,fd) . ,fb)))))))

  (define drop-dot-D
    (lambda (D)
      (map (lambda (d)
             (map (lambda (pr)
                    (let ((x (lhs pr))
                          (u (rhs pr)))
                      `(,x ,u)))
                  d))
           D)))

  (define drop-dot-T
    (lambda (T)
      (map (lambda (t)
             (let ((x (lhs t))
                   (tag (rhs t)))
               `(absent ,tag ,x)))
           T)))

  (define sorter (lambda (ls) (sort lex<=? ls)))

  (define sort-part
    (lambda (pr)
      (let ((tag (car pr))
            (x* (sorter (cdr pr))))
        `(,tag . ,x*))))

  (define anyvar?
    (lambda (u S)
      (case-value u
        ((x) (var? (walk x S)))
        ((au du) (or (anyvar? au S)
                     (anyvar? du S)))
        ((u) #f))))

  (define rem-subsumed
    (lambda (D)
      (let loop ((D D) (D+ '()))
        (cond
          ((null? D) D+)
          ((or (subsumed? (car D) (cdr D))
               (subsumed? (car D) D+))
           (loop (cdr D) D+))
          (else (loop (cdr D)
                  (cons (car D) D+)))))))

  (define subsumed?
    (lambda (d D)
      (cond
        ((null? D) #f)
        (else (let ((d^ (unify* (car D) d)))
                (or (and d^ (eq? d^ d))
                    (subsumed? d (cdr D))))))))

  (define rem-subsumed-T
    (lambda (T)
      (let loop ((T T) (T^ '()))
        (cond
          ((null? T) T^)
          (else
           (let ((x (lhs (car T)))
                 (tag (rhs (car T))))
             (cond
               ((or (subsumed-T? x tag (cdr T))
                    (subsumed-T? x tag T^))
                (loop (cdr T) T^))
               (else (loop (cdr T)
                       (cons (car T) T^))))))))))

  (define subsumed-T?
    (lambda (x tag1 T)
      (cond
        ((null? T) #f)
        (else
         (let ((y (lhs (car T)))
               (tag2 (rhs (car T))))
           (or
             (and (eq? y x) (tag=? tag2 tag1))
             (subsumed-T? x tag1 (cdr T))))))))

  (define unify*
    (lambda (S+ S)
      (unify (map lhs S+) (map rhs S+) S)))

  (define part
    (lambda (tag A x* y*)
      (cond
       ((null? A)
        (cons `(,tag . ,x*) (partition* y*)))
       ((tag=? (rhs (car A)) tag)
        (let ((x (lhs (car A))))
          (let ((x* (cond
                      ((memq x x*) x*)
  (else (cons x x*)))))
            (part tag (cdr A) x* y*))))
       (else
        (let ((y* (cons (car A) y*)))
          (part tag (cdr A) x* y*))))))

  (define partition*
    (lambda (A)
      (cond
        ((null? A) '())
        (else
         (part (rhs (car A)) A '() '())))))

  (define lex<=?
    (lambda (x y)
      (string<=? (datum->string x) (datum->string y))))

  (define datum->string
    (lambda (x)
      (call-with-string-output-port
        (lambda (p) (display x p)))))

  (define-syntax project
    (syntax-rules ()
      ((_ (x ...) g g* ...)
       (lambdag@ (c : S D A T)
         (let ((x (walk* x S)) ...)
           ((fresh () g g* ...) c))))))

  (define-syntax conda
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (c)
         (inc
           (ifa ((g0 c) g ...)
                ((g1 c) g^ ...) ...))))))

  (define-syntax ifa
    (syntax-rules ()
      ((_) (mzero))
      ((_ (e g ...) b ...)
       (let loop ((c-inf e))
         (case-inf c-inf
           (() (ifa b ...))
           ((f) (inc (loop (f))))
           ((a) (bind* c-inf g ...))
           ((a f) (bind* c-inf g ...)))))))

  (define-syntax condu
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (c)
         (inc
           (ifu ((g0 c) g ...)
                ((g1 c) g^ ...) ...))))))

  (define-syntax ifu
    (syntax-rules ()
      ((_) (mzero))
      ((_ (e g ...) b ...)
       (let loop ((c-inf e))
         (case-inf c-inf
           (() (ifu b ...))
           ((f) (inc (loop (f))))
           ((c) (bind* c-inf g ...))
           ((c f) (bind* (unit c) g ...)))))))

  (define onceo (lambda (g) (condu (g))))
  #+end_src
* webyrd-miniKanren
*** README
    Will's personal version of miniKanren
    since he can never find the version he wants
    Includes disequality constraints
    and Aziz's trie-based susbtitutions
    [Or at least, will use the trie code once Will integrates the files!]
*** mk
    #+begin_src scheme
    (define-syntax lambdag@
      (syntax-rules ()
        ((_ (a) e) (lambda (a) e))))

    (define-syntax lambdaf@
      (syntax-rules ()
        ((_ () e) (lambda () e))))

    (define-syntax run*
      (syntax-rules ()
        ((_ (x) g ...) (run #f (x) g ...))))

    (define rhs
      (lambda (pair)
        (cdr pair)))

    (define lhs
      (lambda (pair)
        (car pair)))

    (define size-s
      (lambda (s)
        (length s)))

    (define var
      (lambda (name)
        (vector name)))

    (define var?
      (lambda (x)
        (vector? x)))

    (define s-of
      (lambda (a) a))

    (define empty-s '())

    (define empty-a empty-s)

    (define walk
      (lambda (v s)
        (cond
          ((var? v)
           (let ((a (assq v s)))
             (cond
               (a (walk (rhs a) s))
               (else v))))
          (else v))))

    (define ext-s
      (lambda (x v s)
        (cons `(,x . ,v) s)))

    (define unify
      (lambda (u v s)
        (let ((u (walk u s))
              (v (walk v s)))
          (cond
            ((eq? u v) s)
            ((var? u) (ext-s u v s))
            ((var? v) (ext-s v u s))
            ((and (pair? u) (pair? v))
             (let ((s (unify (car u) (car v) s)))
               (and s (unify (cdr u) (cdr v) s))))
            ((equal? u v) s)
            (else #f)))))

    (define unify-check
      (lambda (u v s)
        (let ((u (walk u s))
              (v (walk v s)))
          (cond
            ((eq? u v) s)
            ((var? u) (ext-s-check u v s))
            ((var? v) (ext-s-check v u s))
            ((and (pair? u) (pair? v))
             (let ((s (unify-check
                        (car u) (car v) s)))
               (and s (unify-check
                        (cdr u) (cdr v) s))))
            ((equal? u v) s)
            (else #f)))))

    (define ext-s-check
      (lambda (x v s)
        (cond
          ((occurs-check x v s) #f)
          (else (ext-s x v s)))))

    (define occurs-check
      (lambda (x v s)
        (let ((v (walk v s)))
          (cond
            ((var? v) (eq? v x))
            ((pair? v)
             (or
               (occurs-check x (car v) s)
               (occurs-check x (cdr v) s)))
            (else #f)))))

    (define walk*
      (lambda (w s)
        (let ((v (walk w s)))
          (cond
            ((var? v) v)
            ((pair? v)
             (cons
               (walk* (car v) s)
               (walk* (cdr v) s)))
            (else v)))))

    (define reify-s
      (lambda (v s)
        (let ((v (walk v s)))
          (cond
            ((var? v)
             (ext-s v (reify-name (size-s s)) s))
            ((pair? v) (reify-s (cdr v)
                         (reify-s (car v) s)))
            (else s)))))

    (define reify-name
      (lambda (n)
        (string->symbol
          (string-append "_" "." (number->string n)))))

    (define reify
      (lambda (v s)
        (let ((v (walk* v s)))
          (walk* v (reify-s v empty-s)))))

    (define mzero
      (lambda () #f))
    (define-syntax inc
      (syntax-rules () ((_ e) (lambdaf@ () e))))
    (define unit
      (lambda (a) a))
    (define choice
      (lambda (a f)
        (cons a f)))

    (define-syntax case-inf
      (syntax-rules ()
        ((_ e (() e0) ((f^) e1) ((a^) e2) ((a f) e3))
         (let ((a-inf e))
           (cond
             ((not a-inf) e0)
             ((procedure? a-inf)  (let ((f^ a-inf)) e1))
             ((not (and (pair? a-inf)
                        (procedure? (cdr a-inf))))
              (let ((a^ a-inf)) e2))
             (else (let ((a (car a-inf)) (f (cdr a-inf)))
                     e3)))))))

    (define-syntax run
      (syntax-rules ()
        ((_ n (x) g0 g ...)
         (take n
           (lambdaf@ ()
             ((exist (x) g0 g ...
                (lambdag@ (a)
                  (cons (reify x a) '())))
              empty-a))))))

    (define take
      (lambda (n f)
        (if (and n (zero? n))
          '()
          (case-inf (f)
            (() '())
            ((f) (take n f))
            ((a) a)
            ((a f)
             (cons (car a)
               (take (and n (- n 1)) f)))))))

    (define ==
      (lambda (u v)
        (lambdag@ (a)
          (unify u v a))))

    (define ==-check
      (lambda (u v)
        (lambdag@ (a)
          (unify-check u v a))))

    (define-syntax exist
      (syntax-rules ()
        ((_ (x ...) g0 g ...)
         (lambdag@ (a)
           (inc
             (let ((x (var 'x)) ...)
               (bind* (g0 a) g ...)))))))

    (define-syntax bind*
      (syntax-rules ()
        ((_ e) e)
        ((_ e g0 g ...) (bind* (bind e g0) g ...))))

    (define bind
      (lambda (a-inf g)
        (case-inf a-inf
          (() (mzero))
          ((f) (inc (bind (f) g)))
          ((a) (g a))
          ((a f) (mplus (g a) (lambdaf@ () (bind (f) g)))))))

    (define-syntax conde
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (a)
           (inc
             (mplus*
               (bind* (g0 a) g ...)
               (bind* (g1 a) g^ ...) ...))))))

    (define-syntax mplus*
      (syntax-rules ()
        ((_ e) e)
        ((_ e0 e ...) (mplus e0
                        (lambdaf@ () (mplus* e ...))))))

    (define mplus
      (lambda (a-inf f)
        (case-inf a-inf
          (() (f))
          ((f^) (inc (mplus (f) f^)))
          ((a) (choice a f))
          ((a f^) (choice a (lambdaf@ () (mplus (f) f^)))))))


    (define-syntax conda
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (a)
           (inc
             (ifa ((g0 a) g ...)
                  ((g1 a) g^ ...) ...))))))

    (define-syntax ifa
      (syntax-rules ()
        ((_) (mzero))
        ((_ (e g ...) b ...)
         (let loop ((a-inf e))
           (case-inf a-inf
             (() (ifa b ...))
             ((f) (inc (loop (f))))
             ((a) (bind* a-inf g ...))
             ((a f) (bind* a-inf g ...)))))))

    (define-syntax condu
      (syntax-rules ()
        ((_ (g0 g ...) (g1 g^ ...) ...)
         (lambdag@ (a)
           (inc
             (ifu ((g0 a) g ...)
                  ((g1 a) g^ ...) ...))))))

    (define-syntax ifu
      (syntax-rules ()
        ((_) (mzero))
        ((_ (e g ...) b ...)
         (let loop ((a-inf e))
           (case-inf a-inf
             (() (ifu b ...))
             ((f) (inc (loop (f))))
             ((a) (bind* a-inf g ...))
             ((a f) (bind* (unit a) g ...)))))))

    (define-syntax project
      (syntax-rules ()
        ((_ (x ...) g g* ...)
         (lambdag@ (a)
           (let ((x (walk* x a)) ...)
             ((exist () g g* ...) a))))))

    (define succeed (== #f #f))

    (define fail (== #f #t))

    (define onceo
      (lambda (g)
        (condu
          (g succeed)
          ((== #f #f) fail))))
    #+end_src
*** mkneverequalo
    #+begin_src scheme
    ;; (load "mk.scm")

    (define make-a (lambda (s c*) (cons s c*)))
    (define s-of (lambda (a) (car a)))
    (define c*-of (lambda (a) (cdr a)))
    (define empty-c* '())
    (define empty-a (make-a empty-s empty-c*))

    (define =/=
      (lambda (u v)
        (lambdag@ (a)
          (=/=-verify (unify u v (s-of a)) a))))

    (define =/=-verify
      (lambda (s^ a)
        (let ((s (s-of a))
              (c* (c*-of a)))
          (cond
            ((not s^) a)
            ((eq? s^ s) #f)
            (else (let ((c (prefix-s s^ s)))
                    (make-a s (cons c c*))))))))

    (define prefix-s
      (lambda (s <s)
        (cond
          ((eq? s <s) empty-s)
          (else (cons (car s) (prefix-s (cdr s) <s))))))

    (define ==
      (lambda (u v)
        (lambdag@ (a)
          (==-verify (unify u v (s-of a)) a))))

    (define ==-verify
      (lambda (s^ a)
        (let ((s (s-of a))
              (c* (c*-of a)))
          (cond
            ((not s^) #f)
            ((eq? s^ s) a)
            ((verify-c* c* empty-c* s^)
             => (lambda (c*) (make-a s^ c*)))
            (else #f)))))

    (define verify-c*
      (lambda (c* c*^ s)
        (cond
          ((null? c*) c*^)
          ((unify* (car c*) s)
           => (lambda (s^)
                (cond
                  ((eq? s s^) #f)
                  (else (let ((c (prefix-s s^ s)))
                          (verify-c* (cdr c*) (cons c c*^) s))))))
          (else (verify-c* (cdr c*) c*^ s)))))

    (define unify*
      (lambda (p* s)
        (cond
          ((null? p*) s)
          ((unify (lhs (car p*)) (rhs (car p*)) s)
           => (lambda (s) (unify* (cdr p*) s)))
          (else #f))))



    (define reify
      (lambda (v a)
        (let ((s (s-of a)))
          (let ((v (walk* v s))
                (c* (walk* (c*-of a) s)))
            (let ((r (reify-s v empty-s)))
              (let ((v (walk* v r))
                    (c* (walk* (rem-subsumed
                                 (purify c* r)
                                 empty-c*)
                               r)))
                (cond
                  ((null? c*) v)
                  (else `(,v : (never-equal . ,c*))))))))))

    (define purify
      (lambda (ls r)
        (cond
          ((null? ls) empty-c*)
          ((anyvar? (car ls) r)
           (purify (cdr ls) r))
          (else (cons (car ls)
                  (purify (cdr ls) r))))))

    (define anyvar?
      (lambda (v r)
        (cond
          ((var? v) (var? (walk v r)))
          ((pair? v) (or (anyvar? (car v) r)
                         (anyvar? (cdr v) r)))
          (else #f))))

    (define rem-subsumed
      (lambda (c* c*^)
        (cond
          ((null? c*) c*^)
          ((or (subsumed? (car c*) c*^)
               (subsumed? (car c*) (cdr c*)))
           (rem-subsumed (cdr c*) c*^))
          (else (rem-subsumed (cdr c*)
                  (cons (car c*) c*^))))))

    (define subsumed?
      (lambda (c c*)
        (and (not (null? c*))
             (or (eq? (unify* (car c*) c) c)
                 (subsumed? c (cdr c*))))))

    (define-syntax project
      (syntax-rules ()
        ((_ (x ...) g g* ...)
         (lambdag@ (a)
           (let ((s (s-of a)))
             (let ((x (walk* x s)) ...)
               ((exist () g g* ...) a)))))))

    (define ==-check
      (lambda (u v)
        (lambdag@ (a)
          (==-verify (unify-check u v (s-of a)) a))))
    #+end_src
*** mkdefs
    #+begin_src scheme
    ;; (load "mkneverequalo.scm")

    (define-syntax run1 (syntax-rules () ((_ (x) g0 g ...) (run 1 (x) g0 g ...))))
    (define-syntax run2 (syntax-rules () ((_ (x) g0 g ...) (run 2 (x) g0 g ...))))
    (define-syntax run3 (syntax-rules () ((_ (x) g0 g ...) (run 3 (x) g0 g ...))))
    (define-syntax run4 (syntax-rules () ((_ (x) g0 g ...) (run 4 (x) g0 g ...))))
    (define-syntax run5 (syntax-rules () ((_ (x) g0 g ...) (run 5 (x) g0 g ...))))
    (define-syntax run6 (syntax-rules () ((_ (x) g0 g ...) (run 6 (x) g0 g ...))))
    (define-syntax run7 (syntax-rules () ((_ (x) g0 g ...) (run 7 (x) g0 g ...))))
    (define-syntax run8 (syntax-rules () ((_ (x) g0 g ...) (run 8 (x) g0 g ...))))
    (define-syntax run9 (syntax-rules () ((_ (x) g0 g ...) (run 9 (x) g0 g ...))))
    (define-syntax run10 (syntax-rules () ((_ (x) g0 g ...) (run 10 (x) g0 g ...))))

    (define-syntax run11 (syntax-rules () ((_ (x) g0 g ...) (run 11 (x) g0 g ...))))
    (define-syntax run12 (syntax-rules () ((_ (x) g0 g ...) (run 12 (x) g0 g ...))))
    (define-syntax run13 (syntax-rules () ((_ (x) g0 g ...) (run 13 (x) g0 g ...))))
    (define-syntax run14 (syntax-rules () ((_ (x) g0 g ...) (run 14 (x) g0 g ...))))
    (define-syntax run15 (syntax-rules () ((_ (x) g0 g ...) (run 15 (x) g0 g ...))))
    (define-syntax run16 (syntax-rules () ((_ (x) g0 g ...) (run 16 (x) g0 g ...))))
    (define-syntax run17 (syntax-rules () ((_ (x) g0 g ...) (run 17 (x) g0 g ...))))
    (define-syntax run18 (syntax-rules () ((_ (x) g0 g ...) (run 18 (x) g0 g ...))))
    (define-syntax run19 (syntax-rules () ((_ (x) g0 g ...) (run 19 (x) g0 g ...))))
    (define-syntax run20 (syntax-rules () ((_ (x) g0 g ...) (run 20 (x) g0 g ...))))

    (define-syntax run21 (syntax-rules () ((_ (x) g0 g ...) (run 21 (x) g0 g ...))))
    (define-syntax run22 (syntax-rules () ((_ (x) g0 g ...) (run 22 (x) g0 g ...))))
    (define-syntax run23 (syntax-rules () ((_ (x) g0 g ...) (run 23 (x) g0 g ...))))
    (define-syntax run24 (syntax-rules () ((_ (x) g0 g ...) (run 24 (x) g0 g ...))))
    (define-syntax run25 (syntax-rules () ((_ (x) g0 g ...) (run 25 (x) g0 g ...))))
    (define-syntax run26 (syntax-rules () ((_ (x) g0 g ...) (run 26 (x) g0 g ...))))
    (define-syntax run27 (syntax-rules () ((_ (x) g0 g ...) (run 27 (x) g0 g ...))))
    (define-syntax run28 (syntax-rules () ((_ (x) g0 g ...) (run 28 (x) g0 g ...))))
    (define-syntax run29 (syntax-rules () ((_ (x) g0 g ...) (run 29 (x) g0 g ...))))
    (define-syntax run30 (syntax-rules () ((_ (x) g0 g ...) (run 30 (x) g0 g ...))))

    (define-syntax run31 (syntax-rules () ((_ (x) g0 g ...) (run 31 (x) g0 g ...))))
    (define-syntax run32 (syntax-rules () ((_ (x) g0 g ...) (run 32 (x) g0 g ...))))
    (define-syntax run33 (syntax-rules () ((_ (x) g0 g ...) (run 33 (x) g0 g ...))))
    (define-syntax run34 (syntax-rules () ((_ (x) g0 g ...) (run 34 (x) g0 g ...))))
    (define-syntax run35 (syntax-rules () ((_ (x) g0 g ...) (run 35 (x) g0 g ...))))
    (define-syntax run36 (syntax-rules () ((_ (x) g0 g ...) (run 36 (x) g0 g ...))))
    (define-syntax run37 (syntax-rules () ((_ (x) g0 g ...) (run 37 (x) g0 g ...))))
    (define-syntax run38 (syntax-rules () ((_ (x) g0 g ...) (run 38 (x) g0 g ...))))
    (define-syntax run39 (syntax-rules () ((_ (x) g0 g ...) (run 39 (x) g0 g ...))))
    (define-syntax run40 (syntax-rules () ((_ (x) g0 g ...) (run 40 (x) g0 g ...))))

    (define caro
      (lambda (p a)
        (exist (d)
          (== (cons a d) p))))

    (define cdro
      (lambda (p d)
        (exist (a)
          (== (cons a d) p))))

    (define conso
      (lambda (a d p)
        (== (cons a d) p)))

    (define nullo
      (lambda (x)
        (== '() x)))

    (define eqo
      (lambda (x y)
        (== x y)))

    (define pairo
      (lambda (p)
        (exist (a d)
          (conso a d p))))

    (define membero
      (lambda (x l)
        (conde
          ((exist (a)
             (caro l a)
             (== a x)))
          ((exist (d)
             (cdro l d)
             (membero x d))))))

    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          ((exist (a d res)
             (conso a d l)
             (rembero x d res)
             (conso a res out))))))

    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((exist (a d res)
             (conso a d l)
             (conso a res out)
             (appendo d s res))))))

    (define flatteno
      (lambda (s out)
        (conde
          ((nullo s) (== '() out))
          ((pairo s)
           (exist (a d res-a res-d)
             (conso a d s)
             (flatteno a res-a)
             (flatteno d res-d)
             (appendo res-a res-d out)))
          ((conso s '() out)))))

    (define anyo
      (lambda (g)
        (conde
          (g)
          ((anyo g)))))

    (define nevero (anyo fail))
    (define alwayso (anyo succeed))



    (define build-num
      (lambda (n)
        (cond
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2))))
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((zero? n) '()))))

    (define poso
      (lambda (n)
        (exist (a d)
          (== `(,a . ,d) n))))

    (define >1o
      (lambda (n)
        (exist (a ad dd)
          (== `(,a ,ad . ,dd) n))))

    (define full-addero
      (lambda (b x y r c)
        (conde
          ((== 0 b) (== 0 x) (== 0 y) (== 0 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 0 b) (== 1 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 1 x) (== 0 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 0 x) (== 1 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 1 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 1 b) (== 1 x) (== 1 y) (== 1 r) (== 1 c)))))

    (define addero
      (lambda (d n m r)
        (conde
          ((== 0 d) (== '() m) (== n r))
          ((== 0 d) (== '() n) (== m r)
           (poso m))
          ((== 1 d) (== '() m)
           (addero 0 n '(1) r))
          ((== 1 d) (== '() n) (poso m)
           (addero 0 '(1) m r))
          ((== '(1) n) (== '(1) m)
           (exist (a c)
             (== `(,a ,c) r)
             (full-addero d 1 1 a c)))
          ((== '(1) n) (gen-addero d n m r))
          ((== '(1) m) (>1o n) (>1o r)
           (addero d '(1) n r))
          ((>1o n) (gen-addero d n m r)))))

    (define gen-addero
      (lambda (d n m r)
        (exist (a b c e x y z)
          (== `(,a . ,x) n)
          (== `(,b . ,y) m) (poso y)
          (== `(,c . ,z) r) (poso z)
          (full-addero d a b c e)
          (addero e x y z))))

    (define pluso
      (lambda (n m k)
        (addero 0 n m k)))

    (define minuso
      (lambda (n m k)
        (pluso m k n)))

    (define *o
      (lambda (n m p)
        (conde
          ((== '() n) (== '() p))
          ((poso n) (== '() m) (== '() p))
          ((== '(1) n) (poso m) (== m p))
          ((>1o n) (== '(1) m) (== n p))
          ((exist (x z)
             (== `(0 . ,x) n) (poso x)
             (== `(0 . ,z) p) (poso z)
             (>1o m)
             (*o x m z)))
          ((exist (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(0 . ,y) m) (poso y)
             (*o m n p)))
          ((exist (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(1 . ,y) m) (poso y)
             (odd-*o x n m p))))))

    (define odd-*o
      (lambda (x n m p)
        (exist (q)
          (bound-*o q p n m)
          (*o x m q)
          (pluso `(0 . ,q) m p))))

    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((exist (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))

    (define =lo
      (lambda (n m)
        (conde
          ((== '() n) (== '() m))
          ((== '(1) n) (== '(1) m))
          ((exist (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (=lo x y))))))

    (define <lo
      (lambda (n m)
        (conde
          ((== '() n) (poso m))
          ((== '(1) n) (>1o m))
          ((exist (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (<lo x y))))))

    (define <=lo
      (lambda (n m)
        (conde
          ((=lo n m))
          ((<lo n m)))))

    (define <o
      (lambda (n m)
        (conde
          ((<lo n m))
          ((=lo n m)
           (exist (x)
             (poso x)
             (pluso n x m))))))

    (define <=o
      (lambda (n m)
        (conde
          ((== n m))
          ((<o n m)))))

    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (exist (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((exist (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((exist (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((exist (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((exist (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((exist (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))

    (define logo
     (lambda (n b q r)
       (conde
         ((== '(1) n) (poso b) (== '() q) (== '() r))
         ((== '() q) (<o n b) (pluso r '(1) n))
         ((== '(1) q) (>1o b) (=lo n b) (pluso r b n))
         ((== '(1) b) (poso q) (pluso r '(1) n))
         ((== '() b) (poso q) (== r n))
         ((== '(0 1) b)
          (exist (a ad dd)
            (poso dd)
            (== `(,a ,ad . ,dd) n)
            (exp2 n '() q)
            (exist (s)
              (splito n dd r s))))
         ((exist (a ad add ddd)
            (conde
              ((== '(1 1) b))
              ((== `(,a ,ad ,add . ,ddd) b))))
          (<lo b n)
          (exist (bw1 bw nw nw1 ql1 ql s)
            (exp2 b '() bw1)
            (pluso bw1 '(1) bw)
            (<lo q n)
            (exist (q1 bwq1)
              (pluso q '(1) q1)
              (*o bw q1 bwq1)
              (<o nw1 bwq1))
              (exp2 n '() nw1)
              (pluso nw1 '(1) nw)
              (/o nw bw ql1 s)
              (pluso ql '(1) ql1)
              (<=lo ql q)
              (exist (bql qh s qdh qd)
                (repeated-mul b ql bql)
                (/o nw bw1 qh s)
                (pluso ql qdh qh)
                (pluso ql qd q)
                (<=o qd qdh)
                (exist (bqd bq1 bq)
                  (repeated-mul b qd bqd)
                  (*o bql bqd bq)
                  (*o b bq bq1)
                  (pluso bq r n)
                  (<o n bq1))))))))

    (define exp2
      (lambda (n b q)
        (conde
          ((== '(1) n) (== '() q))
          ((>1o n) (== '(1) q)
           (exist (s)
             (splito n b s '(1))))
          ((exist (q1 b2)
             (== `(0 . ,q1) q)
             (poso q1)
             (<lo b n)
             (appendo b `(1 . ,b) b2)
             (exp2 n b2 q1)))
          ((exist (q1 nh b2 s)
             (== `(1 . ,q1) q)
             (poso q1)
             (poso nh)
             (splito n b s nh)
             (appendo b `(1 . ,b) b2)
             (exp2 nh b2 q1))))))

    (define repeated-mul
      (lambda (n q nq)
        (conde
          ((poso n) (== '() q) (== '(1) nq))
          ((== '(1) q) (== n nq))
          ((>1o q)
           (exist (q1 nq1)
             (pluso q1 '(1) q)
             (repeated-mul n q1 nq1)
             (*o nq1 n nq))))))

    (define expo
      (lambda (b q n)
        (logo n b q '())))
    #+end_src
*** prelude
    #+begin_src scheme
    (define-syntax test-check
      (syntax-rules ()
        ((_ title tested-expression expected-result)
         (begin
           (printf "Testing ~s\n" title)
           (let* ((expected expected-result)
                  (produced tested-expression))
             (or (equal? expected produced)
                 (errorf 'test-check
                   "Failed: ~a\nExpected: ~a\nComputed: ~a\n"
                   'tested-expression expected produced)))))))

    ;;;  Max fuel for engines
    (define max-ticks 10000000)

    (define-syntax test-divergence
      (syntax-rules ()
        ((_ title tested-expression)
         (begin
           (printf "Testing ~s (engine with ~s ticks fuel)\n" title max-ticks)
           ((make-engine (lambda () tested-expression))
            max-ticks
            (lambda (t v)
              (error title "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
            (lambda (e^) (void)))))))
    #+end_src
*** mktests
    #+begin_src scheme
    (load "mkneverequalo.scm")
    (load "prelude.scm")

    (define-syntax run1 (syntax-rules () ((_ (x) g0 g ...) (run 1 (x) g0 g ...))))
    (define-syntax run2 (syntax-rules () ((_ (x) g0 g ...) (run 2 (x) g0 g ...))))
    (define-syntax run3 (syntax-rules () ((_ (x) g0 g ...) (run 3 (x) g0 g ...))))
    (define-syntax run4 (syntax-rules () ((_ (x) g0 g ...) (run 4 (x) g0 g ...))))
    (define-syntax run5 (syntax-rules () ((_ (x) g0 g ...) (run 5 (x) g0 g ...))))
    (define-syntax run6 (syntax-rules () ((_ (x) g0 g ...) (run 6 (x) g0 g ...))))
    (define-syntax run7 (syntax-rules () ((_ (x) g0 g ...) (run 7 (x) g0 g ...))))
    (define-syntax run8 (syntax-rules () ((_ (x) g0 g ...) (run 8 (x) g0 g ...))))
    (define-syntax run9 (syntax-rules () ((_ (x) g0 g ...) (run 9 (x) g0 g ...))))
    (define-syntax run10 (syntax-rules () ((_ (x) g0 g ...) (run 10 (x) g0 g ...))))

    (define-syntax run11 (syntax-rules () ((_ (x) g0 g ...) (run 11 (x) g0 g ...))))
    (define-syntax run12 (syntax-rules () ((_ (x) g0 g ...) (run 12 (x) g0 g ...))))
    (define-syntax run13 (syntax-rules () ((_ (x) g0 g ...) (run 13 (x) g0 g ...))))
    (define-syntax run14 (syntax-rules () ((_ (x) g0 g ...) (run 14 (x) g0 g ...))))
    (define-syntax run15 (syntax-rules () ((_ (x) g0 g ...) (run 15 (x) g0 g ...))))
    (define-syntax run16 (syntax-rules () ((_ (x) g0 g ...) (run 16 (x) g0 g ...))))
    (define-syntax run17 (syntax-rules () ((_ (x) g0 g ...) (run 17 (x) g0 g ...))))
    (define-syntax run18 (syntax-rules () ((_ (x) g0 g ...) (run 18 (x) g0 g ...))))
    (define-syntax run19 (syntax-rules () ((_ (x) g0 g ...) (run 19 (x) g0 g ...))))
    (define-syntax run20 (syntax-rules () ((_ (x) g0 g ...) (run 20 (x) g0 g ...))))

    (define-syntax run21 (syntax-rules () ((_ (x) g0 g ...) (run 21 (x) g0 g ...))))
    (define-syntax run22 (syntax-rules () ((_ (x) g0 g ...) (run 22 (x) g0 g ...))))
    (define-syntax run23 (syntax-rules () ((_ (x) g0 g ...) (run 23 (x) g0 g ...))))
    (define-syntax run24 (syntax-rules () ((_ (x) g0 g ...) (run 24 (x) g0 g ...))))
    (define-syntax run25 (syntax-rules () ((_ (x) g0 g ...) (run 25 (x) g0 g ...))))
    (define-syntax run26 (syntax-rules () ((_ (x) g0 g ...) (run 26 (x) g0 g ...))))
    (define-syntax run27 (syntax-rules () ((_ (x) g0 g ...) (run 27 (x) g0 g ...))))
    (define-syntax run28 (syntax-rules () ((_ (x) g0 g ...) (run 28 (x) g0 g ...))))
    (define-syntax run29 (syntax-rules () ((_ (x) g0 g ...) (run 29 (x) g0 g ...))))
    (define-syntax run30 (syntax-rules () ((_ (x) g0 g ...) (run 30 (x) g0 g ...))))

    (define-syntax run31 (syntax-rules () ((_ (x) g0 g ...) (run 31 (x) g0 g ...))))
    (define-syntax run32 (syntax-rules () ((_ (x) g0 g ...) (run 32 (x) g0 g ...))))
    (define-syntax run33 (syntax-rules () ((_ (x) g0 g ...) (run 33 (x) g0 g ...))))
    (define-syntax run34 (syntax-rules () ((_ (x) g0 g ...) (run 34 (x) g0 g ...))))
    (define-syntax run35 (syntax-rules () ((_ (x) g0 g ...) (run 35 (x) g0 g ...))))
    (define-syntax run36 (syntax-rules () ((_ (x) g0 g ...) (run 36 (x) g0 g ...))))
    (define-syntax run37 (syntax-rules () ((_ (x) g0 g ...) (run 37 (x) g0 g ...))))
    (define-syntax run38 (syntax-rules () ((_ (x) g0 g ...) (run 38 (x) g0 g ...))))
    (define-syntax run39 (syntax-rules () ((_ (x) g0 g ...) (run 39 (x) g0 g ...))))
    (define-syntax run40 (syntax-rules () ((_ (x) g0 g ...) (run 40 (x) g0 g ...))))

    (test-check "=/=-1"
      (run* (q)
        (=/= 3 q)
        (== q 3))
      '())

    (test-check "=/=-2"
      (run* (q)
        (== q 3)
        (=/= 3 q))
      '())

    (test-check "=/=-3"
      (run* (q)
        (exist (x y)
          (=/= x y)
          (== x y)))
      '())

    (test-check "=/=-4"
      (run* (q)
        (exist (x y)
          (== x y)
          (=/= x y)))
      '())

    (test-check "=/=-5"
      (run* (q)
        (exist (x y)
          (=/= x y)
          (== 3 x)
          (== 3 y)))
      '())

    (test-check "=/=-6"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (=/= x y)
          (== 3 y)))
      '())

    (test-check "=/=-7"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (== 3 y)
          (=/= x y)))
      '())

    (test-check "=/=-8"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (== 3 y)
          (=/= y x)))
      '())

    (test-check "=/=-9"
      (run* (q)
        (exist (x y z)
          (== x y)
          (== y z)
          (=/= x 4)
          (== z (+ 2 2))))
      '())

    (test-check "=/=-10"
      (run* (q)
        (exist (x y z)
          (== x y)
          (== y z)
          (== z (+ 2 2))
          (=/= x 4)))
      '())

    (test-check "=/=-11"
      (run* (q)
        (exist (x y z)
          (=/= x 4)
          (== y z)
          (== x y)
          (== z (+ 2 2))))
      '())

    (test-check "=/=-12"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '(_.0))

    (test-check "=/=-13"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (== z 1)
          (== `(,x ,y) q)))
      '())

    (test-check "=/=-14"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (== z 0)))
      '(_.0))

    (test-check "=/=-15"
      (run* (q)
        (exist (x y z)
          (== z 0)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '(_.0))

    (test-check "=/=-16"
      (run* (q)
        (exist (x y z)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (=/= x y)))
      '(_.0))

    (test-check "=/=-17"
      (run* (q)
        (exist (x y z)
          (== z 1)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '())

    (test-check "=/=-18"
      (run* (q)
        (exist (x y z)
          (== z 1)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (=/= x y)))
      '())

    (test-check "=/=-19"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)))
      '(_.0))

    (test-check "=/=-20"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== y 1)))
      '(_.0))

    (test-check "=/=-21"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 1)))
      '())

    (test-check "=/=-22"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 2) (_.1 . 1))))))

    (test-check "=/=-23"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== `(,x ,y) q)))
      '(((2 _.0) : (never-equal ((_.0 . 1))))))

    (test-check "=/=-24"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 9)
          (== `(,x ,y) q)))
      '((2 9)))

    (test-check "=/=-25"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 1)
          (== `(,x ,y) q)))
      '())

    (test-check "=/=-26"
      (run* (q)
        (exist (a x z)
          (=/= a `(,x 1))
          (== a `(,z 1))
          (== x z)))
      '())

    (test-check "=/=-27"
      (run* (q)
        (exist (a x z)
          (=/= a `(,x 1))
          (== a `(,z 1))
          (== x 5)
          (== `(,x ,z) q)))
      '(((5 _.0) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-28"
      (run* (q)
        (=/= 3 4))
      '(_.0))

    (test-check "=/=-29"
      (run* (q)
        (=/= 3 3))
      '())

    (test-check "=/=-30"
      (run* (q)
        (exist (a)
          (=/= a 3)
          (== 3 a)))
      '())

    (test-check "=/=-31"
      (run* (q)
        (exist (a)
          (== 3 a)
          (=/= a 3)))
      '())

    (test-check "=/=-32"
      (run* (q)
        (exist (a)
          (== 3 a)
          (=/= a 4)))
      '(_.0))

    (test-check "=/=-33"
      (run* (q)
        (=/= 4 q)
        (=/= 3 q))
      '((_.0 : (never-equal ((_.0 . 4)) ((_.0 . 3))))))

    (test-check "=/=-34"
      (run* (q) (=/= q 5) (=/= q 5))
      '((_.0 : (never-equal ((_.0 . 5))))))

    (test-check "=/=-35"
      (let ((foo (lambda (x)
                   (exist (a)
                     (=/= x a)))))
        (run* (q) (exist (a) (foo a))))
      '(_.0))

    (test-check "=/=-36"
      (let ((foo (lambda (x)
                   (exist (a)
                     (=/= x a)))))
        (run* (q) (exist (b) (foo b))))
      '(_.0))

    (test-check "=/=-37"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-38"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= y x)))
      '(((_.0 _.1) : (never-equal ((_.1 . _.0))))))

    (test-check "=/=-39"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)
          (=/= y x)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-40"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)
          (=/= x y)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-41"
      (run* (q) (=/= q 5) (=/= 5 q))
      '((_.0 : (never-equal ((_.0 . 5))))))

    (test-check "=/=-42"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= `(,x ,y) `(5 6))
          (=/= x 5)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-43"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x 5)
          (=/= `(,x ,y) `(5 6))))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-44"
      (run* (q)
        (exist (x y)
          (=/= x 5)
          (=/= `(,x ,y) `(5 6))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-45"
      (run* (q)
        (exist (x y)
          (=/= 5 x)
          (=/= `(,x ,y) `(5 6))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-46"
      (run* (q)
        (exist (x y)
          (=/= 5 x)
          (=/= `( ,y ,x) `(6 5))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-47"
      (run* (x)
        (exist (y z)
          (=/= x `(,y 2))
          (== x `(,z 2))))
      '((_.0 2)))

    (test-check "=/=-48"
      (run* (x)
        (exist (y z)
          (=/= x `(,y 2))
          (== x `((,z) 2))))
      '(((_.0) 2)))

    (test-check "=/=-49"
      (run* (x)
        (exist (y z)
          (=/= x `((,y) 2))
          (== x `(,z 2))))
      '((_.0 2)))


    (test-check "testc11.tex-1"
    (run* (q)
      fail)

    `())

    (test-check "testc11.tex-2"
    (run* (q)
      (== #t q))

    `(#t))

    (test-check "testc11.tex-3"
    (run* (q)
      fail
      (== #t q))
    `())

     (define g fail)


    (test-check "testc11.tex-4"
    (run* (q)
      succeed
      (== #t q))
    (list #t))

    (test-check "testc11.tex-5"
    (run* (q)
      succeed
      (== #t q))

    `(#t))

    (test-check "testc11.tex-6"
    (run* (r)
      succeed
      (== 'corn r))

    (list 'corn))

    (test-check "testc11.tex-7"
    (run* (r)
      succeed
      (== 'corn r))

    `(corn))

    (test-check "testc11.tex-8"
    (run* (r)
      fail
      (== 'corn r))

    `())

    (test-check "testc11.tex-9"
    (run* (q)
      succeed
      (== #f q))

    `(#f))

    (test-check "testc11.tex-10"
    (run* (x)
      (let ((x #f))
        (== #t x)))

    '())

    (test-check "testc11.tex-11"
    (run* (q)
      (exist (x)
        (== #t x)
        (== #t q)))

    (list #t))

    (run* (q)
      (exist (x)
        (== #t x)
        (== #t q)))


    (test-check "testc11.tex-12"
    (run* (q)
      (exist (x)
        (== x #t)
        (== #t q)))

    (list #t))

    (test-check "testc11.tex-13"
    (run* (q)
      (exist (x)
        (== x #t)
        (== q #t)))

    (list #t))

    (test-check "testc11.tex-14"
    (run* (x)
      succeed)

    (list `_.0))

    (test-check "testc11.tex-15"
    (run* (x)
      (let ((x #f))
        (exist (x)
          (== #t x))))

    `(_.0))

    (test-check "testc11.tex-16"
    (run* (r)
      (exist (x y)
        (== (cons x (cons y '())) r)))

    (list `(_.0 _.1)))

    (test-check "testc11.tex-17"
    (run* (s)
      (exist (t u)
        (== (cons t (cons u '())) s)))

    (list `(_.0 _.1)))

    (test-check "testc11.tex-18"
    (run* (r)
      (exist (x)
        (let ((y x))
          (exist (x)
            (== (cons y (cons x (cons y '()))) r)))))

    (list `(_.0 _.1 _.0)))

    (test-check "testc11.tex-19"
    (run* (r)
      (exist (x)
        (let ((y x))
          (exist (x)
            (== (cons x (cons y (cons x '()))) r)))))

    (list `(_.0 _.1 _.0)))

    (test-check "testc11.tex-20"
    (run* (q)
      (== #f q)
      (== #t q))

    `())

    (test-check "testc11.tex-21"
    (run* (q)
      (== #f q)
      (== #f q))

    '(#f))

    (test-check "testc11.tex-22"
    (run* (q)
      (let ((x q))
        (== #t x)))

    (list #t))

    (test-check "testc11.tex-23"
    (run* (r)
      (exist (x)
        (== x r)))

    (list `_.0))

    (test-check "testc11.tex-24"
    (run* (q)
      (exist (x)
        (== #t x)
        (== x q)))

    (list #t))

    (test-check "testc11.tex-25"
    (run* (q)
      (exist (x)
        (== x q)
        (== #t x)))

    (list #t))

    (run* (q)
      (exist (x)
        (== #t x)
        (== x q)))


    (test-check "testc11.tex-26"
    (run* (q)
      (exist (x)
        (== (eq? x q) q)))


        (list #f))


    (test-check "testc11.tex-27"
    (run* (q)
      (let ((x q))
        (exist (q)
          (== (eq? x q) x))))

    (list #f))

    (test-check "testc11.tex-28"
    (cond
      (#f #t)
      (#t #f))

    #f)

    (test-check "testc11.tex-29"
    (cond
      (#f succeed)
      (#t fail))


        fail)


        (test-check "testc13.tex-fail1" (run* (q)


    (conde
      (fail succeed)
      (succeed fail))


        ) '())


        (test-check "testc13.tex-succeed1" (not (null? (run* (q)


    (conde
      (fail fail)
      (succeed succeed))


        ))) #t)


        (test-check "testc13.tex-succeed2" (not (null? (run* (q)


    (conde
      (succeed succeed)
      (succeed fail))


        ))) #t)


    (test-check "testc11.tex-30"
    (run* (x)
      (conde
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive oil))

    (test-check "testc11.tex-31"
    (run1 (x)
      (conde
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive))

    (test-check "testc11.tex-32"
    (run* (x)
      (conde
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        (succeed succeed)
        ((== 'oil x) succeed)))

    `(olive _.0 oil))

        (test-check "testc13.tex-conde1" (run* (x)


    (conde
      ((== 'olive x) succeed)
      (succeed succeed)
      ((== 'oil x) succeed))


        ) `(olive _.0 oil))


    (test-check "testc11.tex-33"
    (run2 (x)
      (conde
        ((== 'extra x) succeed)
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(extra olive))

    (test-check "testc11.tex-34"
    (run* (r)
      (exist (x y)
        (== 'split x)
        (== 'pea y)
        (== (cons x (cons y '())) r)))

    (list `(split pea)))

    (test-check "testc11.tex-35"
    (run* (r)
      (exist (x y)
        (conde
          ((== 'split x) (== 'pea y))
          ((== 'navy x) (== 'bean y)))
        (== (cons x (cons y '())) r)))

    `((split pea) (navy bean)))

    (test-check "testc11.tex-36"
    (run* (r)
      (exist (x y)
        (conde
          ((== 'split x) (== 'pea y))
          ((== 'navy x) (== 'bean y)))
        (== (cons x (cons y (cons 'soup '()))) r)))

    `((split pea soup) (navy bean soup)))

    (define teacupo
      (lambda (x)
        (conde
          ((== 'tea x) succeed)
          ((== 'cup x) succeed))))


    (test-check "testc11.tex-37"
    (run* (x)
      (teacupo x))

    `(tea cup))

    (test-check "testc11.tex-38"
    (run* (r)
      (exist (x y)
        (conde
          ((teacupo x) (== #t y) succeed)
          ((== #f x) (== #t y)))
        (== (cons x (cons y '())) r)))

    `((#f #t) (tea #t) (cup #t)))

    (test-check "testc11.tex-39"
    (run* (r)
      (exist (x y z)
        (conde
          ((== y x) (exist (x) (== z x)))
          ((exist (x) (== y x)) (== z x)))
        (== (cons y (cons z '())) r)))

    `((_.0 _.1) (_.0 _.1)))

    (test-check "testc11.tex-40"
    (run* (r)
      (exist (x y z)
        (conde
          ((== y x) (exist (x) (== z x)))
          ((exist (x) (== y x)) (== z x)))
        (== #f x)
        (== (cons y (cons z '())) r)))

    `((#f _.0) (_.0 #f)))

    (test-check "testc11.tex-41"
    (run* (q)
      (let ((a (== #t q))
            (b (== #f q)))
       b))

    '(#f))

    (test-check "testc11.tex-42"
    (run* (q)
      (let ((a (== #t q))
            (b (exist (x)
                 (== x q)
                 (== #f x)))
            (c (conde
                 ((== #t q) succeed)
                 (succeed (== #f q)))))
       b))

    '(#f))

    (test-check "testc12.tex-1"
    (let ((x (lambda (a) a))
          (y 'c))
      (x y))

    'c)

    (test-check "testc12.tex-2"
    (run* (r)
      (exist (y x)
        (== `(,x ,y) r)))

    (list `(_.0 _.1)))

    (test-check "testc12.tex-3"
    (run* (r)
      (exist (v w)
        (== (let ((x v) (y w)) `(,x ,y)) r)))

    `((_.0 _.1)))

    (test-check "testc12.tex-4"
    (car `(grape raisin pear))

    `grape)

    (test-check "testc12.tex-5"
    (car `(a c o r n))

    'a)


    (define caro
      (lambda (p a)
        (exist (d)
          (== (cons a d) p))))


    (test-check "testc12.tex-6"
    (run* (r)
      (caro `(a c o r n) r))

    (list 'a))

    (test-check "testc12.tex-7" 'a

              (car

    `(a c o r n)

              ))


    (test-check "testc12.tex-8"
    (run* (q)
      (caro `(a c o r n) 'a)
      (== #t q))

    (list #t))

    (test-check "testc12.tex-9" 'a

              (car

    `(a c o r n)

              ))


    (test-check "testc12.tex-10"
    (run* (r)
      (exist (x y)
        (caro `(,r ,y) x)
        (== 'pear x)))

    (list 'pear))


    (test-check "testc12.tex-11"
    (cons
      (car `(grape raisin pear))
      (car `((a) (b) (c))))

    `(grape a))

    (test-check "testc12.tex-12"
    (run* (r)
      (exist (x y)
        (caro `(grape raisin pear) x)
        (caro `((a) (b) (c)) y)
        (== (cons x y) r)))

    (list `(grape a)))

    (test-check "testc12.tex-13"
    (cdr `(grape raisin pear))

    `(raisin pear))

    (test-check "testc12.tex-14"
    (car (cdr `(a c o r n)))

    'c)


    (define cdro
      (lambda (p d)
        (exist (a)
          (== (cons a d) p))))


    (test-check "testc12.tex-15"
    (run* (r)
      (exist (v)
        (cdro `(a c o r n) v)
        (caro v r)))

    (list 'c))


    (test-check "testc12.tex-16"
    (cons
      (cdr `(grape raisin pear))
      (car `((a) (b) (c))))

    `((raisin pear) a))

    (test-check "testc12.tex-17"
    (run* (r)
      (exist (x y)
        (cdro `(grape raisin pear) x)
        (caro `((a) (b) (c)) y)
        (== (cons x y) r)))

    (list `((raisin pear) a)))

    (test-check "testc12.tex-18"
    (run* (q)
      (cdro '(a c o r n) '(c o r n))
      (== #t q))

    (list #t))

    (test-check "testc12.tex-19" `(c o r n)

       (cdr

    '(a c o r n)

       ))


    (test-check "testc12.tex-20"
    (run* (x)
      (cdro '(c o r n) `(,x r n)))

    (list 'o))

    (test-check "testc12.tex-21" `(o r n)

       (cdr

    `(c o r n)

       ))


    (test-check "testc12.tex-22"
    (run* (l)
      (exist (x)
        (cdro l '(c o r n))
        (caro l x)
        (== 'a x)))

    (list `(a c o r n)))


    (define conso
      (lambda (a d p)
        (== (cons a d) p)))


    (test-check "testc12.tex-23"
    (run* (l)
      (conso '(a b c) '(d e) l))

    (list `((a b c) d e)))

    (test-check "testc12.tex-24"
    (run* (x)
      (conso x '(a b c) '(d a b c)))

    (list 'd))

    (test-check "testc12.tex-25" (cons 'd '(a b c))
    `(d a b c))

    (test-check "testc12.tex-26"
    (run* (r)
      (exist (x y z)
        (== `(e a d ,x) r)
        (conso y `(a ,z c) r)))

    (list `(e a d c)))

    (test-check "testc12.tex-27"
    (run* (x)
      (conso x `(a ,x c) `(d a ,x c)))

    (list 'd))

             (define x 'd)


    (test-check "testc12.tex-28" (cons x `(a ,x c))
    `(d a ,x c))

    (test-check "testc12.tex-29"
    (run* (l)
      (exist (x)
        (== `(d a ,x c) l)
        (conso x `(a ,x c) l)))

    (list `(d a d c)))

    (test-check "testc12.tex-30"
    (run* (l)
      (exist (x)
        (conso x `(a ,x c) l)
        (== `(d a ,x c) l)))

    (list `(d a d c)))


    (test-check "testc12.tex-31"
    (run* (l)
      (exist (d x y w s)
        (conso w '(a n s) s)
        (cdro l s)
        (caro l x)
        (== 'b x)
        (cdro l d)
        (caro d y)
        (== 'e y)))

    (list `(b e a n s)))

    (test-check "testc12.tex-32"
    (null? `(grape raisin pear))

    #f)

    (test-check "testc12.tex-33"
    (null? '())

    #t)


    (define nullo
      (lambda (x)
        (== '() x)))


    (test-check "testc12.tex-34"
    (run* (q)
      (nullo `(grape raisin pear))
      (== #t q))

    `())

    (test-check "testc12.tex-35"
    (run* (q)
      (nullo '())
      (== #t q))

    `(#t))

    (test-check "testc12.tex-36"
    (run* (x)
      (nullo x))

    `(()))


    (test-check "testc12.tex-37"
    (eq? 'pear 'plum)

    #f)

    (test-check "testc12.tex-38"
    (eq? 'plum 'plum)

    #t)


    (define eqo
      (lambda (x y)
        (== x y)))


    (test-check "testc12.tex-39"
    (run* (q)
      (eqo 'pear 'plum)
      (== #t q))

    `())

    (test-check "testc12.tex-40"
    (run* (q)
      (eqo 'plum 'plum)
      (== #t q))

    `(#t))


    (test-check "testc12.tex-41"
    (pair? `((split) . pea))

    #t)

    (test-check "testc12.tex-42"
    (pair? '())

    #f)

    (test-check "testc12.tex-43"
    (car `(pear))

    `pear)

    (test-check "testc12.tex-44"
    (cdr `(pear))

    `())

    (test-check "testc12.tex-45"
    (cons `(split) 'pea)

    `((split) . pea))

    (test-check "testc12.tex-46"
    (run* (r)
      (exist (x y)
        (== (cons x (cons y 'salad)) r)))

    (list `(_.0 _.1 . salad)))

    (define pairo
      (lambda (p)
        (exist (a d)
          (conso a d p))))


    (test-check "testc12.tex-47"
    (run* (q)
      (pairo (cons q q))
      (== #t q))

    `(#t))

    (test-check "testc12.tex-48"
    (run* (q)
      (pairo '())
      (== #t q))

    `())

    (test-check "testc12.tex-49"
    (run* (q)
      (pairo 'pair)
      (== #t q))

    `())

    (test-check "testc12.tex-50"
    (run* (x)
      (pairo x))

    (list `(_.0 . _.1)))

    (test-check "testc12.tex-51"
    (run* (r)
      (pairo (cons r 'pear)))

    (list `_.0))

    (define new-list?
      (lambda (l)
        (cond
          ((null? l) #t)
          ((pair? l) (new-list? (cdr l)))
          (else #f))))


    (test-check "testc14.tex-1"
    (new-list? `((a) (a b) c))

    #t)

    (test-check "testc14.tex-2"
    (new-list? `())

    #t)

    (test-check "testc14.tex-3"
    (new-list? 's)

    #f)

    (test-check "testc14.tex-4"
    (new-list? `(d a t e . s))

    #f)

    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (exist (d)
             (cdro l d)
             (listo d)))
          ((== #f #f) fail))))


    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (exist (d)
             (cdro l d)
             (listo d)))
          (succeed fail))))


    (define listo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((pairo l)
           (exist (d)
             (cdro l d)
             (listo d))))))


    (test-check "testc14.tex-5"
    (run* (x)
      (listo `(a b ,x d)))

    (list `_.0))

    (test-check "testc14.tex-6"
    (run1 (x)
      (listo `(a b c . ,x)))

    (list `()))
    (define e (make-engine (lambda ()
    (run* (x)
      (listo `(a b c . ,x)))
    )))
    (printf "Testing testc14.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc14.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc14.tex-8"
    (run5 (x)
      (listo `(a b c . ,x)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3))
    )

    (define lol?
      (lambda (l)
        (cond
          ((null? l) #t)
          ((new-list? (car l)) (lol? (cdr l)))
          (else #f))))


    (define lolo
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((exist (a)
             (caro l a)
             (listo a))
           (exist (d)
             (cdro l d)
             (lolo d))))))


    (test-check "testc14.tex-9"
    (run1 (l)
      (lolo l))

    `(()))

    (test-check "testc14.tex-10"
    (run* (q)
      (exist (x y)
        (lolo `((a b) (,x c) (d ,y)))
        (== #t q)))

    (list #t))

    (test-check "testc14.tex-11"
    (run1 (q)
      (exist (x)
        (lolo `((a b) . ,x))
        (== #t q)))

    (list #t))

    (test-check "testc14.tex-12"
    (run1 (x)
      (lolo `((a b) (c d) . ,x)))

    `(()))

    (test-check "testc14.tex-13"
    (run5 (x)
      (lolo `((a b) (c d) . ,x)))


    `(()
     (())
     ((_.0))
     (() ())
     ((_.0 _.1)))
    )

    (define twinso
      (lambda (s)
        (exist (x y)
          (conso x y s)
          (conso x '() y))))


    (test-check "testc14.tex-14"
    (run* (q)
      (twinso '(tofu tofu))
      (== #t q))

    (list #t))

    (test-check "testc14.tex-15"
    (run* (z)
      (twinso `(,z tofu)))

    (list `tofu))

    (define loto
      (lambda (l)
        (conde
          ((nullo l) succeed)
          ((exist (a)
             (caro l a)
             (twinso a))
           (exist (d)
             (cdro l d)
             (loto d))))))


    (test-check "testc14.tex-16"
    (run1 (z)
      (loto `((g g) . ,z)))

    (list `()))

    (test-check "testc14.tex-17"
    (run5 (z)
      (loto `((g g) . ,z)))


    '(()
     ((_.0 _.0))
     ((_.0 _.0) (_.1 _.1))
     ((_.0 _.0) (_.1 _.1) (_.2 _.2))
     ((_.0 _.0) (_.1 _.1) (_.2 _.2) (_.3 _.3)))
    )

    (test-check "testc14.tex-18"
    (run5 (r)
      (exist (w x y z)
        (loto `((g g) (e ,w) (,x ,y) . ,z))
        (== `(,w (,x ,y) ,z) r)))


    '((e (_.0 _.0) ())
     (e (_.0 _.0) ((_.1 _.1)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2) (_.3 _.3)))
     (e (_.0 _.0) ((_.1 _.1) (_.2 _.2) (_.3 _.3) (_.4 _.4))))
    )

    (test-check "testc14.tex-19"
    (run3 (out)
      (exist (w x y z)
        (== `((g g) (e ,w) (,x ,y) . ,z) out)
        (loto out)))


    `(((g g) (e e) (_.0 _.0))
     ((g g) (e e) (_.0 _.0) (_.1 _.1))
     ((g g) (e e) (_.0 _.0) (_.1 _.1) (_.2 _.2)))
    )

    (define listofo
      (lambda (predo l)
        (conde
          ((nullo l) succeed)
          ((exist (a)
             (caro l a)
             (predo a))
           (exist (d)
             (cdro l d)
             (listofo predo d))))))


    (test-check "testc14.tex-20"
    (run3 (out)
      (exist (w x y z)
        (== `((g g) (e ,w) (,x ,y) . ,z) out)
        (listofo twinso out)))


    `(((g g) (e e) (_.0 _.0))
     ((g g) (e e) (_.0 _.0) (_.1 _.1))
     ((g g) (e e) (_.0 _.0) (_.1 _.1) (_.2 _.2)))
    )

    (define loto
      (lambda (l)
        (listofo twinso l)))


    (define member?
      (lambda (x l)
        (cond
          ((null? l) #f)
          ((eq? (car l) x) #t)
          (else (member? x (cdr l))))))


    (test-check "testc14.tex-21"
    (member? 'olive `(virgin olive oil))

    #t)

    (define membero
      (lambda (x l)
        (conde
          ((nullo l) fail)
          ((exist (a)
             (caro l a)
             (== a x))
           succeed)
          (succeed
            (exist (d)
              (cdro l d)
              (membero x d))))))


    (test-check "testc14.tex-22"
    (run* (q)
      (membero 'olive `(virgin olive oil))
      (== #t q))

    (list #t))

    (test-check "testc14.tex-23"
    (run1 (y)
      (membero y `(hummus with pita)))

    (list `hummus))

    (test-check "testc14.tex-24"
    (run1 (y)
      (membero y `(with pita)))

    (list `with))

    (test-check "testc14.tex-25"
    (run1 (y)
      (membero y `(pita)))

    (list `pita))

    (test-check "testc14.tex-26"
    (run* (y)
      (membero y `()))

    `())

    (test-check "testc14.tex-27"
    (run* (y)
      (membero y `(hummus with pita)))

    `(hummus with pita))

    (test-check "testc14.tex-28"
    (run* (x)
      (membero 'e `(pasta ,x fagioli)))

    (list `e))

    (test-check "testc14.tex-29"
    (run1 (x)
      (membero 'e `(pasta e ,x fagioli)))

    (list `_.0))

    (test-check "testc14.tex-30"
    (run1 (x)
      (membero 'e `(pasta ,x e fagioli)))

    (list `e))

    (test-check "testc14.tex-31"
    (run* (r)
      (exist (x y)
        (membero 'e `(pasta ,x fagioli ,y))
        (== `(,x ,y) r)))

    `((e _.0) (_.0 e)))

    (test-check "testc14.tex-32"
    (run1 (l)
      (membero 'tofu l))

    `((tofu . _.0)))
    (define e (make-engine (lambda ()
    (run* (l)
      (membero 'tofu l))
    )))
    (printf "Testing testc14.tex-33  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc14.tex-33 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc14.tex-34"
    (run5 (l)
      (membero 'tofu l))


    `((tofu . _.0)
     (_.0 tofu . _.1)
     (_.0 _.1 tofu . _.2)
     (_.0 _.1 _.2 tofu . _.3)
     (_.0 _.1 _.2 _.3 tofu . _.4))
    )

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x) (cdro l '()))
          ((exist (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-35"
    (run5 (l)
      (pmembero 'tofu l))


    `((tofu)
     (_.0 tofu)
     (_.0 _.1 tofu)
     (_.0 _.1 _.2 tofu)
     (_.0 _.1 _.2 _.3 tofu))
    )

    (test-check "testc14.tex-36"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t))

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x)
           (conde
             ((cdro l '()))
             (succeed)))
          ((exist (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-37"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t #t #t))

    (define pmembero
      (lambda (x l)
        (conde
          ((caro l x)
           (conde
             ((cdro l '()))
             ((exist (a d)
                (cdro l `(,a . ,d))))))
          ((exist (d)
             (cdro l d)
             (pmembero x d))))))


    (test-check "testc14.tex-38"
    (run* (q)
      (pmembero 'tofu `(a b tofu d tofu))
      (== #t q))

    `(#t #t))

    (test-check "testc14.tex-39"
    (run12 (l)
      (pmembero 'tofu l))


    `((tofu)
     (tofu _.0 . _.1)
     (_.0 tofu)
     (_.0 tofu _.1 . _.2)
     (_.0 _.1 tofu)
     (_.0 _.1 tofu _.2 . _.3)
     (_.0 _.1 _.2 tofu)
     (_.0 _.1 _.2 tofu _.3 . _.4)
     (_.0 _.1 _.2 _.3 tofu)
     (_.0 _.1 _.2  _.3 tofu _.4 . _.5 )
     (_.0 _.1 _.2 _.3 _.4 tofu)
     (_.0 _.1 _.2 _.3 _.4 tofu _.5 . _.6))
    )

    (define mem
      (lambda (x l)
        (cond
          ((null? l) #f)
          ((eq? (car l) x) l)
          (else (mem x (cdr l))))))


    (test-check "testc15.tex-1"
    (mem 'tofu `(a b tofu d peas e))

    `(tofu d peas e))

    (test-check "testc15.tex-2"
    (mem 'tofu `(a b peas d peas e))

    #f)

    (test-check "testc15.tex-3"
    (run* (out)
      (== (mem 'tofu `(a b tofu d peas e)) out))

    (list `(tofu d peas e)))

    (test-check "testc15.tex-4"
    (mem 'peas
      (mem 'tofu `(a b tofu d peas e)))

    `(peas e))

    (test-check "testc15.tex-5"
    (mem 'tofu
      (mem 'tofu `(a b tofu d tofu e)))

    `(tofu d tofu e))

    (test-check "testc15.tex-6"
    (mem 'tofu
      (cdr (mem 'tofu `(a b tofu d tofu e))))

    `(tofu e))

    (define memo
      (lambda (x l out)
        (conde
          ((nullo l) fail)
          ((exist (a)
             (caro l a)
             (== a x))
           (== l out))
          (succeed
            (exist (d)
              (cdro l d)
              (memo x d out))))))


    (define memo
      (lambda (x l out)
        (conde
          ((exist (a)
             (caro l a)
             (== a x))
           (== l out))
          ((exist (d)
             (cdro l d)
             (memo x d out))))))


    (define memo
      (lambda (x l out)
        (conde
          ((caro l x) (== l out))
          ((exist (d)
             (cdro l d)
             (memo x d out))))))


    (test-check "testc15.tex-7"
    (run1 (out)
      (memo 'tofu `(a b tofu d tofu e) out))

    `((tofu d tofu e)))

    (test-check "testc15.tex-8"
    (run1 (out)
      (exist (x)
        (memo 'tofu `(a b ,x d tofu e) out)))

    `((tofu d tofu e)))

    (test-check "testc15.tex-9"
    (run* (r)
      (memo r
        `(a b tofu d tofu e)
        `(tofu d tofu e)))

    (list `tofu))

    (test-check "testc15.tex-10"
    (run* (q)
      (memo 'tofu '(tofu e) '(tofu e))
      (== #t q))

    (list #t))

    (test-check "testc15.tex-11"
    (run* (q)
      (memo 'tofu '(tofu e) '(tofu))
      (== #t q))

    `())

    (test-check "testc15.tex-12"
    (run* (x)
      (memo 'tofu '(tofu e) `(,x e)))

    (list `tofu))

    (test-check "testc15.tex-13"
    (run* (x)
      (memo 'tofu '(tofu e) `(peas ,x)))

    `())

    (test-check "testc15.tex-14"
    (run* (out)
      (exist (x)
        (memo 'tofu `(a b ,x d tofu e) out)))

    `((tofu d tofu e) (tofu e)))

    (test-check "testc15.tex-15"
    (run12 (z)
      (exist (u)
        (memo 'tofu `(a b tofu d tofu e . ,z) u)))


    `(_.0
     _.0
     (tofu . _.0)
     (_.0 tofu . _.1)
     (_.0 _.1 tofu . _.2)
     (_.0 _.1 _.2 tofu . _.3)
     (_.0 _.1 _.2 _.3 tofu . _.4)
     (_.0 _.1 _.2 _.3 _.4 tofu . _.5)
     (_.0 _.1 _.2 _.3 _.4 _.5 tofu . _.6)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 tofu . _.7)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 _.7 tofu . _.8)
     (_.0 _.1 _.2 _.3 _.4 _.5 _.6 _.7 _.8 tofu . _.9))
    )

    (define rember
      (lambda (x l)
        (cond
          ((null? l) '())
          ((eq? (car l) x) (cdr l))
          (else
            (cons (car l)
              (rember x (cdr l)))))))


    (test-check "testc15.tex-16"
    (rember 'peas '(a b peas d peas e))

    `(a b d peas e))

    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((exist (a)
             (caro l a)
             (== a x))
           (cdro l out))
          ((exist (res)
             (exist (d)
               (cdro l d)
               (rembero x d res))
             (exist (a)
               (caro l a)
               (conso a res out)))))))


    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          ((exist (res)
             (exist (d)
               (cdro l d)
               (rembero x d res))
             (exist (a)
               (caro l a)
               (conso a res out)))))))


    (exist (res)
      (exist (d)
        (cdro l d)
        (rembero x d res))
      (exist (a)
        (caro l a)
        (conso a res out)))


    (exist (a d res)
      (cdro l d)
      (rembero x d res)
      (caro l a)
      (conso a res out))


    (define rembero
      (lambda (x l out)
        (conde
          ((nullo l) (== '() out))
          ((caro l x) (cdro l out))
          (


    (exist (a d res)
      (conso a d l)
      (rembero x d res)
      (conso a res out))


      ))))


    (test-check "testc15.tex-17"
    (run1 (out)
      (exist (y)
        (rembero 'peas `(a b ,y d peas e) out)))

    `((a b d peas e)))

    (test-check "testc15.tex-18"
    (run* (out)
      (exist (y z)
        (rembero y `(a b ,y d ,z e) out)))


    `((b a d _.0 e)
     (a b d _.0 e)
     (a b d _.0 e)
     (a b d _.0 e)
     (a b _.0 d e)
     (a b e d _.0)
     (a b _.0 d _.1 e))
    )

    (test-check "testc15.tex-19"
    (run* (r)
      (exist (y z)
        (rembero y `(,y d ,z e) `(,y d e))
        (== `(,y ,z) r)))


    `((d d)
     (d d)
     (_.0 _.0)
     (e e))
    )

    (test-check "testc15.tex-20"
    (run13 (w)
      (exist (y z out)
        (rembero y `(a b ,y d ,z . ,w) out)))


    `(_.0
     _.0
     _.0
     _.0
     _.0
     ()
     (_.0 . _.1)
     (_.0)
     (_.0 _.1 . _.2)
     (_.0 _.1)
     (_.0 _.1 _.2 . _.3)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3 . _.4))
    )

    (define surpriseo
      (lambda (s)
        (rembero s '(a b c) '(a b c))))


    (test-check "testc15.tex-21"
    (run* (r)
      (== 'd r)
      (surpriseo r))

    (list 'd))

    (test-check "testc15.tex-22"
    (run* (r)
      (surpriseo r))

    `(_.0))

    (test-check "testc15.tex-23"
    (run* (r)
      (== 'b r)
      (surpriseo r))

    `(b))

    (define new-append
      (lambda (l s)
        (cond
          ((null? l) s)
          (else (cons (car l)
                  (new-append (cdr l) s))))))


    (test-check "testc16.tex-1"
    (new-append `(a b c) `(d e))

    `(a b c d e))

    (test-check "testc16.tex-2"
    (new-append '(a b c) '())

    `(a b c))

    (test-check "testc16.tex-3"
    (new-append '() '(d e))

    `(d e))

    (test-check "testc16.tex-4"
    (new-append '(d e) 'a)

    `(d e . a))

    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((exist (a d res)
             (caro l a)
             (cdro l d)
             (appendo d s res)
             (conso a res out))))))


    (test-check "testc16.tex-5"
    (run* (x)
      (appendo
        '(cake)
        '(tastes yummy)
        x))

    (list `(cake tastes yummy)))

    (test-check "testc16.tex-6"
    (run* (x)
      (exist (y)
        (appendo
          `(cake with ice ,y)
          '(tastes yummy)
          x)))

    (list `(cake with ice _.0 tastes yummy)))

    (test-check "testc16.tex-7"
    (run* (x)
      (exist (y)
        (appendo
          '(cake with ice cream)
          y
          x)))

    (list `(cake with ice cream . _.0)))

    (test-check "testc16.tex-8"
    (run1 (x)
      (exist (y)
        (appendo `(cake with ice . ,y) '(d t) x)))

    (list `(cake with ice d t)))

    (test-check "testc16.tex-9"
    (run1 (y)
      (exist (x)
        (appendo `(cake with ice . ,y) '(d t) x)))


      (list '()))


    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((exist (a d res)
             (conso a d l)
             (appendo d s res)
             (conso a res out))))))


    (test-check "testc16.tex-10"
    (run5 (x)
      (exist (y)
        (appendo `(cake with ice . ,y) '(d t) x)))


    `((cake with ice d t)
     (cake with ice _.0 d t)
     (cake with ice _.0 _.1 d t)
     (cake with ice _.0 _.1 _.2 d t)
     (cake with ice _.0 _.1 _.2 _.3 d t))
    )

    (test-check "testc16.tex-11"
    (run5 (y)
      (exist (x)
        (appendo `(cake with ice . ,y) '(d t) x)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3))
    )

     (define y

    `(_.0 _.1 _.2)

     )


    (test-check "testc16.tex-12"
    `(cake with ice . ,y)


    `(cake with ice . (_.0 _.1 _.2))
    )

    (test-check "testc16.tex-13"
    (run5 (x)
      (exist (y)
        (appendo
          `(cake with ice . ,y)
          `(d t . ,y)
          x)))


    `((cake with ice d t)
     (cake with ice _.0 d t _.0)
     (cake with ice _.0 _.1 d t _.0 _.1)
     (cake with ice _.0 _.1 _.2 d t _.0 _.1 _.2)
     (cake with ice _.0 _.1 _.2 _.3 d t _.0 _.1 _.2 _.3))
    )

    (test-check "testc16.tex-14"
    (run* (x)
      (exist (z)
        (appendo
          `(cake with ice cream)
          `(d t . ,z)
          x)))


    `((cake with ice cream d t . _.0))
    )

    (test-check "testc16.tex-15"
    (run6 (x)
      (exist (y)
        (appendo x y `(cake with ice d t))))


    `(()
     (cake)
     (cake with)
     (cake with ice)
     (cake with ice d)
     (cake with ice d t))
    )

    (test-check "testc16.tex-16"
    (run6 (y)
      (exist (x)
        (appendo x y `(cake with ice d t))))


    `((cake with ice d t)
     (with ice d t)
     (ice d t)
     (d t)
     (t)
     ())
    )

      (define appendxyquestion
        (lambda ()


    (run6 (r)
      (exist (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))


      ))
    (define appendxyanswer


    `((() (cake with ice d t))
     ((cake) (with ice d t))
     ((cake with) (ice d t))
     ((cake with ice) (d t))
     ((cake with ice d) (t))
     ((cake with ice d t) ()))


      )
      (test-check "appendxy"
        (appendxyquestion)
        appendxyanswer)

    (define e (make-engine (lambda ()
    (run7 (r)
      (exist (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))
    )))
    (printf "Testing testc16.tex-17  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc16.tex-17 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define appendo
      (lambda (l s out)
        (conde
          ((nullo l) (== s out))
          ((exist (a d res)
             (conso a d l)
             (conso a res out)
             (appendo d s res))))))


    (test-check "testc16.tex-18"
    (run7 (r)
      (exist (x y)
        (appendo x y `(cake with ice d t))
        (== `(,x ,y) r)))


      appendxyanswer)


    (test-check "testc16.tex-19"
    (run7 (x)
      (exist (y z)
        (appendo x y z)))


    `(()
     (_.0)
     (_.0 _.1)
     (_.0 _.1 _.2)
     (_.0 _.1 _.2 _.3)
     (_.0 _.1 _.2 _.3 _.4)
     (_.0 _.1 _.2 _.3 _.4 _.5))
    )

    (test-check "testc16.tex-20"
    (run7 (y)
      (exist (x z)
        (appendo x y z)))


    `(_.0
     _.0
     _.0
     _.0
     _.0
     _.0
     _.0)
    )

    (test-check "testc16.tex-21"
    (run7 (z)
      (exist (x y)
        (appendo x y z)))


    `(_.0
     (_.0 . _.1)
     (_.0 _.1 . _.2)
     (_.0 _.1 _.2 . _.3)
     (_.0 _.1 _.2 _.3 . _.4)
     (_.0 _.1 _.2 _.3 _.4 . _.5)
     (_.0 _.1 _.2 _.3 _.4 _.5 . _.6))
    )

    (test-check "testc16.tex-22"
    (run7 (r)
      (exist (x y z)
        (appendo x y z)
        (== `(,x ,y ,z) r)))


    `((() _.0 _.0)
     ((_.0) _.1 (_.0 . _.1))
     ((_.0 _.1) _.2 (_.0 _.1 . _.2))
     ((_.0 _.1 _.2) _.3 (_.0 _.1 _.2 . _.3))
     ((_.0 _.1 _.2 _.3) _.4 (_.0 _.1 _.2 _.3 . _.4))
     ((_.0 _.1 _.2 _.3 _.4) _.5 (_.0 _.1 _.2 _.3 _.4 . _.5))
     ((_.0 _.1 _.2 _.3 _.4 _.5) _.6 (_.0 _.1 _.2 _.3 _.4 _.5 . _.6)))
    )

    (define swappendo
      (lambda (l s out)
        (conde
          ((exist (a d res)
             (conso a d l)
             (conso a res out)
             (swappendo d s res)))
          ((nullo l) (== s out)))))


    (test-check "testc16.tex-23"
    (run7 (r)
      (exist (x y z)
        (swappendo x y z)
        (== `(,x ,y ,z) r)))


    `((() _.0 _.0)
     ((_.0) _.1 (_.0 . _.1))
     ((_.0 _.1) _.2 (_.0 _.1 . _.2))
     ((_.0 _.1 _.2) _.3 (_.0 _.1 _.2 . _.3))
     ((_.0 _.1 _.2 _.3) _.4 (_.0 _.1 _.2 _.3 . _.4))
     ((_.0 _.1 _.2 _.3 _.4) _.5 (_.0 _.1 _.2 _.3 _.4 . _.5))
     ((_.0 _.1 _.2 _.3 _.4 _.5) _.6 (_.0 _.1 _.2 _.3 _.4 _.5 . _.6)))
    )

    (define unwrap
      (lambda (x)
        (cond
          ((pair? x) (unwrap (car x)))
          (else x))))


    (test-check "testc16.tex-24"
    (unwrap '((((pizza)))))

    `pizza)

    (test-check "testc16.tex-25"
    (unwrap '((((pizza pie) with)) extra cheese))

    `pizza)

    (define unwrapo
      (lambda (x out)
        (conde
          ((pairo x)
           (exist (a)
             (caro x a)
             (unwrapo a out)))
          ((== x out)))))


    (test-check "testc16.tex-26"
    (run* (x)
      (unwrapo '(((pizza))) x))


    `((((pizza)))
     ((pizza))
     (pizza)
     pizza)
      )

    (test-check "testc16.tex-27"
    (run1 (x)
      (unwrapo x 'pizza))


    `(pizza)
    )

    (test-check "testc16.tex-28"
    (run1 (x)
      (unwrapo `((,x)) 'pizza))


    `(pizza)
    )

    (test-check "testc16.tex-29"
    (run5 (x)
      (unwrapo x 'pizza))


    `(pizza
     (pizza . _.0)
     ((pizza . _.0) . _.1)
     (((pizza . _.0) . _.1) . _.2)
     ((((pizza . _.0) . _.1) . _.2) . _.3))
    )

    (test-check "testc16.tex-30"
    (run5 (x)
      (unwrapo x '((pizza))))


    `(((pizza))
     (((pizza)) . _.0)
     ((((pizza)) . _.0) . _.1)
     (((((pizza)) . _.0) . _.1) . _.2)
     ((((((pizza)) . _.0) . _.1) . _.2) . _.3))
    )

    (test-check "testc16.tex-31"
    (run5 (x)
      (unwrapo `((,x)) 'pizza))


    `(pizza
     (pizza . _.0)
     ((pizza . _.0) . _.1)
     (((pizza . _.0) . _.1) . _.2)
     ((((pizza . _.0) . _.1) . _.2) . _.3))
    )

    (define flatten
      (lambda (s)
        (cond
          ((null? s) '())
          ((pair? s)
           (new-append
             (flatten (car s))
             (flatten (cdr s))))
          (else (cons s '())))))


    (test-check "testc16.tex-32"
    (flatten '((a b) c))

    `(a b c))

    (define flatteno
      (lambda (s out)
        (conde
          ((nullo s) (== '() out))
          ((pairo s)
           (exist (a d res-a res-d)
             (conso a d s)
             (flatteno a res-a)
             (flatteno d res-d)
             (appendo res-a res-d out)))
          ((conso s '() out)))))


    (test-check "testc16.tex-33"
    (run10 (x)
      (flatteno '((a b) c) x))


    `((((a b) c))
     ((a b) (c))
     ((a b) c)
     (a (b) (c))
     ((a b) c ())
     (a (b) c)
     (a (b) c ())
     (a b (c))
     (a b () (c))
     (a b c))
    )

    (test-check "testc16.tex-34"
    (run10 (x)
      (flatteno '(a (b c)) x))


    `(((a (b c)))
     (a ((b c)))
     (a (b c))
     (a (b c) ())
     (a b (c))
     (a b (c) ())
     (a b c)
     (a b c ())
     (a b c ())
     (a b c () ()))
    )

    (test-check "testc16.tex-35"
    (run* (x)
      (flatteno '(a) x))


    `(((a))
     (a)
     (a ()))
    )

    (test-check "testc16.tex-36"
    (run* (x)
      (flatteno '((a)) x))


    `((((a)))
     ((a))
     ((a) ())
     (a)
     (a ())
     (a ())
     (a () ()))
    )

    (test-check "testc16.tex-37"
    (run* (x)
      (flatteno '(((a))) x))


    `(((((a))))
     (((a)))
     (((a)) ())
     ((a))
     ((a) ())
     ((a) ())
     ((a) () ())
     (a)
     (a ())
     (a ())
     (a () ())
     (a ())
     (a () ())
     (a () ())
     (a () () ()))
    )

      (define flattenogrumblequestion
        (lambda ()


    (run* (x)
      (flatteno '((a b) c) x))


      ))
    (define flattenogrumbleanswer


    `((((a b) c))
     ((a b) (c))
     ((a b) c)
     (a (b) (c))
     ((a b) c ())
     (a (b) c)
     (a (b) c ())
     (a b (c))
     (a b () (c))
     (a b c)
     (a b c ())
     (a b () c)
     (a b () c ()))


      )
      (test-check "flattenogrumble"
        (flattenogrumblequestion)
        flattenogrumbleanswer)

    (define e (make-engine (lambda ()
    (run* (x)
      (flatteno x '(a b c)))
    )))
    (printf "Testing testc16.tex-38  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc16.tex-38 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc16.tex-39"
    (length
      (run* (x)
        (flatteno '((((a (((b))) c))) d) x)))

    574)

    (define strangeo
      (exist ()
        strangeo))

    (define e (make-engine (lambda ()
    (run1 (x)
      strangeo)
    )))
    (printf "Testing testc17.tex-1  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-1 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-2"
    (run1 (q)
      (conde
        (strangeo)
        (succeed)))

    `(_.0))

    (define strangero
      (conde
        (strangero (conde
                     (strangero)
                     (succeed)))
        (succeed)))


    (test-check "testc17.tex-3"
    (run5 (q)
      strangero)

    `(_.0 _.0 _.0 _.0 _.0))

    (define strangesto
      (lambda (x y)
        (conde
          ((strangesto y x) (== #f y))
          ((== #f x)))))


    (test-check "testc17.tex-4"
    (run5 (q)
      (exist (x y)
        (strangesto x y)
        (== `(,x ,y) q)))

    `((#f _.0) (_.0 #f) (#f #f) (#f #f) (#f #f)))

    (define any*
      (lambda (g)
        (conde
          (g)
          ((any* g)))))


    (define never (any* fail))

    (define e (make-engine (lambda ()
    (run1 (q)
      never
      (== #t q))
    )))
    (printf "Testing testc17.tex-5  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-5 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (run1 (q)
      fail
      never)


    (define always (any* succeed))


    (test-check "testc17.tex-6"
    (run1 (q)
      always
      (== #t q))

    (list #t))
    (define e (make-engine (lambda ()
    (run* (q)
      always
      (== #t q))
    )))
    (printf "Testing testc17.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-8"
    (run5 (q)
      always
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-9"
    (run5 (q)
      (== #t q)
      always)

    `(#t #t #t #t #t))

    (define salo
      (lambda (g)
        (conde
          (succeed)
          (g))))


    (test-check "testc17.tex-10"
    (run1 (q)
      (salo always)
      (== #t q))

    `(#t))

    (test-check "testc17.tex-11"
    (run1 (q)
      (salo never)
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run* (q)
      (salo never)
      (== #t q))
    )))
    (printf "Testing testc17.tex-12  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-12 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (salo never)
      fail
      (== #t q))
    )))
    (printf "Testing testc17.tex-13  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-13 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      always
      fail
      (== #t q))
    )))
    (printf "Testing testc17.tex-14  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-14 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-15"
    (run1 (q)
      (conde
        ((== #f q) always)
        ((== #t q)))
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run2 (q)
      (conde
        ((== #f q) always)
        ((== #t q)))
      (== #t q))
    )))
    (printf "Testing testc17.tex-16  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc17.tex-16 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc17.tex-17"
    (run5 (q)
      (conde
        ((== #f q) always)
        ((any* (== #t q))))
      (== #t q))


    `(#t #t #t #t #t)
    )

    (test-check "testc17.tex-18"
    (run5 (q)
      (conde
        (always)
        (never))
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-19"
    (run1 (q)
      (exist ()
        (conde
          ((== #f q))
          ((== #t q)))
        always)
      (== #t q))

    `(#t))

    (test-check "testc17.tex-20"
    (run5 (q)
      (exist ()
        (conde
          ((== #f q))
          ((== #t q)))
        always)
      (== #t q))

    `(#t #t #t #t #t))

    (test-check "testc17.tex-21"
    (run5 (q)
      (exist ()
        (conde
          ((== #t q))
          ((== #f q)))
        always)
      (== #t q))

    `(#t #t #t #t #t))

    (define bit-xoro
      (lambda (x y r)
        (conde
          ((== 0 x) (== 0 y) (== 0 r))
          ((== 0 x) (== 1 y) (== 1 r))
          ((== 1 x) (== 0 y) (== 1 r))
          ((== 1 x) (== 1 y) (== 0 r)))))


    (test-check "testc20.tex-1"
    (run* (s)
      (exist (x y)
        (bit-xoro x y 0)
        (== `(,x ,y) s)))


    `((0 0)
     (1 1))
    )

    (test-check "testc20.tex-2"
    (run* (s)
      (exist (x y)
        (bit-xoro x y 1)
        (== `(,x ,y) s)))


    `((0 1)
     (1 0))
    )

    (test-check "testc20.tex-3"
    (run* (s)
      (exist (x y r)
        (bit-xoro x y r)
        (== `(,x ,y ,r) s)))


    `((0 0 0)
     (0 1 1)
     (1 0 1)
     (1 1 0))
    )

    (define bit-ando
      (lambda (x y r)
        (conde
          ((== 0 x) (== 0 y) (== 0 r))
          ((== 1 x) (== 0 y) (== 0 r))
          ((== 0 x) (== 1 y) (== 0 r))
          ((== 1 x) (== 1 y) (== 1 r)))))


    (test-check "testc20.tex-4"
    (run* (s)
      (exist (x y)
        (bit-ando x y 1)
        (== `(,x ,y) s)))


    `((1 1))
    )

    (define half-addero
      (lambda (x y r c)
        (exist ()
          (bit-xoro x y r)
          (bit-ando x y c))))


    (test-check "testc20.tex-5"
    (run* (r)
      (half-addero 1 1 r 1))

    (list 0))

    (test-check "testc20.tex-6"
    (run* (s)
      (exist (x y r c)
        (half-addero x y r c)
        (== `(,x ,y ,r ,c) s)))


    `((0 0 0 0)
     (0 1 1 0)
     (1 0 1 0)
     (1 1 0 1))
      )

    (define full-addero
      (lambda (b x y r c)
        (exist (w xy wz)
          (half-addero x y w xy)
          (half-addero w b r wz)
          (bit-xoro xy wz c))))


    (test-check "testc20.tex-7"
    (run* (s)
      (exist (r c)
        (full-addero 0 1 1 r c)
        (== `(,r ,c) s)))

    (list `(0 1)))

    (define full-addero
      (lambda (b x y r c)
        (conde
          ((== 0 b) (== 0 x) (== 0 y) (== 0 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 0 b) (== 1 x) (== 0 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 1 x) (== 0 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 0 x) (== 1 y) (== 1 r) (== 0 c))
          ((== 1 b) (== 0 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 0 b) (== 1 x) (== 1 y) (== 0 r) (== 1 c))
          ((== 1 b) (== 1 x) (== 1 y) (== 1 r) (== 1 c)))))


    (test-check "testc20.tex-8"
    (run* (s)
      (exist (r c)
        (full-addero 1 1 1 r c)
        (== `(,r ,c) s)))

    (list `(1 1)))

    (test-check "testc20.tex-9"
    (run* (s)
      (exist (b x y r c)
        (full-addero b x y r c)
        (== `(,b ,x ,y ,r ,c) s)))


    `((0 0 0 0 0)
     (1 0 0 1 0)
     (0 1 0 1 0)
     (1 1 0 0 1)
     (0 0 1 1 0)
     (1 0 1 0 1)
     (0 1 1 0 1)
     (1 1 1 1 1))
    )


    (define build-num
      (lambda (n)
        (cond
          ((zero? n) '())
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2)))))))


    (test-check "testc20.tex-10" `(1 0 1)

        (build-num

    5

        ))


    (test-check "testc20.tex-11" `(1 1 1)

        (build-num

    7

        ))

    (test-check "nine" (build-num
    9

        )

    `(1 0 0 1)

        )

    (test-check "six" (build-num
    6

        )

    `(0 1 1)

        )

    (test-check "nineteen" (build-num
    19

        )

    `(1 1 0 0 1)

        )

    (test-check "biggie" (build-num
    17290

        )

    `(0 1 0 1 0 0 0 1 1 1 0 0 0 0 1)

        )


    (test-check "testc20.tex-12" (build-num 0)
    `())

    (test-check "testc20.tex-13" (build-num 36)
    `(0 0 1 0 0 1))

    (test-check "testc20.tex-14" (build-num 19)
    `(1 1 0 0 1))


    (define build-num
      (lambda (n)
        (cond
          ((odd? n)
           (cons 1
             (build-num (quotient (- n 1) 2))))
          ((and (not (zero? n)) (even? n))
           (cons 0
             (build-num (quotient n 2))))
          ((zero? n) '()))))


    (define poso
      (lambda (n)
        (exist (a d)
          (== `(,a . ,d) n))))


    (test-check "testc20.tex-15"
    (run* (q)
      (poso '(0 1 1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-16"
    (run* (q)
      (poso '(1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-17"
    (run* (q)
      (poso '())
      (== #t q))

    `())

    (test-check "testc20.tex-18"
    (run* (r)
      (poso r))

    (list `(_.0 . _.1)))

    (define >1o
      (lambda (n)
        (exist (a ad dd)
          (== `(,a ,ad . ,dd) n))))


    (test-check "testc20.tex-19"
    (run* (q)
      (>1o '(0 1 1))
      (== #t q))

    (list #t))

    (test-check "testc20.tex-20"
    (run* (q)
      (>1o '(0 1))
      (== #t q))

    `(#t))

    (test-check "testc20.tex-21"
    (run* (q)
      (>1o '(1))
      (== #t q))

    `())

    (test-check "testc20.tex-22"
    (run* (q)
      (>1o '())
      (== #t q))

    `())

    (test-check "testc20.tex-23"
    (run* (r)
      (>1o r))

    (list
    `(_.0 _.1 . _.2)
    ))


    (define addero
      (lambda (d n m r)
        (conde
          ((== 0 d) (== '() m) (== n r))
          ((== 0 d) (== '() n) (== m r)
           (poso m))
          ((== 1 d) (== '() m)
           (addero 0 n '(1) r))
          ((== 1 d) (== '() n) (poso m)
           (addero 0 '(1) m r))
          ((== '(1) n) (== '(1) m)
           (exist (a c)
             (== `(,a ,c) r)
             (full-addero d 1 1 a c)))
          ((== '(1) n) (gen-addero d n m r))
          ((== '(1) m) (>1o n) (>1o r)
           (addero d '(1) n r))
          ((>1o n) (gen-addero d n m r)))))

    (define gen-addero
      (lambda (d n m r)
        (exist (a b c e x y z)
          (== `(,a . ,x) n)
          (== `(,b . ,y) m) (poso y)
          (== `(,c . ,z) r) (poso z)
          (full-addero d a b c e)
          (addero e x y z))))


    (test-check "testc20.tex-24"
    (run3 (s)
      (exist (x y r)
        (addero 0 x y r)
        (== `(,x ,y ,r) s)))


    `((_.0 () _.0)
     (() (_.0 . _.1) (_.0 . _.1))
     ((1) (1) (0 1)))
     )

    (test-check "testc20.tex-25"
    (run22 (s)
      (exist (x y r)
        (addero 0 x y r)
        (== `(,x ,y ,r) s)))


    `((_.0 () _.0)
     (() (_.0 . _.1) (_.0 . _.1))
     ((1) (1) (0 1))
     ((1) (0 _.0 . _.1) (1 _.0 . _.1))
     ((1) (1 1) (0 0 1))
     ((0 _.0 . _.1) (1) (1 _.0 . _.1))
     ((1) (1 0 _.0 . _.1) (0 1 _.0 . _.1))
     ((0 1) (0 1) (0 0 1))
     ((1) (1 1 1) (0 0 0 1))
     ((1 1) (1) (0 0 1))
     ((1) (1 1 0 _.0 . _.1) (0 0 1 _.0 . _.1))
     ((1 1) (0 1) (1 0 1))
     ((1) (1 1 1 1) (0 0 0 0 1))
     ((1 0 _.0 . _.1) (1) (0 1 _.0 . _.1))
     ((1) (1 1 1 0 _.0 . _.1) (0 0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1) (0 0 0 0 0 1))
     ((1 1 1) (1) (0 0 0 1))
     ((1) (1 1 1 1 0 _.0 . _.1) (0 0 0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1 1) (0 0 0 0 0 0 1))
     ((0 1) (1 1) (1 0 1))
     ((1 1 0 _.0 . _.1) (1) (0 0 1 _.0 . _.1))
     ((1) (1 1 1 1 1 0 _.0 . _.1) (0 0 0 0 0 1 _.0 . _.1)))
    )



    (test-check "testc20.tex-26"
    (run* (s)
      (gen-addero 1 '(0 1 1) '(1 1) s))

    (list `(0 1 0 1)))

    (test-check "testc20.tex-27"
    (run* (s)
      (exist (x y)
        (addero 0 x y '(1 0 1))
        (== `(,x ,y) s)))


    `(((1 0 1) ())
     (() (1 0 1))
     ((1) (0 0 1))
     ((0 0 1) (1))
     ((1 1) (0 1))
     ((0 1) (1 1)))
    )

    (run* (s)
      (exist (x y)
        (addero 0 x y '(1 0 1))
        (== `(,x ,y) s)))


    (define pluso
      (lambda (n m k)
        (addero 0 n m k)))


    (run* (s)
      (exist (x y)
        (pluso x y '(1 0 1))
        (== `(,x ,y) s)))


    (test-check "testc20.tex-28"
    (run* (s)
      (exist (x y)
        (pluso x y '(1 0 1))
        (== `(,x ,y) s)))


    `(((1 0 1) ())
     (() (1 0 1))
     ((1) (0 0 1))
     ((0 0 1) (1))
     ((1 1) (0 1))
     ((0 1) (1 1)))
    )

    (define minuso
      (lambda (n m k)
        (pluso m k n)))


    (test-check "testc20.tex-29"
    (run* (q)
      (minuso '(0 0 0 1) '(1 0 1) q))


    `((1 1))
    )

    (test-check "testc20.tex-30"
    (run* (q)
      (minuso '(0 1 1) '(0 1 1) q))


    `(())
    )

    (test-check "testc20.tex-31"
    (run* (q)
      (minuso '(0 1 1) '(0 0 0 1) q))


    `()
    )


    (define *o
      (lambda (n m p)
        (conde
          ((== '() n) (== '() p))
          ((poso n) (== '() m) (== '() p))
          ((== '(1) n) (poso m) (== m p))
          ((>1o n) (== '(1) m) (== n p))
          ((exist (x z)
             (== `(0 . ,x) n) (poso x)
             (== `(0 . ,z) p) (poso z)
             (>1o m)
             (*o x m z)))
          ((exist (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(0 . ,y) m) (poso y)
             (*o m n p)))
          ((exist (x y)
             (== `(1 . ,x) n) (poso x)
             (== `(1 . ,y) m) (poso y)
             (odd-*o x n m p))))))

    (define odd-*o
      (lambda (x n m p)
        (exist (q)
          (bound-*o q p n m)
          (*o x m q)
          (pluso `(0 . ,q) m p))))

    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((exist (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))


    (test-check "testc21.tex-1"
    (run34 (t)
      (exist (x y r)
        (*o x y r)
        (== `(,x ,y ,r) t)))


    `((() _.0 ())
     ((_.0 . _.1) () ())
     ((1) (_.0 . _.1) (_.0 . _.1))
     ((_.0 _.1 . _.2) (1) (_.0 _.1 . _.2))
     ((0 1) (_.0 _.1 . _.2) (0 _.0 _.1 . _.2))
     ((0 0 1) (_.0 _.1 . _.2) (0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 1) (0 1 _.0 . _.1))
     ((0 0 0 1) (_.0 _.1 . _.2) (0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 1) (0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 1) (0 0 1 _.0 . _.1))
     ((0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 1) (0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 1) (0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 1) (0 0 0 1 _.0 . _.1))
     ((1 1) (1 1) (1 0 0 1))
     ((0 0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 0 1) (0 0 0 0 1 _.0 . _.1))
     ((0 0 0 1 _.0 . _.1) (0 1) (0 0 0 0 1 _.0 . _.1))
     ((1 1) (1 0 1) (1 1 1 1))
     ((0 1 1) (1 1) (0 1 0 0 1))
     ((1 1) (1 1 1) (1 0 1 0 1))
     ((1 1) (0 1 1) (0 1 0 0 1))
     ((0 0 0 0 0 0 1) (_.0 _.1 . _.2) (0 0 0 0 0 0 _.0 _.1 . _.2))
     ((1 _.0 . _.1) (0 0 0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 1 _.0 . _.1) (0 0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 0 1 _.0 . _.1) (0 0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 0 0 1 _.0 . _.1) (0 0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((1 0 1) (1 1) (1 1 1 1))
     ((0 0 0 0 1 _.0 . _.1) (0 1) (0 0 0 0 0 1 _.0 . _.1))
     ((0 1 1) (1 0 1) (0 1 1 1 1))
     ((0 0 1 1) (1 1) (0 0 1 0 0 1))
     ((1 1) (1 0 0 1) (1 1 0 1 1)))
    )

    (test-check "testc21.tex-2"
    (run* (p)
      (*o '(0 1) '(0 0 1) p))

    (list `(0 0 0 1)))



    (define bound-*o
      (lambda (q p n m)
        succeed))


    (test-check "testc21.tex-3"
    (run1 (t)
      (exist (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))

    (list `((1) (1))))
    (define e (make-engine (lambda ()
    (run2 (t)
      (exist (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))
    )))
    (printf "Testing testc21.tex-4  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-4 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define bound-*o
      (lambda (q p n m)
        (conde
          ((nullo q) (pairo p))
          ((exist (x y z)
             (cdro q x)
             (cdro p y)
             (conde
               ((nullo n)
                (cdro m z)
                (bound-*o x y z '()))
               ((cdro n z)
                (bound-*o x y z m))))))))



    (test-check "testc21.tex-5"
    (run2 (t)
      (exist (n m)
        (*o n m '(1))
        (== `(,n ,m) t)))

    `(((1) (1))))

    (test-check "testc21.tex-6"
    (run* (p)
      (*o '(1 1 1) '(1 1 1 1 1 1) p))

    (list `(1 0 0 1 1 1 0 1 1)))

    (define =lo
      (lambda (n m)
        (conde
          ((== '() n) (== '() m))
          ((== '(1) n) (== '(1) m))
          ((exist (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (=lo x y))))))


    (test-check "testc21.tex-7"
    (run* (t)
      (exist (w x y)
        (=lo `(1 ,w ,x . ,y) '(0 1 1 0 1))
        (== `(,w ,x ,y) t)))

    (list `(_.0 _.1 (_.2 1))))

    (test-check "testc21.tex-8"
    (run* (b)
      (=lo '(1) `(,b)))

    (list 1))

    (test-check "testc21.tex-9"
    (run* (n)
      (=lo `(1 0 1 . ,n) '(0 1 1 0 1)))

    (list
    `(_.0 1)
    ))

    (test-check "testc21.tex-10"
    (run5 (t)
      (exist (y z)
        (=lo `(1 . ,y) `(1 . ,z))
        (== `(,y ,z) t)))


    `((() ())
     ((1) (1))
     ((_.0 1) (_.1 1))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1)))
    )

    (test-check "testc21.tex-11"
    (run5 (t)
      (exist (y z)
        (=lo `(1 . ,y) `(0 . ,z))
        (== `(,y ,z) t)))


    `(((1) (1))
     ((_.0 1) (_.1 1))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 1)))
    )

    (test-check "testc21.tex-12"
    (run5 (t)
      (exist (y z)
        (=lo `(1 . ,y) `(0 1 1 0 1 . ,z))
        (== `(,y ,z) t)))


    `(((_.0 _.1 _.2 1) ())
     ((_.0 _.1 _.2 _.3 1) (1))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 1))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 1))
     ((_.0 _.1 _.2 _.3 _.4 _.5 _.6 1) (_.7 _.8 _.9 1)))
    )

    (define <lo
      (lambda (n m)
        (conde
          ((== '() n) (poso m))
          ((== '(1) n) (>1o m))
          ((exist (a x b y)
             (== `(,a . ,x) n) (poso x)
             (== `(,b . ,y) m) (poso y)
             (<lo x y))))))


    (test-check "testc21.tex-13"
    (run8 (t)
      (exist (y z)
        (<lo `(1 . ,y) `(0 1 1 0 1 . ,z))
        (== `(,y ,z) t)))


    `((() _.0)
     ((1) _.0)
     ((_.0 1) _.1)
     ((_.0 _.1 1) _.2)
     ((_.0 _.1 _.2 1) (_.3 . _.4))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 . _.6))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 . _.8))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 _.8 _.9 . _.10)))
    )
    (define e (make-engine (lambda ()
    (run1 (n)
      (<lo n n))
    )))
    (printf "Testing testc21.tex-14  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-14 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define <=lo
      (lambda (n m)
        (conde
          ((=lo n m))
          ((<lo n m)))))


    (test-check "testc21.tex-15"
    (run8 (t)
      (exist (n m)
        (<=lo n m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (1))
     (() (_.0 . _.1))
     ((1) (_.0 _.1 . _.2))
     ((_.0 1) (_.1 1))
     ((_.0 1) (_.1 _.2 _.3 . _.4))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1)))
    )

    (test-check "testc21.tex-16"
    (run1 (t)
      (exist (n m)
        (<=lo n m)
        (*o n '(0 1) m)
        (== `(,n ,m) t)))

    (list `(() ())))

    (test-check "testc21.tex-17"
    (run10 (t)
      (exist (n m)
        (<=lo n m)
        (*o n '(0 1) m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (0 1))
     ((0 1) (0 0 1))
     ((1 1) (0 1 1))
     ((1 _.0 1) (0 1 _.0 1))
     ((0 0 1) (0 0 0 1))
     ((0 1 1) (0 0 1 1))
     ((1 _.0 _.1 1) (0 1 _.0 _.1 1))
     ((0 1 _.0 1) (0 0 1 _.0 1))
     ((0 0 0 1) (0 0 0 0 1)))
    )

    (test-check "testc21.tex-18"
    (run15 (t)
      (exist (n m)
        (<=lo n m)
        (== `(,n ,m) t)))


    `((() ())
     ((1) (1))
     (() (_.0 . _.1))
     ((1) (_.0 _.1 . _.2))
     ((_.0 1) (_.1 1))
     ((_.0 1) (_.1 _.2 _.3 . _.4))
     ((_.0 _.1 1) (_.2 _.3 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 1))
     ((_.0 _.1 1) (_.2 _.3 _.4 _.5 . _.6))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 _.6 _.7 . _.8))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 _.8 _.9 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 _.8 _.9 . _.10))
     ((_.0 _.1 _.2 _.3 _.4 _.5 1) (_.6 _.7 _.8 _.9 _.10 _.11 1))
     ((_.0 _.1 _.2 _.3 _.4 1) (_.5 _.6 _.7 _.8 _.9 _.10 _.11 . _.12)))
    )

    (define <o
      (lambda (n m)
        (conde
          ((<lo n m))
          ((=lo n m)
           (exist (x)
             (poso x)
             (pluso n x m))))))


    (define <=o
      (lambda (n m)
        (conde
          ((== n m))
          ((<o n m)))))


    (test-check "testc21.tex-19"
    (run* (q)
      (<o '(1 0 1) '(1 1 1))
      (== #t q))

    (list #t))

    (test-check "testc21.tex-20"
    (run* (q)
      (<o '(1 1 1) '(1 0 1))
      (== #t q))

    `())

    (test-check "testc21.tex-21"
    (run* (q)
      (<o '(1 0 1) '(1 0 1))
      (== #t q))

    `())

    (test-check "lessthanequalo-1"
      (run* (q)
        (<=o '(1 0 1) '(1 0 1))
        (== #t q))

    `(#t))

    (test-check "testc21.tex-22"
    (run6 (n)
      (<o n `(1 0 1)))


    `(() (1) (_.0 1) (0 0 1))
    )

    (test-check "testc21.tex-23"
    (run6 (m)
      (<o `(1 0 1) m))


    `((_.0 _.1 _.2 _.3 . _.4) (0 1 1) (1 1 1))
    )
    (define e (make-engine (lambda ()
    (run* (n)
      (<o n n))
    )))
    (printf "Testing testc21.tex-24  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc21.tex-24 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (exist (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((exist (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((exist (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((exist (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((exist (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((exist (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))


    (test-check "testc21.tex-25"
    (run6 (t)
      (exist (n m q r)
        (/o n m q r)
        (== `(,n ,m ,q ,r) t)))


    `((() (_.0 . _.1) () ())
     ((1) (_.0 _.1 . _.2) () (1))
     ((_.0 1) (_.1 _.2 _.3 . _.4) () (_.0 1))
     ((_.0 _.1 1) (_.2 _.3 _.4 _.5 . _.6) () (_.0 _.1 1))
     ((_.0 _.1 _.2 1) (_.3 _.4 _.5 _.6 _.7 . _.8) () (_.0 _.1 _.2 1))
     ((_.0 _.1 _.2 _.3 1) (_.4 _.5 _.6 _.7 _.8 _.9 . _.10) () (_.0 _.1 _.2 _.3 1)))
    )





    (define /o
      (lambda (n m q r)
        (conde
          ((== '() q) (== n r) (<o n m))
          ((== '(1) q) (== '() r) (== n m)
           (<o r m))
          ((<o m n) (<o r m)
           (exist (mq)
             (<=lo mq n)
             (*o m q mq)
             (pluso mq r n))))))



      (define /otest1
        (lambda ()


    (run3 (t)
      (exist (y z)
        (/o `(1 0 . ,y) '(0 1) z '())
        (== `(,y ,z) t)))


      ))
    (define e (make-engine /otest1))
    (printf "Testing testc23.tex-/otest1  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-/otest1 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (define /o
      (lambda (n m q r)
        (conde
          ((== r n) (== '() q) (<o n m))
          ((== '(1) q) (=lo n m) (pluso r m n)
           (<o r m))
          ((<lo m n)
           (<o r m)
           (poso q)
           (exist (nh nl qh ql qlm qlmr rr rh)
             (splito n r nl nh)
             (splito q r ql qh)
             (conde
               ((== '() nh)
                (== '() qh)
                (minuso nl r qlm)
                (*o ql m qlm))
               ((poso nh)
                (*o ql m qlm)
                (pluso qlm r qlmr)
                (minuso qlmr nl rr)
                (splito rr r '() rh)
                (/o nh m qh rh))))))))

    (define splito
      (lambda (n r l h)
        (conde
          ((== '() n) (== '() h) (== '() l))
          ((exist (b n^)
             (== `(0 ,b . ,n^) n)
             (== '() r)
             (== `(,b . ,n^) h)
             (== '() l)))
          ((exist (n^)
             (==  `(1 . ,n^) n)
             (== '() r)
             (== n^ h)
             (== '(1) l)))
          ((exist (b n^ a r^)
             (== `(0 ,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== '() l)
             (splito `(,b . ,n^) r^ '() h)))
          ((exist (n^ a r^)
             (== `(1 . ,n^) n)
             (== `(,a . ,r^) r)
             (== '(1) l)
             (splito n^ r^ '() h)))
          ((exist (b n^ a r^ l^)
             (== `(,b . ,n^) n)
             (== `(,a . ,r^) r)
             (== `(,b . ,l^) l)
             (poso l^)
             (splito n^ r^ l^ h))))))


    (define logo
     (lambda (n b q r)
       (conde
         ((== '(1) n) (poso b) (== '() q) (== '() r))
         ((== '() q) (<o n b) (pluso r '(1) n))
         ((== '(1) q) (>1o b) (=lo n b) (pluso r b n))
         ((== '(1) b) (poso q) (pluso r '(1) n))
         ((== '() b) (poso q) (== r n))
         ((== '(0 1) b)
          (exist (a ad dd)
            (poso dd)
            (== `(,a ,ad . ,dd) n)
            (exp2 n '() q)
            (exist (s)
              (splito n dd r s))))
         ((exist (a ad add ddd)
            (conde
              ((== '(1 1) b))
              ((== `(,a ,ad ,add . ,ddd) b))))
          (<lo b n)
          (exist (bw1 bw nw nw1 ql1 ql s)
            (exp2 b '() bw1)
            (pluso bw1 '(1) bw)
            (<lo q n)
            (exist (q1 bwq1)
              (pluso q '(1) q1)
              (*o bw q1 bwq1)
              (<o nw1 bwq1))
              (exp2 n '() nw1)
              (pluso nw1 '(1) nw)
              (/o nw bw ql1 s)
              (pluso ql '(1) ql1)
              (<=lo ql q)
              (exist (bql qh s qdh qd)
                (repeated-mul b ql bql)
                (/o nw bw1 qh s)
                (pluso ql qdh qh)
                (pluso ql qd q)
                (<=o qd qdh)
                (exist (bqd bq1 bq)
                  (repeated-mul b qd bqd)
                  (*o bql bqd bq)
                  (*o b bq bq1)
                  (pluso bq r n)
                  (<o n bq1))))))))


    (define exp2
      (lambda (n b q)
        (conde
          ((== '(1) n) (== '() q))
          ((>1o n) (== '(1) q)
           (exist (s)
             (splito n b s '(1))))
          ((exist (q1 b2)
             (== `(0 . ,q1) q)
             (poso q1)
             (<lo b n)
             (appendo b `(1 . ,b) b2)
             (exp2 n b2 q1)))
          ((exist (q1 nh b2 s)
             (== `(1 . ,q1) q)
             (poso q1)
             (poso nh)
             (splito n b s nh)
             (appendo b `(1 . ,b) b2)
             (exp2 nh b2 q1))))))


    (define repeated-mul
      (lambda (n q nq)
        (conde
          ((poso n) (== '() q) (== '(1) nq))
          ((== '(1) q) (== n nq))
          ((>1o q)
           (exist (q1 nq1)
             (pluso q1 '(1) q)
             (repeated-mul n q1 nq1)
             (*o nq1 n nq))))))


    (test-check "testc21.tex-26"
    (run* (r)
      (logo '(0 1 1 1) '(0 1) '(1 1) r))

    (list `(0 1 1)))


    (printf "This next test takes several minutes to run!\n")


    (test-check "testc21.tex-27"
    (run9 (s)
      (exist (b q r)
        (logo '(0 0 1 0 0 0 1) b q r)
        (>1o q)
        (== `(,b ,q ,r) s)))
    `((() (_.0 _.1 . _.2) (0 0 1 0 0 0 1))
     ((1) (_.0  _.1 . _.2) (1 1 0 0 0 0 1))
     ((0 1) (0 1 1) (0 0 1))
     ((1 1) (1 1) (1 0 0 1 0 1))
     ((0 0 1) (1 1) (0 0 1))
     ((0 0 0 1) (0 1) (0 0 1))
     ((1 0 1) (0 1) (1 1 0 1 0 1))
     ((0 1 1) (0 1) (0 0 0 0 0 1))
     ((1 1 1) (0 1) (1 1 0 0 1)))
    )

    (define expo
      (lambda (b q n)
        (logo n b q '())))


    (test-check "testc21.tex-28"
    (run* (t)
      (expo '(1 1) '(1 0 1) t))

    (list `(1 1 0 0 1 1 1 1)))

     (define u (var 'u))

     (define v (var 'v))

     (define w (var 'w))


     (define x (var 'x))

     (define y (var 'y))

     (define z (var 'z))


    (test-check "testc22.tex-1"
    (rhs `(,z . b))

    'b)

    (test-check "testc22.tex-2"
    (rhs `(,z . ,w))

    w)

    (test-check "testc22.tex-3"
    (rhs `(,z . (,x e ,y)))

    `(,x e ,y))


    (test-check "testc22.tex-4"
    (walk z `((,z . a) (,x . ,w) (,y . ,z)))

    'a)

    (test-check "testc22.tex-5"
    (walk y `((,z . a) (,x . ,w) (,y . ,z)))

    'a)

    (test-check "testc22.tex-6"
    (walk x `((,z . a) (,x . ,w) (,y . ,z)))

    w)

    (test-check "testc22.tex-7"
    (walk w `((,z . a) (,x . ,w) (,y . ,z)))

    w)

    (test-check "testc22.tex-8"
    (walk u `((,x . b) (,w . (,x e ,x)) (,u . ,w)))

    `(,x e ,x))


    (test-check "testc22.tex-9"
    (walk y (ext-s x 'e `((,z . ,x) (,y . ,z))))

    'e)

    (test-check "testc22.tex-10"
    (walk y `((,x . e)))

    y)

    (test-check "testc22.tex-11"
    (walk x `((,y . ,z) (,x . ,y)))

    z)

    (test-check "testc22.tex-12"
    (walk x (ext-s y z `((,x . ,y))))

    z)

    (test-check "testc22.tex-13"
    (walk x (ext-s z 'b `((,y . ,z) (,x . ,y))))

    'b)

    (test-check "testc22.tex-14"
    (walk x (ext-s z w `((,y . ,z) (,x . ,y))))

    w)


    (test-check "testc22.tex-15"
    (occurs-check z u
      `((,x . (a ,y)) (,w . (,x e ,x)) (,u . ,w) (,y . (,z))))

    #t)



    (test-check "testc22.tex-16"
    (walk* x
      `((,y . (a ,z c)) (,x . ,y) (,z . a)))

    `(a a c))

    (test-check "testc22.tex-17"
    (walk* x
      `((,y . (,z ,w c)) (,x . ,y) (,z . a)))

    `(a ,w c))

    (test-check "testc22.tex-18"
    (walk* y
      `((,y . (,w ,z c)) (,v . b) (,x . ,v) (,z . ,x)))

    `(,w b c))



    (test-check "testc22.tex-19"
    (run* (q)
      (== #f q)
      (project (q)
        (== (not (not q)) q)))

    '(#f))



    (test-check "testc22.tex-20"
    (let ((r (walk* `(,x ,y ,z) empty-s)))
      (walk* r (reify-s r empty-s)))

    `(_.0 _.1 _.2))

    (test-check "testc22.tex-21"
    (let ((r `(,u (,v (,w ,x) ,y) ,x)))
      (walk* r (reify-s r empty-s)))

    `(_.0 (_.1 (_.2 _.3) _.4) _.3))

    (test-check "testc22.tex-22"
    (let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . a))))
      (let ((r (walk* x s)))
        (walk* r (reify-s r empty-s))))

    `(a _.0 c _.0))

    (test-check "testc22.tex-23"
    (let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . ,u))))
      (let ((r (walk* x s)))
        (walk* r (reify-s r empty-s))))

    `(_.0 _.1 c _.1))


    ;(test-check "testc22.tex-24"
    ;(let ((s `((,y . (,z ,w c ,w)) (,x . ,y) (,z . a))))
    ;  (reify x s))
    ;`(a _.0 c _.0))

    (define e (make-engine (lambda ()
    (run1 (x)
      (== `(,x) x))
    )))
    (printf "Testing testc22.tex-25  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-25 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))



    (test-check "testc22.tex-26"
    (run1 (q)
      (exist (x)
        (== `(,x) x)
        (== #t q)))

    `(#t))

    (test-check "testc22.tex-27"
    (run1 (q)
      (exist (x y)
        (== `(,x) y)
        (== `(,y) x)
        (== #t q)))

    `(#t))

    (test-check "testc22.tex-28"
    (run1 (x)
      (==-check `(,x) x))

    `())
    (define e (make-engine (lambda ()
    (run1 (x)
      (exist (y z)
        (== x z)
        (== `(a b ,z) y)
        (== x y)))
    )))
    (printf "Testing testc22.tex-29  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-29 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc22.tex-30"
    (run1 (x)
      (exist (y z)
        (== x z)
        (== `(a b ,z) y)
        (==-check x y)))

    `())
    (define e (make-engine (lambda ()
    (run1 (x)
      (== `(,x) x))
    )))
    (printf "Testing testc22.tex-31  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc22.tex-31 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


        (test-check "testc23.tex-fail1" (run* (q)


    (conda
      (fail succeed)
      (fail))


        ) '())


        (test-check "testc23.tex-succeed1" (not (null? (run* (q)


    (conda
      (fail succeed)
      (succeed))


        ))) #t)


        (test-check "testc23.tex-succeed1" (not (null? (run* (q)


    (conda
      (succeed fail)
      (succeed))


        ))) #f)


        (test-check "testc23.tex-succeed2" (not (null? (run* (q)


    (conda
      (succeed succeed)
      (fail))


        ))) #t)


    (test-check "testc23.tex-1"
    (run* (x)
      (conda
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `(olive))

    (test-check "testc23.tex-2"
    (run* (x)
      (conda
        ((== 'virgin x) fail)
        ((== 'olive x) succeed)
        ((== 'oil x) succeed)))

    `())

    (test-check "testc23.tex-3"
    (run* (q)
      (exist (x y)
        (== 'split x)
        (== 'pea y)
        (conda
          ((== 'split x) (== x y))
          (succeed)))
      (== #t q))

    `())

    (test-check "testc23.tex-4"
    (run* (q)
      (exist (x y)
        (== 'split x)
        (== 'pea y)
        (conda
          ((== x y) (== 'split x))
          (succeed)))
      (== #t q))

    (list #t))

    (define notpastao
      (lambda (x)
        (conda
          ((== 'pasta x) fail)
          (succeed))))


    (test-check "testc23.tex-5"
    (run* (x)
      (conda
        ((notpastao x) fail)
        ((== 'spaghetti x))))

    '(spaghetti))

    (test-check "testc23.tex-6"
    (run* (x)
      (== 'spaghetti x)
      (conda
        ((notpastao x) fail)
        ((== 'spaghetti x))))

    '())
    (define e (make-engine (lambda ()
    (run* (q)
      (conda
        (always succeed)
        (fail))
      (== #t q))
    )))
    (printf "Testing testc23.tex-7  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-7 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc23.tex-8"
    (run* (q)
      (condu
        (always succeed)
        (fail))
      (== #t q))

    `(#t))
    (define e (make-engine (lambda ()
    (run* (q)
      (condu
        (succeed always)
        (fail))
      (== #t q))
    )))
    (printf "Testing testc23.tex-9  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-9 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (conda
        (always succeed)
        (fail))
      fail
      (== #t q))
    )))
    (printf "Testing testc23.tex-10  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-10 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (test-check "testc23.tex-11"
    (run1 (q)
      (condu
        (always succeed)
        (fail))
      fail
      (== #t q))

    `())

    (define onceo
      (lambda (g)
        (condu
          (g succeed))))


    (test-check "testc23.tex-12"
    (run* (x)
      (onceo (teacupo x)))

    `(tea))

    (test-check "testc23.tex-13"
    (run1 (q)
      (onceo (salo never))
      fail)

    `())

    (test-check "testc23.tex-14"
    (run* (r)
      (conde
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f tea cup))

    (test-check "testc23.tex-15"
    (run* (r)
      (conda
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(tea cup))

    (test-check "testc23.tex-16"
    (run* (r)
      (== #f r)
      (conda
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f))

    (test-check "testc23.tex-17"
    (run* (r)
      (== #f r)
      (condu
        ((teacupo r) succeed)
        ((== #f r) succeed)))

    `(#f))

    (define bumpo
      (lambda (n x)
        (conde
          ((== n x) succeed)
          ((exist (m)
             (minuso n '(1) m)
             (bumpo m x))))))


    (test-check "testc23.tex-18"
    (run* (x)
      (bumpo '(1 1 1) x))


    `((1 1 1)
     (0 1 1)
     (1 0 1)
     (0 0 1)
     (1 1)
     (0 1)
     (1)
     ())
    )

    (define gen&testo
      (lambda (op i j k)
        (onceo
          (exist (x y z)
            (op x y z)
            (== i x)
            (== j y)
            (== k z)))))


    (test-check "testc23.tex-19"
    (run* (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(1 1 1))
      (== #t q))

    (list
    #t
    ))
    (define e (make-engine (lambda ()
    (run1 (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(0 1 1)))
    )))
    (printf "Testing testc23.tex-20  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-20 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))

    (define e (make-engine (lambda ()
    (run1 (q)
      (gen&testo pluso '(0 0 1) '(1 1) '(0 1 1)))
    )))
    (printf "Testing testc23.tex-21  (engine with ~s ticks fuel)\n" max-ticks)
    (e max-ticks
    (lambda (t v) (error 'testc23.tex-21 "infinite loop returned ~s after ~s ticks" v (- max-ticks t)))
    (lambda (e^) (void)))


    (define enumerateo
      (lambda (op r n)
        (exist (i j k)
          (bumpo n i)
          (bumpo n j)
          (op i j k)
          (gen&testo op i j k)
          (== `(,i ,j ,k) r))))


    (test-check "testc23.tex-22"
    (run* (s)
      (enumerateo pluso s '(1 1)))


    `(((1 1) (1 1) (0 1 1))
     ((1 1) (0 1) (1 0 1))
     ((1 1) () (1 1))
     ((0 1) (1 1) (1 0 1))
     ((1 1) (1) (0 0 1))
     ((1) (1 1) (0 0 1))
     ((0 1) (0 1) (0 0 1))
     (() (1 1) (1 1))
     ((0 1) () (0 1))
     ((0 1) (1) (1 1))
     ((1) (0 1) (1 1))
     ((1) (1) (0 1))
     ((1) () (1))
     (() (0 1) (0 1))
     (() (1) (1))
     (() () ()))
    )

    (run* (s)
      (enumerateo pluso s '(1 1)))


    (test-check "testc23.tex-23"
    (run1 (s)
      (enumerateo pluso s '(1 1 1)))


    `(((1 1 1) (1 1 1) (0 1 1 1)))
    )







    ;;;  Will's toys:

    (define proof-that-exist-needs-an-inc
      (exist ()
        (proof-that-exist-needs-an-inc)))

    (test-check 'proof-that-run-needs-an-inc
      (run 1 (q)
        (conde
          (proof-that-exist-needs-an-inc)
          (succeed)))
      '(_.0))

    (define proof-that-exist-needs-an-inc-with-conda
      (conda
        (proof-that-exist-needs-an-inc)))

    (test-check 'proof-that-run-needs-an-inc-with-conde-and-conda
      (run 1 (q)
        (conde
          (proof-that-exist-needs-an-inc)
          (succeed)))
      '(_.0))

    (define proof-that-exist-needs-an-inc-with-conda
      (exist ()
        (conda
          (proof-that-exist-needs-an-inc succeed))))

    (test-check 'proof-that-run-needs-an-inc-with-conde
      (run 1 (q)
        (conde
          (proof-that-exist-needs-an-inc succeed)
          (succeed)))
      '(_.0))

    (test-check 'why-conde-must-also-have-an-inc
      ((make-engine
         (lambda ()
           (run 5 (q)
             (letrec ((f (exist ()
                           (conde
                             (f (conde
                                  (f)
                                  (succeed)))
                             (succeed)))))
               f))))
       100000
       (lambda (x y) y)
       list)
      '(_.0 _.0 _.0 _.0 _.0))
    #+end_src
*** neverequalotests
    #+begin_src scheme
    (load "mkneverequalo.scm")
    (load "prelude.scm")

    (test-check "=/=-1"
      (run* (q)
        (=/= 3 q)
        (== q 3))
      '())

    (test-check "=/=-2"
      (run* (q)
        (== q 3)
        (=/= 3 q))
      '())

    (test-check "=/=-3"
      (run* (q)
        (exist (x y)
          (=/= x y)
          (== x y)))
      '())

    (test-check "=/=-4"
      (run* (q)
        (exist (x y)
          (== x y)
          (=/= x y)))
      '())

    (test-check "=/=-5"
      (run* (q)
        (exist (x y)
          (=/= x y)
          (== 3 x)
          (== 3 y)))
      '())

    (test-check "=/=-6"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (=/= x y)
          (== 3 y)))
      '())

    (test-check "=/=-7"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (== 3 y)
          (=/= x y)))
      '())

    (test-check "=/=-8"
      (run* (q)
        (exist (x y)
          (== 3 x)
          (== 3 y)
          (=/= y x)))
      '())

    (test-check "=/=-9"
      (run* (q)
        (exist (x y z)
          (== x y)
          (== y z)
          (=/= x 4)
          (== z (+ 2 2))))
      '())



    (test-check "=/=-10"
      (run* (q)
        (exist (x y z)
          (== x y)
          (== y z)
          (== z (+ 2 2))
          (=/= x 4)))
      '())

    (test-check "=/=-11"
      (run* (q)
        (exist (x y z)
          (=/= x 4)
          (== y z)
          (== x y)
          (== z (+ 2 2))))
      '())

    (test-check "=/=-12"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '(_.0))

    (test-check "=/=-13"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (== z 1)
          (== `(,x ,y) q)))
      '())

    (test-check "=/=-14"
      (run* (q)
        (exist (x y z)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (== z 0)))
      '(_.0))

    (test-check "=/=-15"
      (run* (q)
        (exist (x y z)
          (== z 0)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '(_.0))

    (test-check "=/=-16"
      (run* (q)
        (exist (x y z)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (=/= x y)))
      '(_.0))








    (test-check "=/=-17"
      (run* (q)
        (exist (x y z)
          (== z 1)
          (=/= x y)
          (== x `(0 ,z 1))
          (== y `(0 1 1))))
      '())

    (test-check "=/=-18"
      (run* (q)
        (exist (x y z)
          (== z 1)
          (== x `(0 ,z 1))
          (== y `(0 1 1))
          (=/= x y)))
      '())

    (test-check "=/=-19"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)))
      '(_.0))

    (test-check "=/=-20"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== y 1)))
      '(_.0))

    (test-check "=/=-21"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 1)))
      '())

    (test-check "=/=-22"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 2) (_.1 . 1))))))

    (test-check "=/=-23"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== `(,x ,y) q)))
      '(((2 _.0) : (never-equal ((_.0 . 1))))))

    (test-check "=/=-24"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 9)
          (== `(,x ,y) q)))
      '((2 9)))






    (test-check "=/=-25"
      (run* (q)
        (exist (x y)
          (=/= `(,x 1) `(2 ,y))
          (== x 2)
          (== y 1)
          (== `(,x ,y) q)))
      '())

    (test-check "=/=-26"
      (run* (q)
        (exist (a x z)
          (=/= a `(,x 1))
          (== a `(,z 1))
          (== x z)))
      '())

    (test-check "=/=-27"
      (run* (q)
        (exist (a x z)
          (=/= a `(,x 1))
          (== a `(,z 1))
          (== x 5)
          (== `(,x ,z) q)))
      '(((5 _.0) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-28"
      (run* (q)
        (=/= 3 4))
      '(_.0))

    (test-check "=/=-29"
      (run* (q)
        (=/= 3 3))
      '())

    (test-check "=/=-30"
      (run* (q)
        (exist (a)
          (=/= a 3)
          (== 3 a)))
      '())

    (test-check "=/=-31"
      (run* (q)
        (exist (a)
          (== 3 a)
          (=/= a 3)))
      '())

    (test-check "=/=-32"
      (run* (q)
        (exist (a)
          (== 3 a)
          (=/= a 4)))
      '(_.0))

    (test-check "=/=-33"
      (run* (q)
        (=/= 4 q)
        (=/= 3 q))
      '((_.0 : (never-equal ((_.0 . 4)) ((_.0 . 3))))))

    (test-check "=/=-34"
      (run* (q) (=/= q 5) (=/= q 5))
      '((_.0 : (never-equal ((_.0 . 5))))))



    (test-check "=/=-35"
      (let ((foo (lambda (x)
                   (exist (a)
                     (=/= x a)))))
        (run* (q) (exist (a) (foo a))))
      '(_.0))

    (test-check "=/=-36"
      (let ((foo (lambda (x)
                   (exist (a)
                     (=/= x a)))))
        (run* (q) (exist (b) (foo b))))
      '(_.0))

    (test-check "=/=-37"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-38"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= y x)))
      '(((_.0 _.1) : (never-equal ((_.1 . _.0))))))

    (test-check "=/=-39"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)
          (=/= y x)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-40"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x y)
          (=/= x y)))
      '(((_.0 _.1) : (never-equal ((_.0 . _.1))))))

    (test-check "=/=-41"
      (run* (q) (=/= q 5) (=/= 5 q))
      '((_.0 : (never-equal ((_.0 . 5))))))

    (test-check "=/=-42"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= `(,x ,y) `(5 6))
          (=/= x 5)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-43"
      (run* (q)
        (exist (x y)
          (== `(,x ,y) q)
          (=/= x 5)
          (=/= `(,x ,y) `(5 6))))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))






    (test-check "=/=-44"
      (run* (q)
        (exist (x y)
          (=/= x 5)
          (=/= `(,x ,y) `(5 6))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-45"
      (run* (q)
        (exist (x y)
          (=/= 5 x)
          (=/= `(,x ,y) `(5 6))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-46"
      (run* (q)
        (exist (x y)
          (=/= 5 x)
          (=/= `( ,y ,x) `(6 5))
          (== `(,x ,y) q)))
      '(((_.0 _.1) : (never-equal ((_.0 . 5))))))

    (test-check "=/=-47"
      (run* (x)
        (exist (y z)
          (=/= x `(,y 2))
          (== x `(,z 2))))
      '((_.0 2)))

    (test-check "=/=-48"
      (run* (x)
        (exist (y z)
          (=/= x `(,y 2))
          (== x `((,z) 2))))
      '(((_.0) 2)))

    (test-check "=/=-49"
      (run* (x)
        (exist (y z)
          (=/= x `((,y) 2))
          (== x `(,z 2))))
      '((_.0 2)))
    #+end_src
* mk-c
  #+begin_src scheme
  ;;; miniKanren from Dan Friedman, William Byrd and Oleg Kiselyov

  ;;; modified by Yin Wang to support a constraint-based negation operator
  ;;; (noto) and a disjoint branching operator (condc). The
  ;;; limitation is that they cannot be nested.

  ;;; Lazy streams are used to make the connections more modular.

  ;;; This file was generated by writeminikanren.pl
  ;;; Generated at 2007-10-25 15:24:42

  (define *debug-tags* '())
  (define debug
    (lambda (tags format . args)
      (let* ((tags (if (not (pair? tags)) (list tags) tags))
             (fs (string-append "[" (symbol->string (car tags)) "] " format "\n")))
        (cond
         [(null? tags)]
         [(pair? tags)
          (if (member (car tags) *debug-tags*)
              (apply printf fs args)
              (void))]
         ))))



  (define-syntax lambdag@
    (syntax-rules ()
      ((_ (p ...) e ...) (lambda (p ...) e ...))))


  (define-syntax lambdaf@
    (syntax-rules ()
      ((_ () e ...) (lambda () e ...))))


  (define-syntax inc
    (syntax-rules () ((_ e) (lambdaf@ () e))))


  (define defunc
    (lambda (f)
      (if (procedure? f) (defunc (f)) f)))



  ;;------------ stream primitives ------------
  (define snull 'snull)


  (define snull?
    (lambda (s)
      (eq? s snull)))


  (define-syntax scons
    (syntax-rules ()
      ((_ a d) (cons a (lambda () d)))))


  (define scar
    (lambda (s)
      (cond
       [(procedure? s) (scar (s))]
       [else (car s)])))


  (define scdr
    (lambda (s)
      (cond
       [(procedure? s) (scdr (s))]
       [else ((cdr s))])))


  (define-syntax sunit
    (syntax-rules ()
      ((_ a) (scons a snull))))


  (define slift
    (lambda (f)
      (lambda args
        (sunit (apply f args)))))


  (define-syntax make-stream
    (syntax-rules ()
      ((_) snull)
      ((_ e1 e2 ...) (scons e1 (make-stream e2 ...)))))


  (define taken
    (lambda (n s)
      (if (and n (zero? n))
          '()
          (let ([s (defunc s)])
            (cond
             [(snull? s) '()]
             [else (cons (scar s) (taken (and n (- n 1)) (scdr s)))])))))


  (define smerge
    (lambda (s1 s2)
      (cond
       [(snull? s1) s2]
       [(procedure? s1)
        (lambda () (smerge s2 (s1)))]
       [else (scons (scar s1) (smerge s2 (scdr s1)))])))


  (define stream-merge
    (lambda (ss)
      (cond
       [(snull? ss) snull]
       [(procedure? ss) (lambda () (stream-merge (ss)))]
       [(snull? (scar ss)) (stream-merge (scdr ss))]
       [(procedure? (scar ss)) (lambda ()
                                 (smerge (stream-merge (scdr ss))
                                         (scar ss)))]
       [else (scons (scar (scar ss)) (smerge (scdr (scar ss))
                                             (stream-merge (scdr ss))))])))

  (define smap
    (lambda (f s)
      (cond
       [(snull? s) snull]
       [(procedure? s) (lambda () (smap f (s)))]
       [else (scons (f (scar s)) (smap f (scdr s)))])))



  ;; Substitution
  (define-syntax rhs
    (syntax-rules ()
      ((_ x) (cdr x))))


  (define-syntax lhs
    (syntax-rules ()
      ((_ x) (car x))))


  (define-syntax size-s
    (syntax-rules ()
      ((_ x) (length x))))


  (define-syntax var
    (syntax-rules ()
      ((_ x) (vector x))))


  (define-syntax var?
    (syntax-rules ()
      ((_ x) (vector? x))))


  (define empty-s '())

  (define ext-s
    (lambda (x v s)
      (cons `(,x . ,v) s)))


  (define walk
    (lambda (v s)
      (cond
        ((var? v)
         (let ((a (assq v s)))
           (cond
             (a (walk (rhs a) s))
             (else v))))
        (else v))))


  (define unify
    (lambda (v w s env)
      ((Env-unify env) v w s env)))


  (define unify-good
    (lambda (v w s env)
  ;    (printf "[unify-good]: ~a <--> ~a :: ~a\n" v w s)
      (let ((v (walk v s))
            (w (walk w s)))
        (cond
          ((eq? v w) s)
          ((var? v) (ext-s v w s))
          ((var? w) (ext-s w v s))
          ((and (pair? v) (pair? w))
           (let ((s (unify-good (car v) (car w) s env)))
             (and s (unify-good (cdr v) (cdr w) s env))))
          ((equal? v w) s)
          (else #f)))))


  (define unify-evil
    (lambda (v w s env)
      (debug '(unify-evil unify)
             "v=~a, w=~a, cvars: ~a\n  subst:~a" v w (Env-cvars env) s)
      (let ((vv (walk v s))
            (ww (walk w s)))
        (cond
         ((eq? vv ww) s)
         ((and (var? vv) (memq v (Env-cvars env))) #f)
         ((and (var? ww) (memq w (Env-cvars env))) #f)
         ((var? vv) (ext-s vv ww s))
         ((var? ww) (ext-s ww vv s))
         ((and (pair? vv) (pair? ww))
          (let ((s (unify-evil (car vv) (car ww) s env)))
            (and s (unify-evil (cdr vv) (cdr ww) s env))))
         ((equal? vv ww) s)
         (else #f)))))


  (define switch-unify
    (lambda (env)
      (if (eq? (Env-unify env) unify-good)
          (change-unify env unify-evil)
          (change-unify env unify-good))))


  (define unify-check
    (lambda (u v s)
      (let ((u (walk u s))
            (v (walk v s)))
        (cond
          ((eq? u v) s)
          ((var? u) (ext-s-check u v s))
          ((var? v) (ext-s-check v u s))
          ((and (pair? u) (pair? v))
           (let ((s (unify-check (car u) (car v) s)))
             (and s (unify-check (cdr u) (cdr v) s))))
          ((equal? u v) s)
          (else #f)))))


  (define ext-s-check
    (lambda (x v s)
      (cond
        ((occurs-check x v s) #f)
        (else (ext-s x v s)))))


  (define occurs-check
    (lambda (x v s)
      (let ((v (walk v s)))
        (cond
          ((var? v) (eq? v x))
          ((pair? v)
           (or
             (occurs-check x (car v) s)
             (occurs-check x (cdr v) s)))
          (else #f)))))


  (define walk*
    (lambda (w s)
      (let ((v (walk w s)))
        (cond
          ((var? v) v)
          ((pair? v)
           (cons
             (walk* (car v) s)
             (walk* (cdr v) s)))
          (else v)))))


  (define reify-s
    (lambda (v s)
      (debug 'reify-s "v: ~a\ns:~a" v s)
      (let ((v (walk v s)))
        (cond
          ((var? v)
           (ext-s v (reify-name (size-s s)) s))
          ((pair? v) (reify-s (cdr v)
                       (reify-s (car v) s)))
          (else s)))))


  (define reify-name
    (lambda (n)
      (string->symbol
        (string-append "_" "." (number->string n)))))


  (define reify
    (lambda (v s)
      (let ((v (walk* v s)))
        (walk* v (reify-s v empty-s)))))





  ;-------------------------------------------------------------
  ;                     data structures
  ;-------------------------------------------------------------

  (struct Pkg (subst constraints) #:transparent)


  ;; constraints save the current environment vars
  (struct Constraint (goal vars text) #:transparent)


  ;; environment
  (struct Env (unify constraints vars cvars) #:transparent)

  (define Env-constraint-goals
    (lambda (p)
      (map Constraint-goal (Env-constraint p))))


  (define ext-pkg-constraints
    (lambda (p cs ctexts env)
      (let ([newc (map (lambda (g t)
                         (Constraint g (Env-vars env) t))
                       cs ctexts)])
        (Pkg (Pkg-subst p) (append newc (Pkg-constraints p))))))



  ;; convenience functions
  (define change-unify
    (lambda (p u)
      (match p
        [(Env _ constraints vars cvars)
         (Env u constraints vars cvars)])))


  (define change-constraints
    (lambda (p c)
      (match p
        [(Env unify _ vars cvars)
         (Env unify c vars cvars)])))


  (define change-vars
    (lambda (p v)
      (match p
        [(Env unify constraints _ cvars)
         (Env unify constraints v cvars)])))


  (define change-cvars
    (lambda (p cv)
      (match p
        [(Env unify constraints vars _)
         (Env unify constraints vars cv)])))


  (define ext-constraint
    (lambda (env new-cg)
      (let ([newc (map (lambda (g) (Constraint g (Env-vars env) 'a))
                       new-cg)])
        (change-constraints env newc))))


  (define ext-vars
    (lambda (env new-vars)
      (change-vars env (append new-vars (Env-vars env)))))


  (define ext-cvars
    (lambda (env new-cvars)
      (change-cvars env (append new-cvars (Env-cvars env)))))






  ;-------------------------------------------------------------
  ;                       miniKanren
  ;-------------------------------------------------------------

  (define succeed (lambda (s env) (sunit s)))
  (define fail (lambda (s env) snull))


  (define bind
    (lambda (s f env)
      (cond
       [(procedure? s) (lambda () (bind (s) f env))]
       [else
        (stream-merge (smap (lambda (s) (f s env)) s))])))


  (define bind*
    (lambda (s goals env)
      (cond
       [(null? goals)
        (stream-merge
         (smap (lambda (s)
                 (bind-constraints (sunit s) (Pkg-constraints s) env))
               s))]
       [(snull? s) snull]
       [else (bind* (bind s (car goals) env) (cdr goals) env)])))


  (define bind*
    (lambda (s goals env)
      (cond
       [(null? goals) s]
       [(snull? s) snull]
       [else (bind* (bind s (car goals) env) (cdr goals) env)])))


  (define bind-constraints
    (lambda (s cs env)
      (cond
       [(null? cs) s]
       [(snull? s) snull]
       [else
        (debug 'bind-constraints
               "checking constraint: ~a" (Constraint-text (car cs)))
        (bind-constraints
              (bind s
                    (Constraint-goal (car cs))
                    (Env (Env-unify env)
                              '()                     ; no constraints
                              (Env-vars env)
                              (Constraint-vars (car cs))))
              (cdr cs)
              env)])))


  (define ==
    (lambda (u v)
      (lambdag@ (s env)
        (let ((s1 ((Env-unify env) u v (Pkg-subst s) env)))
          (cond
           [(not s1) snull]
           [else (sunit (Pkg s1 (Pkg-constraints s)))])))))


  (define ==
    (lambda (u v)
      (lambdag@ (s env)
        (let ((s1 ((Env-unify env) u v (Pkg-subst s) env)))
          (cond
           [(not s1) snull]
           [else
            (let ([cc (bind-constraints (sunit (Pkg s1 '()))
                                        (Pkg-constraints s) env)])
              (if (snull? cc)
                  snull
                  (sunit (Pkg s1 (filter (lambda (c)
                                           (not (tautology? c (Pkg-subst s))))
                                         (Pkg-constraints s))))))])))))


  (define ando
    (lambda goals
      (lambdag@ (s env)
        (bind* (sunit s) goals env))))


  (define org2
    (lambda (goals)
      (lambdag@ (s env)
        (cond
         [(null? goals) snull]
         [else
          (scons (bind (sunit s) (car goals) env)
                 ((org2 (cdr goals)) s env))]))))


  (define oro
    (lambda goals
      (lambdag@ (s env)
        (stream-merge ((org2 goals) s env)))))

  (define noto
    (lambda (g)
      (lambdag@ (s env)
        (let ([ans (defunc (g s (switch-unify env)))])
          (if (snull? ans)
              (succeed s env)
              (fail s env))))))


  (define-syntax exist
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (s env)
         (inc
           (let ((x (var 'x)) ...)
             ((ando g0 g ...) s (ext-vars env (list x ...)))))))))


  (define-syntax forall
    (syntax-rules ()
      ((_ (x ...) g0 g ...)
       (lambdag@ (s env)
         (inc
           (let ((x (var 'x)) ...)
             ((ando g0 g ...)
              (let loop ([ss (Pkg-subst s)] [vars (list x ...)])
               (cond
                [(null? vars) ss]
                [else (loop (ext-s (car vars) (gensym) ss) (cdr vars))]))
              (ext-vars env (list x ...)))))))))


  (define-syntax conde
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (s env)
         (inc
           ((oro (ando g0 g ...)
                 (ando g1 g^ ...) ...) s env))))))


  (define-syntax condc
    (syntax-rules ()
      ((_ (g0 g ...)) (ando g0 g ...))
      ((_ (g0 g ...) g^ ...)
       (lambdag@ (s env)
         (inc
           ((oro (ando g0 g ...)
                 (assert ((noto g0))
                         (condc g^ ...))) s env))))))


  (define reify-constraint
    (lambda (s)
      (lambda (c)
        (let ((ct (Constraint-text c)))
          (cond
           [(pair? ct)
            (cons (car ct)
                  (map (lambda (v) (walk* v (Pkg-subst s))) (cdr ct)))]
           [else ct])))))


  (define format-constraints
    (lambda (s)
      (debug 'format-constraints "subst: ~a\nconstraints: ~a\n"
             (Pkg-subst s)
             (Pkg-constraints s))
      (map (reify-constraint s)
           (filter (lambda (c)
                     (not (tautology? c (Pkg-subst s))))
                   (Pkg-constraints s)))))


  (define-syntax run
    (syntax-rules ()
      ((_ n (x) g0 g ...)
       (let ((x (var 'x)))
         (let ([ss ((ando g0 g ...) (Pkg empty-s '())
                     (Env unify-good '() (list x) '()))])
           (taken n (smap (lambda (s)
                           (let* ((x (walk* x (Pkg-subst s)))
                                  (rs (reify-s x empty-s)))
                             (list
                              (walk* x rs)
                              (let ((ctext (walk* (format-constraints s) rs)))
                                (if (null? ctext)
                                    '()
                                    (list 'constraints: ctext))))))
                         ss)))))))


  (define tautology?
    (lambda (c s)
      (debug 'tautology?
             "constraint: ~a\nvars: ~a\nsubst:~a\n"
             (Constraint-text c)
             (Constraint-vars c)
             s)
      (not (snull?
            (defunc ((Constraint-goal c)
                     (Pkg s '())
                     (Env unify-evil '() '() (Constraint-vars c))))))))


  (define-syntax run*
    (syntax-rules ()
      ((_ (x) g ...) (run #f (x) g ...))))


  (define-syntax make-text
    (syntax-rules (quote quasiquote)
      ((_ (quote a)) (quote a))
      ((_ (quasiquote a)) (quasiquote a))
      ((_ (g a0 ...)) (list 'g (make-text a0) ...))
      ((_ a) a)))


  (define-syntax make-text*
    (syntax-rules (quote quasiquote)
      ((_) '())
      ((_ (quote a)) (quote a))
      ((_ (quasiquote a)) (quasiquote a))
      ((_ (g0 a ...) g ...)
       (list (make-text (g0 a ...)) (make-text g) ...))
      ((_ a) 'a)))


  ;; (make-text* `b)
  ;; (make-text* (noto (== `(,a ,d) (cons u v))) (noto (appendo a b c)))
  ;; (define a 1)
  ;; (define b 2)
  ;; (define c 3)
  ;; (define d 4)
  ;; (define u 5)
  ;; (define v 6)
  ;; (make-text* (a b c) `(,c a))
  ;; (define q 10)
  ; (make-text* (noto (== q 3)))


  (define-syntax assert
    (syntax-rules ()
      ((_ (c0 c ...) g ...)
       (lambdag@ (s env)
         (inc
          ((ando g ...)
           (ext-pkg-constraints s (list c0 c ...) (make-text* c0 c ...) env)
           (ext-constraint env (list c0 c ...))))))))


  (define-syntax conda
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (s)
         (inc
           (ifa ((g0 s) g ...)
                ((g1 s) g^ ...) ...))))))


  (define-syntax ifa
    (syntax-rules ()
      ((_) snull)
      ((_ (e g ...) b ...)
       (cond
        [(snull? (defunc e)) (ifa b ...)]
        [else (bind* e (list g ...))]))))


  (define-syntax condu
    (syntax-rules ()
      ((_ (g0 g ...) (g1 g^ ...) ...)
       (lambdag@ (s)
         (inc
           (ifu ((g0 s) g ...)
                ((g1 s) g^ ...) ...))))))


  (define-syntax ifu
    (syntax-rules ()
      ((_) snull)
      ((_ (e g ...) b ...)
       (cond
        [(snull? (defunc e)) (ifa b ...)]
        [else (bind* (sunit (scar e)) (list g ...))]))))


  (define-syntax project
    (syntax-rules ()
      ((_ (x ...) g g* ...)
       (lambdag@ (s env)
         (let ((x (walk* x s)) ...)
           ((exist () g g* ...) s env))))))



  (define prints
    (lambda (s env)
      (begin
        (printf "#[prints]:: ~s\n" s)
        (succeed s env))))


  (define print-env
    (lambdag@ (s env)
      (begin
        (printf "env: ~s\n" env)
        (succeed s env))))


  (define print-var
    (lambda (name v)
      (lambda (s env)
        (begin
          (printf "#[print-var] ~a = ~s\n" name (walk v s))
          (succeed s env)))))


  (define-syntax print-var
    (syntax-rules ()
      ((_ v) (lambda (s env)
               (begin
                 (printf "#[print-var] ~a = ~s\n" 'v (walk* v (Pkg-subst s)))
                 (succeed s env))))))


  (define print-constraintso
    (lambda (s env)
      (printf "#[constraints] \n~a\n"
              (map (lambda (s) (format "~a\n" s))
                   (map (reify-constraint s) (Pkg-constraints s))))
      (succeed s env)))





  ;-------------------------------------------------------------
  ;                basic definitions (from TRS)
  ;-------------------------------------------------------------

  (define caro
    (lambda (p a)
      (exist (d)
        (== (cons a d) p))))


  (define cdro
    (lambda (p d)
      (exist (a)
        (== (cons a d) p))))


  (define conso
    (lambda (a d p)
      (== (cons a d) p)))


  (define nullo
    (lambda (x)
      (== '() x)))


  (define eqo
    (lambda (x y)
      (== x y)))


  (define pairo
    (lambda (p)
      (exist (a d)
        (conso a d p))))


  (define nullo
    (lambda (x)
      (== '() x)))




  ;-------------------------------------------------------------
  ;                  rembero (TRS frame 30)
  ;-------------------------------------------------------------

  ;; using conde operator
  (define rembero1
    (lambda (x l out)
      (conde
        ((nullo l) (== '() out))
        ((caro l x) (cdro l out))
        ((exist (res)
           (exist (d)
             (cdro l d)
             (rembero1 x d res))
           (exist (a)
             (caro l a)
             (conso a res out)))))))


  ;; example
  (run* (out)
   (exist (y)
     (rembero1 y `(a b ,y d peas e) out)))


  ;; We got 7 answers, 4 of which shouldn't happen, because
  ;; the fresh variable y should never fail to remove itself
  ;; and thus go on to remove d, peas and e.

  ;; =>
  ;; (((b a d peas e) ())               ; y == a
  ;;  ((a b d peas e) ())               ; y == b
  ;;  ((a b d peas e) ())               ; y == y
  ;;  ((a b d peas e) ())               ; unreasonable beyond this point
  ;;  ((a b peas d e) ())
  ;;  ((a b e d peas) ())
  ;;  ((a b _.0 d peas e) ()))



  ;; using condc operator
  (define rembero
    (lambda (x l out)
      (condc
        ((nullo l) (== '() out))
        ((caro l x) (cdro l out))
        ((exist (res)
           (exist (d)
             (cdro l d)
             (rembero x d res))
           (exist (a)
             (caro l a)
             (conso a res out)))))))


  ;; example
  (run* (out)
   (exist (y)
     (rembero y `(a b ,y d peas e) out)))


  ;; We got only 3 answers, plus two constraints for the third
  ;; answer. The constraints are basically saying: If we are
  ;; to have this answer, neither (caro (b y d peas e) y) nor
  ;; (caro (a b y d peas e) y) should hold.

  ;; =>
  ;; (((b a d peas e) ())
  ;;  ((a b d peas e) ())
  ;;  ((a b d peas e)
  ;;   (constraints:
  ;;    ((noto (caro (b #1(y) d peas e) #1(y)))
  ;;     (noto (caro (a b #1(y) d peas e) #1(y)))))))





  ;-------------------------------------------------------------
  ;                     Oleg's comments (Jul 23)
  ;-------------------------------------------------------------

  (run 5 (out)
   (exist (y l r)
    (== out (list y l r))
    (rembero y l r)))

  ;; =>
  ;; '(((_.0 () ()) ())
  ;;   ((_.0 (_.0 . _.1) _.1) ())
  ;;   ((_.0 (_.1) (_.1))
  ;;    (constraints: ((noto (caro (_.1) _.0)))))
  ;;   ((_.0 (_.1 _.0 . _.2) (_.1 . _.2))
  ;;    (constraints: ((noto (caro (_.1 _.0 . _.2) _.0)))))
  ;;   ((_.0 (_.1 _.2) (_.1 _.2))
  ;;    (constraints: ((noto (caro (_.2) _.0))
  ;;                   (noto (caro (_.1 _.2) _.0))))))


  ;; Here, the constraints are really part of the answer: the answer
  ;; (_.0 (_.1) (_.1)) does not make sense without the constraint that
  ;; _.0 must be different from _.1. The easy way to see that (_.0 (_.1)
  ;; (_.1)) is not an answer is to instantiate both variables to 1:

  (run 5 (out)
   (exist (y l r)
    (== out '(1 (1) (1)))
    (== out (list y l r))
    (rembero y l r)))


  ;; produces (). Thus constraints must be, in general, part of the
  ;; answer. Hence what I said about the need to normalize constraints
  ;; applies. Here is the simple example where constraint normalization
  ;; may help:

  (run* (out)
    (exist (x y)
      (== out (list x y))
      (condc
        ((caro (list x) y))
        ((caro (list y) x))
        ((caro (list y) 1))
        ((caro (list x) 1)))))

  ;; =>
  ;; '(((_.0 _.0) ())
  ;;   ((_.0 1)
  ;;    (constraints:
  ;;     ((noto (caro (list 1) _.0))
  ;;      (noto (caro (list _.0) 1)))))
  ;;   ((1 _.0)
  ;;    (constraints:
  ;;     ((noto (caro (list _.0) 1))
  ;;      (noto (caro (list _.0) 1))
  ;;      (noto (caro (list 1) _.0))))))


  ;; The three constraints in the last answer are identical, aren't they?

  ;; Here is why we need a genuine constraint solver.

  ; num predicate
  (define (num x)
   (conde
     ((== x '()))
     ((exist (y)
      (== x (cons 1 y))
      (num y)))))

  (run 5 (out) (num out))


  ; greater-than on num
  (define (gt x y)
   (conde
     ((== y '()) (pairo x))
     ((exist (x1 y1)
       (== x (cons 1 x1))
       (== y (cons 1 y1))
       (gt x1 y1)))))

  (run* (out) (gt '(1 1 1 1) out))


  ;; (run 1 (out)
  ;;  (exist (x y)
  ;;   (condc
  ;;     ((gt x y) fail)
  ;;     ((gt x (cons 1 y))
  ;;      (num x) (num y) (== out 'really?)))))

  ;; => diverges

  ;; rewritten this way
  ;; (run 1 (out)
  ;;  (exist (x y)
  ;;    (== out (list x y))
  ;;    (num x) (num y)
  ;;    (condc
  ;;      ((gt x y) fail)
  ;;      ((gt x (cons 1 y))))))


  ;; The genuine constraint solver for naturals would have determined
  ;; that if NOT(x > y) then x > y+1 cannot succeed. The CLP system will
  ;; return the finite failure. This is the fundamental difference
  ;; between CLP and ordinary Prolog: Prolog is based on `generate and
  ;; test', whereas CLP do `test and then generate'. They solve
  ;; constraints using uninstantiated variables; they instantiate
  ;; afterwards.

  ;; Incidentally, your noto does not play well will committed choice
  ;; like condu and conda, which is expected (one has to be very careful
  ;; nesting of condu and conda). There is an easy way to make condu and
  ;; conda sound (at least, reporting a run-time error when attempting
  ;; to instantiate a non-local variable). The best way to solve this
  ;; problems is with mode inference (as Mercury or Twelf do).

  ;; Incidentally, the mini-Kanren is based on lazy lists (on streams).
  ;; The monad of mini-Kanren is

  ;;        data L a = Zero | One a | Cons a (() -> L a)

  ;; which is the ordinary lazy list with the special case for
  ;; one-element list.

         ;; Cheers,
         ;; Oleg
  #+end_src
