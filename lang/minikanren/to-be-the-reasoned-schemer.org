#+TITLE:  to be the reasoned schemer
#+AUTHOR: 謝宇恆 / XIE Yuheng

* note

  - try to name some discussions
    to learn how to teach

* 1 playthings

*** note

    - the law of fresh
      if x is fresh
      then (v x) succeeds and associates x with v

    - the law of ==
      (== v w) is the same as (== w v)

    - the law of conde
      to get more values from conde
      pretend that the successful conde line has failed
      refreshing all variables that got an association from that line

    - 多解就來源於

*** run*

    #+begin_src scheme
    (run* (q)
      fail)

    (run* (x)
      succeed)

    (run* (q)
      (== 1 q))

    (run* (x)
      (let ([x1 1])
        (== x1 2)))
    #+end_src

*** reified variable

    - 也許是 Thoralf Albert Skolem 強調
      要給返回的不定元做系統地重命名
      以便閱讀

    #+begin_src scheme
    (run* (x)
      (let ((x #f))
        (fresh (x)
          (== #t x))))

    (run* (x)
      (let ((x #f))
        (== #f x)))

    (run* (x)
      (fresh (x)
        (== #t x)))

    (run* (x)
      (== #f x))

    (run* (x)
      (fresh (a d)
        (== x
            (cons a (cons d '())))))

    (run* (r)
      (fresh (x)
        (let ([y x])
          (fresh (x)
            (== (list y x y) r)))))

    (run* (r)
      (fresh (x)
        (fresh (y)
          (== (list y x y) r))))

    (run* (r)
      (fresh ()
        (fresh (y)
          (== (list y y) r))))
    #+end_src

*** 等詞的困惑

    - == 看似是等詞
      而又有等詞 eq?

    - 也許是 herbrand 最先提出
      始終要有更底層的等詞以區分他們

    #+begin_src scheme
    (run* (q)
      (fresh (x)
        (== (eq? x q) q)))

    (run* (q)
      (let ([x q])
        (fresh (q)
          (== (eq? x q) x))))

    ;; 也就是說 等詞 eq? 和 == 有別
    ;; 但是注意
    (let ([q 1])
      (let ([x q])
        (eq? x q)))
    ;; 也就是說 即使不定元被 unify 了
    ;; 等詞 eq? 還是要能夠區分它們
    (run* (q)
      (fresh (x)
        (== x #f)
        (== q #f)
        (== (eq? x q) q)))
    ;; 也就是說 即使不定元都被 unify 到了相同的值
    ;; 等詞 eq? 還是要能夠區分它們
    (run* (z)
      (fresh (q)
       (fresh (x)
         (== x z)
         (== q z)
         (== (eq? x q) q))))
    #+end_src

*** conde

    - e for every line

    - 形成分支的方式是以 unification 的結果[goal 的結果]爲等詞
      而分配到別的 unification[別的 goal]
      而不是 prolog 一樣 隱式的 pattern match 了
      但是
      其實 unification 就是 pattern match
      所以這裏是又匿名的 pattern match
      看來要比 prolog 靈活

    - undo[refreshes][backtracing] happens here

    #+begin_src scheme
    (run* (x)
      (conde
       [(== 1 x) (== 1 x)]
       [(== 2 x) (== 3 x)]))

    (run* (x)
      (conde
        [(== 'kkk x) fail]
        [(== 'kk x) succeed]
        [(== 'k x) succeed]))

    (run 1 (x)
      (conde
        [(== 'kkk x) succeed]
        [(== 'kk x) succeed]
        [(== 'k x) succeed]))

    (run 2 (x)
      (conde
        [(== 'kkk x) succeed]
        [(== 'kk x) succeed]
        [(== 'k x) succeed]))

    (run #f (x)
      (conde
        [(== 'kkk x) succeed]
        [(== 'kk x) succeed]
        [(== 'k x) succeed]))

    (run* (x)
      (conde
        [(== 'kkk x) fail]
        [(== 'kk x) succeed]
        [succeed succeed]
        [(== 'k x) succeed fail]))

    ;; 這裏第一次體現出來了 backtracing
    (run* (r)
      (fresh (x y)
        (conde
          [(== 'kkk x) (== 'aaa y)]
          [(== 'kk x) (== 'aa y)] )
        (== (list x y) r)))

    (define teacupo
      (lambda (x)
        (conde
          ((== 'tea x) succeed)
          ((== 'cup x) succeed)
          (else fail))))

    (run* (x)
      (teacupo x))
    #+end_src

*** the scope of reification

    #+begin_src scheme
    (run* (r)
      (fresh (x y z)
        (conde
          [(== y x) (fresh (x)
                      (== z x))]
          [(fresh (x)
             (== y x)) (== z x)])
        (== (list y z) r)))

    (run* (r)
      (fresh (x y z)
        (conde
          [(== y x) (fresh (x)
                      (== z x))]
          [(fresh (x)
             (== y x)) (== z x)])
        (== 1 x)
        (== (list y z) r)))
    #+end_src

*** expression have value

    #+begin_src scheme
    (run* (q)
      (let ([a (== 1 q)]
            [b (== 2 q)])
        a))

    (run* (q)
      (let ([a (== 1 q)]
            [b (== 2 q)])
        b))

    (run* (q)
      (let ([a (== #t q)]
            [b (fresh (x)
                 (== x q)
                 (== #f x))]
            [c (conde
                 ((== #t q) succeed)
                 (else (== #f q)))])
        b))
    #+end_src

* 2 teaching old toys new tricks

*** define

    - 用 == 和 數據構造子 cons [任何可逆函數都可以]
      來定義新的 類 == 謂詞 [稱 融合子]
      這就是組合方式之一

    - 另外的組合方式是
      1. 融合子 在 conde 的複合在 形成帶有分支結構 新融合子
         conde 內的的語義是 or
      2. 用 fresh 構造新的 scope 引入新的 變元
         fresh 內的語義是 and

    #+begin_src scheme
    (define caro
      (lambda (p a)
        (fresh (d)
          (== (cons a d) p))))

    (run* (r)
      (fresh (x y)
        (caro (list r y) x)
        (== 1 x)))

    (define cdro
      (lambda (p d)
        (fresh (a)
          (== (cons a d) p))))

    (run* (r)
      (fresh (v)
        (cdro '(1 2 3) v)
        (caro v r)))

    (run* (x)
      (cdro '(1 2 3) (list x 3)))

    (run* (x)
      (fresh (a b)
        (== '(1 2) `(,a ,b))
        (== `(,a ,b) x)))
    (run* (l)
      (fresh (x)
        (cdro l '(1 2 3 4))
        (caro l x)
        (== 0 x)))

    (define conso
      (lambda (a d p)
        (== (cons a d) p)))

    (run* (l)
      (conso 1 2 l))
    (run* (x)
      (conso x '(1 2) '(0 1 2)))
    (run* (x)
      (conso x `(1 ,x 3) `(0 1 ,x 3)))
    (run* (l)
      (fresh (x)
        (== `(0 1 ,x 3) l)
        (conso x `(1 ,x 3) l)))
    (run* (l)
      (fresh (x)
        (conso x `(1 ,x 3) l)
        (== `(0 1 ,x 3) l)))

    (define nullo
      (lambda (x)
        (== x '())))
    (run* (x)
      (nullo x))

    ;; 用 unification 的時候
    ;; 也可以有謂詞性質的 融合子
    (define pairo
      (lambda (p)
        (fresh (a d)
          (conso a d p))))
    ;; 但是它包含的信息少的多
    ;; 用 conso 可以定義 caro cdro 和 pairo
    #+end_src

* 3 seeing old friends in new ways

*** predicate to unifier

    - THE FIRST COMMANDMENT
      to transform a function whose value is a boolean
      into a function whose value is a goal
      replace cond with conde and unnest each question and answer
      unnest the answer #t (or #f) by replacing it with #s (or #u)

    #+begin_src scheme
    (define list?
      (lambda (l)
        (cond
         [(null? l) #t]
         [(pair? l) (list? (cdr l))]
         [else #f])))

    (define listo
      (lambda (l)
        (conde
          [(nullo l) succeed]
          [(pairo l) (fresh (d)
                       (cdro l d)
                       (listo d))]
          [else fail])))

    (run* (x)
      (listo (cons 1 2)))

    (run* (x)
      (listo (list 'a 'b x 'd)))

    ;; loop
    (run 6 (x)
      (listo `(1 2 3 . ,x)))
    #+end_src

*** lolo

    #+begin_src scheme
    (define lol?
      ;; list-of-lists?
      (lambda (l)
        (cond
         [(null? l) #t]
         [(list? (car l))
          (lol? (cdr l))]
         [else #f])))

    (define lolo
      (lambda (l)
        (conde
          [(nullo l)]
          [(fresh (a)
             (caro l a)
             (listo a))
           (fresh (d)
             (cdro l d)
             (lolo d))])))

    (define lolo
      (lambda (l)
        (oro
          (nullo l)
          (ando+ (a)
            (caro l a)
            (listo a))
          (ando+ (d)
            (cdro l d)
            (lolo d)))))

    (define lolo
      (lambda (l)
        (oro
          (nullo l)
          (ando+ (a d)
            (caro l a)
            (listo a)
            (cdro l d)
            (lolo d)))))

    (run 10 (l)
      (lolo l))

    (run 1 (q)
      (ando+ (x y)
        (lolo `((1 2) (,x 3) (4 ,y)))
        (== 'ok q)))

    (run 10 (x)
      (lolo `((1) . ,x)))
    #+end_src

*** loto

    #+begin_src scheme
    (define twinso
      (lambda (s)
        (ando+ (x y)
          (conso x y s)
          (conso x '() y))))

    (define twinso
      (lambda (s)
        (fresh (x)
          (== (list x x) s))))

    (run* (q)
      (twinso '(1 1))
      (== #t q))

    (run* (q)
      (twinso `(1 ,q)))

    (define loto
      ;; list-of-twins
      (lambda (l)
        (conde
         [(nullo l)]
         [(fresh (a)
            (caro l a)
            (twinso a))
          (fresh (d)
            (cdro l d)
            (loto d))])))

    (define loto
      ;; list-of-twins
      (lambda (l)
        (oro
          (nullo l)
          (ando+ (a d)
            (caro l a)
            (twinso a)
            (cdro l d)
            (loto d)))))

    (run 10 (z)
      (loto `((1 1) . ,z)))
    #+end_src

*** listofo

    #+begin_src scheme
    (define listofo
      (lambda (predo l)
        ;; pred denote predicate
        (oro (nullo l)
             (ando+ (a d)
               (caro l a)
               (predo a)
               (cdro l d)
               (listofo predo d)))))

    (run 10 (out)
      (fresh (w x y z)
        (== `((1 1) (2 ,w) (,x ,y) . ,z) out)
        (listofo twinso out)))

    (run 1 (out)
      (fresh (w x y z)
        (== z out)
        (listofo nullo out)))

    (define loto
      (lambda (l)
        (listofo twinso l)))

    (run 10 (z)
      (loto `((1 1) . ,z)))
    #+end_src

*** membero

    #+begin_src scheme
    (define member?
      (lambda (x l)
        (cond
         [(null? l) #f]
         [(eq-car? l x) #t]
         [else (member? x (cdr l))])))

    (define eq-car?
      (lambda (l x)
        (eq? (car l) x)))

    ;; note that
    ;; Whenever a conde line is guaranteed to fail
    ;; it is unnecessary
    ;; 不必用謂詞檢查 以保證參數在函數的定義域內
    ;; 因爲施行計算的不是函數 而是融合子[謂詞]
    (define membero
      (lambda (x l)
        (oro (caro l x)
             (ando+ (d)
               (cdro l d)
               (membero x d)))))

    (run 10 (l)
      (membero 1 (cons l 1)))

    (run 10 (l)
      (membero 1 (cons 1 l)))

    (run 10 (l)
      (membero 1 (list l 1)))

    (run 10 (l)
      (membero 1 (list 1 l)))

    (run* (x)
      (membero 2 (list 1 x 3)))

    (run* (x)
      (membero 2 (list 1 2 x 3)))

    (run* (x)
      (membero 2 (list 1 x 2 3)))

    (run* (out)
      (fresh (x y)
        (membero 2 (list 1 x 3 y))
        (== (list x y) out)))

    (run* (x)
      (membero x (list 1 2 3)))

    (run 10 (l)
      (membero 'k l))
    #+end_src

*** pmembero

    - 這個變體在於 控制解的形狀
      縮小了解集

    #+begin_src scheme
    (define pmembero
      ;; p denotes proper-list
      (lambda (x l)
        (oro (ando (caro l x) (cdro l '()))
             (ando+ (d)
               (cdro l d)
               (pmembero x d)))))

    (run 10 (l)
      (pmembero 'k l))

    ;; mistake
    (run* (out)
      (pmembero 1 '(a b 1 c d 1))
      (== #f out))

    (run* (out)
      (membero 1 '(a b 1 c d 1))
      (== #f out))

    (define pmembero
      (lambda (x l)
        (oro (ando (caro l x) (cdro l '()))
             (caro l x)
             (ando+ (d)
               (cdro l d)
               (pmembero x d)))))

    ;; mistake
    (run* (out)
      (pmembero 1 '(a b 1 c d 1))
      (== #f out))

    (define pmembero
      (lambda (x l)
        (oro (ando (caro l x) (cdro l '()))
             (ando (caro l x)
                   (ando+ (a d)
                     (cdro l (cons a d))))
             (ando+ (d)
               (cdro l d)
               (pmembero x d)))))

    (run* (out)
      (pmembero 1 '(a b 1 c d 1))
      (== #f out))

    (run 10 (l)
      (pmembero 'k l))

    (define pmembero
      (lambda (x l)
        (oro (ando (caro l x)
                   (ando+ (a d)
                     (cdro l (cons a d))))
             (ando (caro l x) (cdro l '()))
             (ando+ (d)
               (cdro l d)
               (pmembero x d)))))

    (run 10 (l)
      (pmembero 'k l))

    (define pmembero
      (lambda (x l)
        (ando (membero x l)
              (listo l))))

    (run 10 (l)
      (pmembero 'k l))

    (run* (out)
      (membero 1 '(a b 1 c d 1))
      (== #f out))
    #+end_src

*** memberrevo

    - 注意回溯的順序

    #+begin_src scheme
    (define memberrevo
      ;; rev denotes reverse
      (lambda (x l)
        (oro (ando+ (d)
               (cdro l d)
               (memberrevo x d))
             (caro l x))))

    (run* (x)
      (memberrevo x '(1 2 3 4 5)))

    ;; 嵌套在 oro 裏順序當然也被保持
    (run 3 (k)
      (oro
        (== k 1)
        (oro
          (== k 2))
        (== k 3)))

    (define list-reverse-copy
      (lambda (l)
        (run* (y)
          (memberrevo y l))))

    (list-reverse-copy'(1 2 3))
    #+end_src

* 4 members only

*** function to unifier

    - THE SECOND COMMANDMENT
      to transform a function whose value is not a boolean into
      a function whose value is a goal
      add an extra argument to hold its value
      replace cond with conde
      and unnest each question and answer

    - 注意
      在一次 unification 中
      memo 的 out 只可能有一種結果

    #+begin_src scheme
    (define memo
      (lambda (x l out)
        (oro
          (ando (caro l x) (== l out))
          (ando+ (d)
            (cdro l d)
            (memo x d out)))))

    (run 1 (out)
      (memo 1 '(0 0 1 2 3) out))

    (run* (r)
      (memo r
             '(0 0 1 2 3)
             '(1 2 3)))

    (run* (r)
      (memo 1 '(1 2 3) '(1 2 3))
      (== #f r))

    (run* (r)
      (memo 1 '(1 2 3) '(1 2))
      (== #f r))

    (run* (r)
      (memo 1 '(1 2 3) '(1 2))
      (== #f r))

    (run* (x)
      (memo 1 `(1 2) `(7 ,x)))

    (run* (out)
      (fresh (x)
        (memo 1 `(0 0 ,x 0 1 2) out)))

    (run 10 (z)
      (fresh (u)
        (memo 'k `(0 0 k 0 k 2 . ,z) u)))
    #+end_src

*** rembero

    #+begin_src scheme
    (define rembero
      (lambda (x l out)
        (oro
          (ando
            (nullo l)
            (== '() out))
          (ando
            (conso x out l))
          (ando+ (res a d)
            (conso a d l)
            (rembero x d res)
            (conso a res out)))))

    (run* (out)
      (rembero 1 '(1 2 3) out))

    (run* (out)
      (fresh (y)
        (rembero 0 `(1 2 ,y 3 0 4) out)))

    (run* (out)
      (fresh (y z)
        (rembero y `(a b ,y d ,z e) out)))

    (run* (r)
      (fresh (y z)
        (rembero y `(,y d ,z e) `(,y d e))
        (== `(,y ,z) r)))

    (run 13 (w)
      (fresh (y z out)
        (rembero y `(a b ,y d ,z . ,w) out)))

    (run 13 (r)
      (fresh (w y z out)
        (rembero y `(a b ,y d ,z . ,w) out)
        (== (list w y z out) r)))

    ;; 以爲不移除任何東西是允許的
    ;; 而且 在轉向下個 oro 分支的時候
    ;; 之前 unification 都被忘記了
    ;; 所以處理語義的時候要小心
    (define surpriseo
      (lambda (s)
        (rembero s '(a b c) '(a b c))))

    ;; 下面的語義是正常的
    (run* (r)
      (== 'd r)
      (surpriseo r))

    ;; 而下面的三個例子中 語義可能就是有偏差的了
    (run* (r)
      (surpriseo r))
    (run* (r)
      (== 'b r)
      (surpriseo r))
    (run* (r)
      (surpriseo r)
      (== 'b r))

    ;; 下面可以讓 移除 的語義更加嚴格
    ;; 不接受沒有移除任何元素的情況
    ;; 這種東西在 一般的函數式編程中是表達不出來的
    (define rembero
      (lambda (x l out)
        (oro
          ;; without the following
          ;; it can not succeed by remove nothing
          ;; (ando
          ;;   (nullo l)
          ;;   (== '() out))
          (ando
            (conso x out l))
          (ando+ (res a d)
            (conso a d l)
            (rembero x d res)
            (conso a res out)))))
    #+end_src

* 5 double your fun

*** appendo

    - order of ando
      make recursive call as late as possible
      thus recursive call is not on fresh variables

    #+begin_src scheme
    (define appendo
      (lambda (l s out)
        (oro (ando
               (nullo l)
               (== out s))
             (ando+ (a d rec)
               (conso a d l)
               (appendo d s rec)
               (conso a rec out)))))

    (run* (out)
      (appendo `(1 2 3) `(a b c) out))

    (run 10 (x)
      (fresh (y)
        (appendo `(a b c . ,y) `(d e) x)))

    (run 10 (x)
      (fresh (y)
        (appendo `(a b c . ,y) `(d e . ,y) x)))

    (run 10 (x)
      (fresh (y)
        (appendo `(a b c) `(d e . ,y) x)))

    ;; can't run 12
    ;; because on the 12th times
    ;; where you pretend that the first branch does not unify
    ;; l & s are fresh
    ;; thus d s rec are all fresh in the recursive call
    (run 11 (x)
      (fresh (y)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))))

    (run 11 (y)
      (fresh (x)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))))

    (run 11 (out)
      (fresh (x y)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))
        (== `(,x ,y) out)))

    (define appendo
      (lambda (l s out)
        (oro (ando
               (nullo l)
               (== out s))
             (ando+ (a d rec)
               (conso a d l)
               (conso a rec out)
               (appendo d s rec)))))

    ;; can run 12
    (run 12 (x)
      (fresh (y)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))))

    (run 12 (y)
      (fresh (x)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))))

    (run 12 (out)
      (fresh (x y)
        (appendo x y `(1 2 3 4 5 6 7 8 9 10))
        (== `(,x ,y) out)))


    (run 3 (x)
      (fresh (y z)
        (appendo x y z)))

    (run 3 (y)
      (fresh (x z)
        (appendo x y z)))

    (run 3 (z)
      (fresh (x y)
        (appendo x y z)))

    (run 3 (out)
      (fresh (x y z)
        (appendo x y z)
        (== `(,x ,y ,z) out)))

    (define swappendo
      (lambda (l s out)
        (oro (ando+ (a d rec)
               (conso a d l)
               (conso a rec out)
               ;; on recursive unification
               ;; all variables are fresh
               (swappendo d s rec))
             (and (nullo l)
                  (== out s)))))

    ;; forever
    ;; (run 1 (z)
    ;;   (fresh (x y)
    ;;     (swappendo x y z)))
    #+end_src

*** note 思想模型

    - 在對例子的觀察中
      獨立建立起自己的思想模型
      來理解語言的語義

*** unwarp

    - order of oro

    #+begin_src scheme
    (define unwarpo
      (lambda (x out)
        (oro
          (ando+ (a)
            (pairo x)
            (caro x a)
            (unwarpo a out))
          (== x out))))

    (run* (x)
      (unwarpo '((((((1)))))) x))

    ;; loop
    ;; (run 1 (x)
    ;;   (unwarpo x 1))
    ;; for recursive call on 'a' 'out'
    ;; but after
    ;;   (pairo x)
    ;;   (caro x a)
    ;; 'a' 'out' are still fresh variables

    (define unwarpo
      (lambda (x out)
        (oro
          (== x out)
          (ando+ (a)
            (pairo x)
            (caro x a)
            (unwarpo a out)))))

    (run* (x)
      (unwarpo '((((((1)))))) x))

    (run 3 (x)
      (unwarpo x 1))

    (run 3 (x)
      (unwarpo `((,x)) 1))
    #+end_src

*** flatteno

    - 注意解的列表如何循環

    #+begin_src scheme
    (define flatten
      (lambda (s)
        (cond [(null? s) '()]
              [(pair? s)
               (append (flatten (car s))
                       (flatten (cdr s)))]
              [else (cons s '())])))

    (flatten '((1 (2)) 3))
    (flatten '(1))
    (flatten '(1 . ()))
    (flatten '(1 . 2))
    (flatten '1)

    (define flatteno
      (lambda (s out)
        (oro (ando (nullo s) (== '() out))
             (ando+ (a d res-a res-d)
               (conso a d s)
               (flatteno a res-a)
               (flatteno d res-d)
               (appendo res-a res-d out))
             (conso s '() out))))

    (run* (out)
      (flatteno '((1 (2)) 3) out))

    (run* (out)
      (flatteno '((1 2) 3) out))

    (run* (out)
      (flatteno '(1) out))

    ;; loop
    ;; (run 3 (x)
    ;;   (flatteno x '(1)))


    (define flattenrevo
      (lambda (s out)
        (oro (ando (nullo s) (== '() out))
             (conso s '() out)
             (ando+ (a d res-a res-d)
               (conso a d s)
               (flattenrevo a res-a)
               (flattenrevo d res-d)
               (appendo res-a res-d out)))))

    (run 2 (x)
      (flattenrevo x '(1)))

    (run 3 (x)
      (flattenrevo x '(1)))

    (run 10 (x)
      (flattenrevo x '(1)))

    (equal?
     (run* (out)
       (flattenrevo '((1 2) 3) out))
     (reverse
      (run* (out)
        (flatteno '((1 2) 3) out))))


    (define flattenrevo
      (lambda (s out)
        (oro (conso s '() out)
             (ando (nullo s) (== '() out))
             (ando+ (a d res-a res-d)
               (conso a d s)
               (flattenrevo a res-a)
               (flattenrevo d res-d)
               (appendo res-a res-d out)))))

    ;; can not run 3
    (run 2 (x)
      (flattenrevo x '(1)))

    (equal?
     (run* (out)
       (flattenrevo '((1 2) 3) out))
     (reverse
      (run* (out)
        (flatteno '((1 2) 3) out))))
    #+end_src

* 6 the fun never ends

*** ><

    #+begin_src scheme

    #+end_src

* >< 7 a bit too much

* >< 8 just a bit more

* >< 9 under the hood

* >< 10 thin ice

* >< connecting the wires

* >< welcome to the club
