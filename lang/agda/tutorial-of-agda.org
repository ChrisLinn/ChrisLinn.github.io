#+TITLE:  tutorial of adga
#+AUTHOR: 謝宇恆 / XIE Yuheng

* constructor

*** type parameter v.s. type indice
    * type constructor
      can not change type parameter
      but can change type indice
      while
      function can always change both

*** constructor
    * 用 data 這個語法關鍵詞定義的 新類型 本身
      也像是 constructor
      它卡以從 別的 type 和 value 構建新的 type
      用 data 定義一個新的 type 時
      需要給出這個類型的元素的 constructor
      * 這種 constructor 類似函數
        但是可以重名
        而函數不可以重名

*** 語法慣例
    * table
      | 新定義類型時                         | 首字母大寫 |
      | 定義用以引入這個類型的數據的構造子時 | 小寫       |
      | 定義生成類型的函數時 [返回值爲類型]  | 首字母大寫 |
      | 定義一般函數時                       | 小寫       |
    * constructor
      構造子有兩種
      1. 定義一個類型的時候
         要給出這個類型的數據的構造子
         是特殊的函數
         與函數的差異在於
         * 引入新的類型
         * 不失信息
      2. 用已有的類型
         定義新的類型

*** 從 具體數學結構 角度看
    * 首先 用 data 定義一個類型構造子
      然後 用一系列的 constructor 引入這個類型

*** 從 證明論 角度看
    * 定義一個 謂詞
      然後 給出這個謂詞的基本性質
      * 不必是 簡單的 引入與消去
        可以是 結構化的 引入與消去
      所證明的 帶有這個 謂詞 的 命題
      是複合命題
      * 所有的邏輯連接詞
        都被設計在下列東西中
        1. 則式 (... -> ...)
        2. 與 則式 有關的匹配規則
      * 而量詞就是
        則式 項之間的 依賴關係

*** 類型 與 謂詞
    * dependent type 中
      被 value 參數化的 類型構造子 是典型的謂詞
      比如 等詞
    * term 層次的 patthern match
    * 定義一個 謂詞
      要把 跟這個 謂詞 有關的所有東西 都寫到定義中
      利用這些東西我們能證明跟這個謂詞有關的謂詞
      而所定義的
      跟這個 謂詞 有關的所有東西
      就是用以 引入 與 消去 這個謂詞的函數
    * boolean is useless 是什麼意思
      謂詞 與 boolean 的關係什麼
    * 很多在程序中需要用來做判斷的謂詞
      被放到了類型檢查中
      需要定義一個 謂詞 的時候
      其實是需要定義一個類型
    * 既然 等詞 可以從 做爲函數的謂詞 被轉化爲類型
      那麼 所有的其他謂詞也可以

*** 計算可以出現在 type 的表達式中 邪

*** 類型類型
    * 有的類系 依賴於值 [像是謂詞]
      有的類型 依賴於類型
    * 類型也是 term
      每個 term 都有 type
      所以說
      上面提到的類型之間的區別
      可以被類型系統以內蘊地方式處理

* >< proof automation

*** tactics

*** automation via reflection

*** proof search

* level

*** 變
    * 每次 level 一聖高
      我們就可以忽略一些信息
      函數 -> 類型
      忽略了具體計算的信息

* module system

*** basic

* 交互性
  - x ::
       我最想要的一個性質就是
       在空白位置聞訊之後
       就能給出 當前的條件 和 需要證明的結論
       對於 cicada 來說
       模式匹配的部分 和 沒有命名的在棧中的參數 都可以在聞訊的時候被展示出來
       還有
       自動展開模式匹配的分支
  - x ::
       我現在知道
       自動展開模式匹配的分支 涉及到 搜索類型構造子
       並 匹配以反代入[unification and substitution]
       具體地
       當需要展開一個假設 :hypothesis 時
       這個 :hypothesis 的類型是已知的 設爲 :type
       取一個類型構造子
       是列一組方程 然後試着解之
       目的是 解出 這個構造子的參數
       使得 這個類型構造子作用於這些參數時 所返回的結果是 已知的類型 :type
       此時 有些參數可以是自由的
       但是 不能有參數相互衝突
       就像解線性方程一樣
       如果同時解得 x = 1 和 x = 2 那麼這個方程就沒有解了
       注意 匹配是有方向的 已經確定是具有自由性的匹配位置 不能被匹配到某個常量
       也就是說 這裏[又]有一個序關係
       其實這種工作很平凡
       不是嗎
       其實就是
       發現 人在寫形式化的證明時 需要做一些枯燥的工作
       發現 這些工作如此平凡 以至於機器能幫人完成
       然後 實現一個程序 來讓機器幫助人完成這些工作
       這樣 就得到了機器輔助證明系統的交互界面中的一個實用性狀了
       可笑的是
       這種平凡的動機 被某些人講複雜了
  - x ::
       我還知道
       點號可能是爲了限制搜索範圍
       因爲 不同的 主要匹配 所帶來的效果不同
       另外
       加點 有助於說明證明是如何完成的
  - k ::
       也就是說
       使用模式匹配這種非線性的方式做證明的時候
       很多證明的步驟被隱藏起來了
  - x ::
       我想加點還因爲
       在交互功能的幫助下
       所進行的匹配 不總是線性的
       第一次對某個變元的匹配可以出現在證明的任何位置
       爲了表達這些信息 相關的語法就必須被引入 這樣設計者就設計出了 加點的語法
  - k ::
       我發現
       這種狀況被稱作是 dependent type 中 pattern match 的特性
       因爲
       有對依賴[dependent] 的表達
       就要用變元
       讓變元能夠在式子中多次出現 就表達了依賴性
       而多次出現的位置 就引出了這種特性
  -----------------------
  - x ::
       另外注意
       所搜索的只能是公理性的類型構造子
       而不能是涉及這個類型的其他函數
       這樣 有時看似需要定義一個函數來表達的東西
       在 agda 裏卻應該處理爲一個新的類型與其構造子
       回想 類型可以被看成是謂詞或者關係
       這就相當於是用二元關係來處理函數[特殊的二元關係]

* >< 隱含參數[implicit argument]
  - x ::
       在實際的模型中考慮 隱含參數 其實很簡單
       首先 類型做爲函數的 元數據
       其 元性 就在於
       它只是在編譯時期起作用
       而在運行時不起作用
  - k ::
       這樣 也就明白了 agda 如何重載 某些函數名
       我想
       重點是要知道 這裏對隱含參數的實現
       並不是像 haskell 的類型類一般
       使得 在運行期 每個函數也要增加一個參數
       agda 的處理方式一定是不傷運行的
  - x ::
       沒錯
       我是這樣理解的
       首先
       理論上的要求是
       所能夠隱式處理的參數
       一定是能夠在利用類型中的其他信息來確定的參數
       其次
       具體實現方面
       類型中所做的局部命名 所提供的額外信息
       在編譯時期都可以利用
       可以選擇將某些信息編譯到函數體中
  ---------------------------------
  - x ::
       但是也許我的這種理解方式是錯的
       一般情況下[甚至大多數情況下]
       必須要通過增傳參數來處理隱含參數
  - k ::
       這是否將會對棧的語義有很壞的影響呢
  - x ::
       如果真的這樣處理
       就一定要明白這些參數是在棧裏的
       在操作棧的時候要小心不要忽略他們
       然而
       在單個函數作用中
       這些參數是被自動處理的
  - k ::
       如何自動處理
  - x ::
       我也還不明白
       嘗試幾個例子吧

* 學習機器輔助證明系統
  - x ::
       我常說
       蟬語的特點是
       很容易透徹理解其具體實現方式
       而上面
       關於隱含參數的討論
       實際上說明了
       想要學習 機器輔助證明系統
       唯一的方式就是去透徹理解其實現方式
       因爲
       理解其具體實現方式
       要比自己構建一個抽象的模型來理解其運作機理
       簡單得多
       構造主義數學 之於 古典數學 也是如此
  - k ::
       但是這種告誡也有反例
       不是嗎
       比如在 SICP 中
       作者令人讚歎的教學法
       就是這種每每透徹理解具體實現的反例



* dependently-typed-programming-in-agda [ulf & james]

* an-intro-to-dependent-types-and-agda [abel]

*** 定義新類型
    * 參數化的類型
      輸入 類型 或者 值
      返回 類型
      的函數
    * 每個 類型 會有一些構造子
      * 構造子
        用以構造屬於這個類型的數據
      構造子決定了類型的性質
      構造子是特殊的函數
      特殊在於
      它們只是用以編碼類型的性質
      而不是真正的計算
    * 一個構造子作用與參數時
      只是把這些參數包裹起來
      構造一個結構化的數據而已
    * 所以 做爲函數 類型構造子 只有類型 而沒有函數體
      因爲它們根本不計算
    * 構造子緊跟在類型定義都後面寫
      在類型定義中出現的名字
      可以在構造子中出現

*** >< 交換律
    * 對加法的遞歸定義本身不蘊含交換律
      交換律需要額外證明
      否則 agda 不能處理
      ><><><
      證明之後就能處理了嘛
      找個例子試試

*** cicada v.s. agda
    * table
      |                    | cicada | agda |
      |--------------------+--------+------|
      | dependent pair     | in     | no   |
      | dependent function | in     | in   |
      | compose            | in     | no   |
      | apply              | no     | in   |
      | equality           | in     | in   |

*** lambda
    * lambda is a way you can use to build new term
      lambda is a way you can use to build new type

* towards-a-practical-programming-language-based-on-dependent-type-theory [ulf]

*** pattern match and type checker

*** metavariable and implicit argument

*** module system
