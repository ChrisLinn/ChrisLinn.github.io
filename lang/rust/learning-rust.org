#+title: learning rust

* resource lifetime

  #+begin_src rust
  fn string_lifetime() {
      let s = String:: from("hi!");
      // do something with s ...
  } // s's memory is freed here

  fn resource_lifetime() {
      let mut f = File::open("/tmp/log.txt").unwrap();
      // do something with f ...
  } // f's file is freed here

  // memory is just resource
  #+end_src

* ownership of resources

  #+begin_src rust
  fn get_strange() -> String {
      let s = String::from("hi!");
      s // last value willbe returned
  } // s's memory is not freed

  fn example() {
      let strange = get_strange();
      // s's memory is now owned by strange
  } // strange's memory is freed here
  #+end_src

* ownership rules

  1. each value in rust has a variable thatâ€™s called its owner.

  2. there can only be one owner at a time.

  3. when the owner goes out of scope, the value will be dropped.

* borrow -- passing ownership

*** [note] function call

    - function call do bindings,
      which can be viewed as let bindings in a new block.
      - x -
        or say,
        let bindings can be implemented by unnamed function call.

    - when call a function on some data,
      the data is either moved or copied to the function,
      depending on the type of the

*** value can not be used after move

    #+begin_src rust
    fn hello() {
        let s = String::from("hi");
        hype(s); // value of s moved to hype
        println!("{}", s); // can not use s here
    }

    fn hype(s: String) {
        println!("{}!!!", s);
    }
    #+end_src

*** explicit clone

    #+begin_src rust
    fn hello() {
        let s = String::from("hi");
        hype(s.clone());
        println!("{}", s);
    }

    fn hype(s: String) {
        println!("{}!!!", s);
    }
    #+end_src

*** borrow

    #+begin_src rust
    fn hello() {
        let s = String::from("hi");
        hype(& s); // hype borrows s
        println!("{}", s);
    }

    fn hype(s: & String) {
        // borrowed value will be immutable
        //   read  -- ok
        //   write -- not allowed
        println!("{}!!!", s);
    }
    #+end_src

*** mut borrow

    #+begin_src rust
    fn hello() {
        let mut s = String::from("hi");
        hype(&mut s);
        println!("{}", s);
    }

    fn hype(s: &mut String) {
        // if explicitly expressed
        // borrowed value can be mutable
        //   read  -- ok
        //   write -- ok
        s.push_str("!!!");
    }
    #+end_src

*** borrow in block

    #+begin_src rust
    fn immutable_borrow() {
        let mut s = String::from("hi");
        {
            let borrowed = & s;
            println!("{}", s); // read -- ok
            // s.truncate(1); // write -- not allowed
        }
        s.truncate(1); // write -- ok
        println!("{}", s);
    }

    fn mutable_borrow() {
        let mut s = String::from("hi");
        {
            let mutably_borrowed = &mut s;
            println!("{}", s); // read -- not allowed
            // not allowed because outer block might write it
            println!("{}", mutably_borrowed); // ok
        }
        s.truncate(1); // write -- ok
        println!("{}", s);
    }
    #+end_src

*** [note] principles

    - if you can *read* something,
      no one else can be *writing* it.

    - if you can *writing* something,
      no one else can be *reading* or *writing* it.

* ownership of resources -- in an unnamed way

  - in the following code,
    after takes_ownership(s)
    s can not be used in current scope anymore

  #+begin_src rust
  let s = String::from("hi");
  takes_ownership(s);
  #+end_src

  - this is to say,
    value (on heap) can not have dup refs.
    we can also do this in an unamed way :

  #+begin_src jojo
  "hi" make-new-string-on-heap
  takes-ownership
  #+end_src

  - but we can not use dup

  #+begin_src jojo
  "hi" make-new-string-on-heap
  dup ;; dup refs
  takes-ownership
  #+end_src

  - in a named syntax,
    we can say :

  #+begin_src jojo
  "hi" make-new-string-on-heap :local!
  ;; :local owns the string
  :local
  ;; after then, the value is not in :local anymore
  #+end_src

  - more examples :

  #+begin_src rust
  fn main() {
      let s1 = gives_ownership();
      let s2 = String::from("hello");
      let s3 = takes_and_gives_back(s2);
  }
  #+end_src

  - unamed version :

  #+begin_src jojo
  gives-ownership
  ;; -- String
  "hi" make-new-string-on-heap
  ;; -- String String
  takes-and-gives-back
  ;; -- String String
  #+end_src

* unnamed ownership rules

  1. one value one reference
     'been on the stack' counts as one reference

  2. :local! take value on the stack
     :local  put value back to the stack
     after then, the ref :local is empty

  3. if :local hould structured data,
     :local.field1
     :local.field2
     can be used to get fields

  4. at the end of function call
     all resources hold by :local will be deep free

  --

  - x -
    with 'no dup refs' principle,
    we can use 'copy' to copy structured data,
    but how about destruction ?
    when to destructe a string ?
    for example, the function 'string-append'
    must destructe its two arguments.

  - k -
    we can push this kind of destructors to primitive functions.

  - x -
    how about cons car cdr ?
    if 'no dup refs' principle is used,
    cons can not be shared anymore.

  - k -
    yes.
    cons can not be shared anymore.
    just like 'string-append',
    'cons' will claim ownership of its two arguments,
    and deep copy is needed to copy a structured data.

  #+begin_src jojo
  (+jojo list-append (-> :ante :succ -> List)
    (cond
      [:ante null?] [:succ]
      [:ante cons?] [:ante.cdr :succ list-append
                     :ante.car swap cons]))

  (note we must be explicit about immutable borrow
    in body of list-length
    no 'cons' is used on fields of :list
    thus no ownership taken)

  (+jojo list-length (-> & :list -- Int)
    (cond [:list null?] 0
          else [:list.cdr list-length inc]))
  #+end_src
