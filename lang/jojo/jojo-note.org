#+title: jojo note

* module

*** 合作

    - 需要夠調用別人寫的函數

    - 以 module 爲單位加載別人寫的函數所在的文件
      用 module_record 來記錄已經加載過的 module
      加載過的就不重複加載

*** 命名

    - 需要避免命名衝突

    - 每個函數有實際的唯一的名字
      module/name

    - 在每個 module 加載過程中
      ><

*** 版本

    - 需要控制版本
      module/name

    - ><

*** >< re-export

    - module 正是用 interface function name 來編碼的
      所以可以設計類似 subtype 的機制
      (考慮 ocaml)

* type

*** 類型系統 與 底層語法擴展機制

    - 對於 底層的處理直接處理輸入流的語法擴展機制來說
      如果有類型系統
      那麼每實現一個語法關鍵詞
      就要同時實現與這個語法關鍵詞有關的類型檢查

    - 這並沒有什麼不妥
      因爲每個名字都對應兩個操作
      一個是關於類型的 一個是關於數據的

    - 是否有必要爲 jojo 引入類型系統 ?
      如何處理與 io 相關的 effect ?

*** type of primitive function

    - 比如 jotable 相關的很多函數 都是帶有對 jotable 的副作用的
      用這些副作用 來實現那些被認爲是不帶有副作用的函數 jo->str 和 str->jo 之類的

*** 放棄爲 jojo 引入類型系統

    - 因爲這講破壞 jojo 的簡單性

* syntax

  - x -
    首先這個語言的特點有
    1. 底層
       數據是簡單的
       沒有 overhead
       就像 c 一樣
       因此可以用 c 來擴展
    2. 語法明顯
       因爲解釋其非常簡單
       解釋其本身不能理解複雜的語法

  - k -
    我們使用 sexp
    但是語言本身又是 後綴表達式爲主的
    如何協調呢 ?

* oo

  - x -
    [<object> <class-name> data]
    a <class-name> maintains a message list
    thus we can add new message to it

  - x -
    data field of object
    array or list ?
    or both ?
