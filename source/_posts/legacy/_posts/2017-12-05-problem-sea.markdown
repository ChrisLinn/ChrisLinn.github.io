---
layout:     post
title:      "[杂乱笔记] Problem Sea"
subtitle:   "当年欠上的课，当年欠考的研，当年欠刷的题"
date:       2017-12-05 21:10:00
author:     "LiqueurTofu"
header-img: "img/home-bg-art.jpg"
catalog:    true
tags:
    - 杂乱笔记
---

<br>

+ [CyC2018/Interview-Notebook](https://github.com/CyC2018/Interview-Notebook)
+ [francistao/LearningNotes](https://github.com/francistao/LearningNotes)
+ [linw7/Skill-Tree](https://github.com/linw7/Skill-Tree)
+ [hit-alibaba](https://hit-alibaba.github.io/interview/)
+ [笔试 安全 site:newcoder.com](https://www.google.com/search?ei=mS9OWpmXAob2vgTVr7nICA&q=%E7%AC%94%E8%AF%95+%E5%AE%89%E5%85%A8+site%3Anewcoder.com&oq=%E7%AC%94%E8%AF%95+%E5%AE%89%E5%85%A8+site%3Anewcoder.com&gs_l=psy-ab.3...1325.1325.0.1793.1.1.0.0.0.0.398.398.3-1.1.0....0...1c.1.64.psy-ab..0.0.0....0.m2eGrWBsKwo)
+ [阿里巴巴20160417春招 安全工程师笔试题](http://www.voidcn.com/article/p-fcudgjnz-zg.html)
+ [阿里巴巴2014校园招聘安全工程师笔试题](http://www.voidcn.com/article/p-gbrxemmt-na.html)
+ [2015阿里安全工程师面试经验分享](https://cv.qiaobutang.com/post/55af0ecc0cf21bf395061bf3)
+ [美团点评2017笔试真题-安全工程师卷A](http://www.yunweipai.com/archives/11610.html)
+ [美团点评2017笔试真题-安全工程师卷B](http://www.yunweipai.com/archives/11613.html)
+ [小米安全工程师2015校招求职笔试面试经历分享](http://www.itmian4.com/thread-7264-1-1.html)
+ [2015小米校招【安全工程师】网申+笔试真题分享](https://cv.qiaobutang.com/post/55c02cbf0cf202898d361d0a)
+ [2015小米校招【安全工程师】面试经历及真题分享](https://cv.qiaobutang.com/post/55c0297d0cf2c96ba5fc5346)
+ [web信息安全工程师之技术面试题](https://edu.aqniu.com/article/47)
+ [网络安全工程师面试题tcp/ip篇](https://edu.aqniu.com/article/47)
+ 面试的时候被问到不确定的问题
    * 诚实的说你不太确定, 然后按你的理解和推测说一个大概. 
        - 我不确定，但我猜这个可能是…
    * 做技术的身上有这种知道就知道, 不知道就不知道的诚实品质让人更加欣赏.
    * 如果听过某个知识点但不知道，可以大方点说不知道，但多说说你是在哪个相关知识点上听说这个知识点的，说说相关的东西，又比如，某个知识点听名字你应该可以猜猜干什么的，相关的你知道什么说什么，比如你可能没用过 scoket.io ，但你可以扯扯 webscoket，你不了解 canvas 你可以扯扯 svg，没用过 three.js 但说说什么是 webGL，把主动权拿在手里，我觉得一般的面试官不会介意，你答得好就是高分。
+ Internet 协议安全性 (IPSec)是一种开放标准的框架结构，通过使用加密的 安全服务 以确保在 Internet 协议 (IP) 网络上进行保密而安全的通讯。
+ HTTP协议
    * 通常承载于TCP协议之上
    * 有时也承载 于TLS（ 安全传输层协议 ）或 SSL（ 安全套接层协议Secure Sockets Layer ）协议
        - HTTPS
        - SSL(Secure Sockets Layer 安全套接层)
        - 其继任者传输层安全（Transport Layer Security，TLS）
    * http协议是无状态的，因此需要cookie，session等对客户端浏览器做标明
        - 状态码
            + 1xx（临时响应）：指示信息--表示请求已接收，继续处理 
            + 2xx：成功--表示请求已被成功接收、理解、接受
                * 200 OK      //客户端请求成功 
            + 3xx：重定向--要完成请求必须进行更进一步的操作 
                * 301 永久重定向
                * 302 临时重定向
            + 4xx：客户端错误--请求有语法错误或请求无法实现
                * 400 Bad Request  //客户端请求有语法错误，不能被服务器所理解
                * 401 Unauthorized //请求未经授权，这个状态代码必须和WWW-Authenticate报头域一起使用 
                * 403 Forbidden  //服务器收到请求，但是拒绝提供服务
                * 404 Not Found  //请求资源不存在，eg：输入了错误的URL 
            + 5xx：服务器端错误--服务器未能实现合法的请求
    * HTTP工作在应用层，TCP，UDP工作在传输层。
+ 常见对称加密算法
    * DES
        - Data Encryption Standard
            - 数据加密标准，速度较快，适用于加密大量数据的场合； 
    * 3DES
        - Triple DES
            + 基于DES，对一块数据用三个不同的密钥进行三次加密，强度更高；
    * AES
        - Advanced Encryption Standard
            + 高级加密标准，是下一代的加密算法标准，速度快，安全级别高。
            + AES的区块长度固定为 128  比特,密钥长度则可以是 128 ,192或256比特 ;
    * RC5
        - 分组加密算法，通过异或，加与循环操作加密，是对称的。
            + RC4加密算法是大名鼎鼎的RSA三人组中的头号人物Ronald Rivest在1987年设计的密钥长度可变的流加密算法簇。之所以称其为簇，是由于其核心部分的S-box长度可为任意，但一般为256字节。该算法的速度可以达到 DES 加密的10倍左右，且具有很高级别的非线性。
    * Bloowfish
        - BlowFish 使用了两个box,除了著名的S-box，还有一个p-box 
            + sbox有4×256个unsigned long元素 
            + pbox有18个unsigned long元素
            + BlowFish算法中，有一个核心加密函数，该函数输入64位信息，运算后， 以64位密文的形式输出。 用BlowFish算法加密信息，需要两个过程。
    * IDEA
    * TDEA
+ 常见的非对称加密算法
    * RSA
        - 由 RSA 公司发明，是一个支持变长密钥的公共密钥算法，需要加密的文件块的长度也是可变的； 
    * DSA
        - Digital Signature Algorithm
            + 数字签名算法，是一种标准的 DSS（数字签名标准）；
    * ECC
        - Elliptic Curves Cryptography
            + 椭圆曲线密码编码学
+ Message Digest Algorithm
    * 压缩性
        - 任意长度的数据，算出的MD5值长度都是固定的。
    * 容易计算
        - 从原数据计算出MD5值很容易。
    * 抗修改性
        - 对原数据进行任何改动，哪怕只修改1个字节，所得到的MD5值都有很大区别。
    * 弱抗碰撞
        - 已知原数据和其MD5值，想找到一个具有相同MD5值的数据（即伪造数据）是非常困难的。
    * 强抗碰撞
        - 想找到两个不同的数据，使它们具有相同的MD5值，是非常困难的。
+ 系统利用SPOOling技术便可将一台物理I/O设备虚拟为多台逻辑I/O设备，同样允许多个用户共享一台物理I/O设备
+ 端口号的目的
    * 跟踪同一时间网络中的不同会话
+ Ethernet 的核心技术是它的随机争用型介质访问控制方法，即
    * CSMA/CD
+ FTP
    * 21端口用于连接
        - 客户端首先连接到FTP服务器的21端口，进行用户的认证
    * 20端口用于传输数据
+ telenet
    * 23
+ ssh
    * 22
+ smtp
    * 25
+ RFCs (Request For Comments)
    * 是一种在线的技术报告，任何人都可以下载
+ 记录
    * 逻辑结构
        - 无结构文件
            + 即流式文件，以字节为单位
        - 有结构文件
            + 记录式文件
                * 顺序文件
                * 索引文件
                * 索引顺序文件
                * 直接文件或散列文件
                * 堆文件(散列文件?)
+ ICMP
    * 能够使主机或路由器报告差错情况和提供有关异常情况报告
+ 要把学校里行政楼和实验楼的局域网互连 , 可以通过（ ）实现。
    * 交换机
+ 数据在网络中经历的总时延包括
    * 发送时延
    * 传播时延
    * 排队时延
    * 处理时延
+ andriod dvm的进程和Linux的进程
    * DVM指dalivk的虚拟机，每一个Andriod应用程序都在它自己的进程中运行，都拥有一个独立的Dalivk虚拟机实例，而每一个DVM都是在Linux中的一个进程，所以说可以认为是同一个概念
+ IME_WAIT出现在client端，即主动关闭的那一端
    * 从TIME_WAIT状态到CLOSED状态，有一个超时设置，这个超时设置是 2*MSL
    * TIME_WAIT确保有足够的时间让对端收到了ACK，如果被动关闭的那方没有收到Ack，就会触发被动端重发Fin，一来一去正好2个MSL
    * 有足够的时间让这个连接不会跟后面的连接混在一起
    + ![TIME_WAIT](http://uploadfiles.nowcoder.com/images/20150908/750854_1441709073035_63AE357E551665FD79C9F49FF8BA7E13)
- OSI 参考模型, Open System Interconnect Reference Model
    + 层-协议数据单元, Protocol Data Unit, PDU
        * 应用层--数据
        * 表示层
        * 会话层
        * 传输层--数据段（Segment）或报文 datagram
            - 川段报：川普的段子上了报纸，传输层TCP是数据段，UDP是数据报
        * 网络层--分组（数据包（Packet））
            - 网吧包夜：网络层是数据包
        * 数据链路层(网络接口层)--数据帧（Frame）
            - 素贞：数据链路层是帧
        * 物理层--比特（Bit）
            - 五笔：物理层是比特
- IEEE 802.3、802.4和802.5分别包括了MAC子层协议和物理层协议，其中最大的不同体现在介质访问控制协议，即CMSA/CD、Token Bus和Token Ring。CSMA/CD协议的总线LAN中，各节点通过竞争的方法强占对媒体的访问权利，出现冲突后，必须延迟重发，节点从准备发送数据到成功发送数据的时间是不能确定的，它不适合传输对时延要求较高的实时性数据。其优点是结构简单、网络维护方便、增删节点容易，网络在轻负载（节点数较少）的情况下效率较高。Token Ring不会出现冲突，是一种确定型的介质访问控制方法，每个节点发送数据的延迟时间可以确定。在轻负载时，由于存在等待令牌的时间，效率较低；而在重负载时，对各节点公平，且效率高。令牌总线与令牌环相似，适用于重负载的网络中、数据发送的延迟时间确定以及，适合实时性的数据传输等，但网络管理较为复杂
- 制定局域网标准的主要机构是
    + IEEE802委员会
- 将物理信道的总带宽分割成若干个与传输单个信号带宽相同的子信道，每个子信道传输一路信号，称这种复用技术为
    + 频分复用
- URL
    + Uniform/Universal Resource Locator
    + 统一资源定位符
    + 互联网上得到的资源的位置和访问方法的一种简洁的表示
    + 互联网上标准资源的地址
- SMTP
    + Simple Mail Transfer Protocol
    + 简单邮件传输协议
    + 一组用于由源地址到目的地址传送邮件的规则
    + 由它来控制信件的中转方式
    + 属于TCP/IP协议簇
    + 帮助每台计算机在发送或中转信件时找到下一个目的地
- HTTP, 超文本传输协议
    + HyperText Transfer Protocol
    + 互联网上应用最为广泛的一种网络协议。所有的WWW文件都必须遵守这个标准。
    + 最初的目的是为了提供一种 __发布和接收HTML页面的方法__ 。
- HTML 超级文本标记语言
    + 是标准通用标记语言下的一个应用，一种规范，一种标准
    + __通过标记符号来标记要显示的网页中的各个部分__
        * 网页文件本身是一种文本文件，通过在文本文件中添加标记符，可以告诉浏览器如何显示其中的内容
- 一台10M的集线器连接了5台PC，PC机均安装了100M网卡，每台PC能分配到的带宽最大为
    + 2M
    + __交换机独占带宽，集线器共享带宽。__
- 在各种交换技术中，目前使用最广泛的是
    + 分组交换
* VLAN的主要作用
    - __抑制广播风暴__
        + 把大的局域网划分为几个单独的互不相通的虚拟局域网，隔离广播风暴
        + VLAN主要是限制网络上的广播，将网络划分为多个VLAN可减少参与广播风暴的设备数量。LAN分段可以防止广播风暴波及整个网络。VLAN可以提供建立防火墙的机制，防止交换网络的过量广播。使用VLAN，可以将某个交换端口或用户赋于某一个特定的VLAN组，该VLAN组可以在一个交换网中或跨接多个交换机，在一个VLAN中的广播不会送到VLAN之外。同样，相邻的端口不会收到其他VLAN产生的广 播。这样可以减少广播流量，释放带宽给用户应用，减少广播的产生。
        + 工作在OSI参考模型 的第2层和第3层，一个VLAN就是一个广播域 ，VLAN之间的通信是通过第3层的路由器 来完成的。与传统的局域网技术 相比较，VLAN技术更加灵活，它具有以下优点： 网络设备的移动、添加和修改的管理开销减少；可以控制广播 活动；可提高网络 的安全性。
* 我国对独立型STP (信令转接点, signalling transfer point) 设备要求其信令链路数不得小于
    - 512
* IP 地址
    - A 类
        + 前缀码 0
        + 默认 mask 255.0.0.0
        + 0.0.0.0 ~ 127.255.255.255
    - B 类
        + 前缀码 10
        + 默认 mask 255.255.0.0
        + 128.0.0.0 ~ 191.255.255.255
    - C 类
        + 前缀码 110
        + 默认 mask 255.255.255.0
        + 192.0.0.0 ~ 223.255.255.255
* 如果C类子网的掩码为 `255.255.255.240`，则包含的子网位数、子网数目、每个子网中的主机数目正确的是
    - ４ 14 14
    - 子网掩码 `255.255.255.240` 最后一字节化为二进制表示为 `11110000` 
        + 可以看出IP地址的前三字节以及第四字节的前四位代表子网号
        + 由于是C类IP，前三字节代表网络号，所以子网位数占四位
        + 子网数目为2^4-2=14，减去2的原因是全0和全1不能使用
        + 主机数目为2^4-2=14，减2原因同上
* Linux中的进程通信
    - list
        + 管道 pipe
        + 流 pipe
        + 命名管道 named pipe (FIFO)
        + 内存映射(mapped memeory)
        + 消息队列(message queue)
        + 共享内存(shared memory)
        + 信号量(semaphore)
        + 信号(signal)
        + 套接字(Socket)
    - cmp
        + https://www.jianshu.com/p/c1015f5ffa74
        + http://blog.csdn.net/gatieme/article/details/50908749
        + https://www.ibm.com/developerworks/cn/linux/l-ipc/
        + https://songlee24.github.io/2015/04/21/linux-IPC/
        + https://www.zhihu.com/question/23995948
* [semaphore和mutex的区别](https://www.zhihu.com/question/47704079)
    - Mutex 相比信号量增加了所有权的概念，一只锁住的 Mutex 只能由给它上锁的线程解开，只有系铃人才能解铃。Mutex 的功能也就因而限制在了构造临界区上。
    - Mutex管理的是咖啡机的使用权，而Semaphore管理的是做好的咖啡数量。
        + [emaphore是线程池？n请务必忘记这个例子。mutex干的活儿和semaphore干的活儿不要混起来。调度线程，就是：一些线程生产（increase）同时另一些线程消费（decrease），semaphore可以让生产和消费保持合乎逻辑的执行顺序。semaphore是服务于多个线程间的执行的逻辑顺序的。](https://www.zhihu.com/question/47704079/answer/135859188)
* 临界区
    - 指必须以互斥的方式执行的代码段，也就是说临界区范围内只能由一个活动的线程。例如：修改共享变量的过程中其他的执行线程可能会访问共享变量，那么修改共享变量的代码就被看成是临界区的一部分。
    - 和并发相关的一个概念，临界区指在这个“区”内只能被一个线程访问，后进入 临界区的线程阻塞，等到之前的线程出临界区后，才能访问
    - 不论是硬件临界资源，还是软件临界资源，多个进程必须互斥地对它进行访问。
    - __它可以作为线程间通信方式而不能作为进程间通信方式，因为进程间内存是相互隔离的。__
    - 临界区问题指用安全、公平和对称的方式来执行临界区代码的问题
+ 集成测试
    * 渐增组装测试
        - 测完一个再加上一个一起测试
        - 在单元测试的基础上，采用自顶向下或自底向上逐层安装测试，知道最后安装测试完毕。也可采用自顶向下与自底向上相结合集成测试，单元测试与集成测试相结合来进行集成测试。
        - 将错误分解，容易找到错误并测试成功，适合于大规模的开发系统。
    * 非渐增组装测试
        - 一个一个的测试
        - 将单元测试后的模块按照总体的结构图一次性集成起来，然后把连接的整体进行程序测试。一般用黑盒法来编写测试集并进行测试。
+ Windows NT为管理用户帐号提供的使用程序叫做
    * 域用户管理器
        - 域（Domain）
            + 是Windows NT中数据安全和集中管理的基本单位。网络由域组成，域具有唯一的名称。域可以看作由运行NT的服务器组成的系统，一组电脑共用相同的账户及安全数据库。
            + 域用户帐户的特点
                * 和本地用户帐户不同，域用户帐户保存在活动目录中。由于所有的用户帐户都集中保存在活动目录中，所以使得集中管理变成可能。同时，一个域用户帐户可以在域中的任何一台计算机上登录（域控制器除外），用户可以不再使用固定的计算机。当计算机出现故障时，用户可以使用域用户帐户登录到另一台计算机上继续工作，这样也使帐号的管理变得简单。（参考博文：域用户帐户和组的管理 - zxllife_blog的日志 - 网易博客  http://blog.163.com/zxllife_blog/blog/static/112505046200911154462493/）
+ 采用多路复用I/O监听3个套接字的数据时，如果套接字描述符分别是：5,17,19,则
    * `select(int maxfd,struct fd_set* rdset,NULL,NULL)` 中的maxfd应取为
        - 20
        - Maxfd: 要监视的文件描述符的范围，一般取监视的描述符数的最大值+1
+ 哪个操作符不能作为类成员函数被重载？
    * `?：`
        - 三目运算符
        - 不可重载运算符包括
            + `?:`
            + `::`
            + `.`
            + `.*`
            + `sizeof`
+ 什么函数不能声明为虚函数(虚函数是在运行期间绑定)
    * 普通函数(非成员函数)
        - 不能被覆盖
    * 友元函数
        - C++不支持友元函数继承
    * 静态成员函数
        - 只有一份大家共享
    * 内联函数
        - 编译期间展开
            + 虚函数是在运行期间绑定
        - 不能被取到地址
    * 构造函数
        - 没有对象不能使用构造函数，先有构造函数后有虚函数，虚函数是对对象的动作
+ 引用与多态的关系
    * 引用可以作为产生多态效果的手段
        - 引用是除指针外另一个可以产生多态效果的手段
        - 这意味着，一个基类的引用可以指向它的派生类实例。
+ 插入排序
    * 将元素逐个插入到有序排列之中，其特点是要不断的移动数据，空出一个适当的位置，把待插入的元素放到里面去 
+ 选择排序
    * 每次在无序队列中“选择”出最小值，放到有序队列的最后
+ 设一课完全二叉树共有999个结点，则在该二叉树中的叶节点个数是
    * 500
        - 2^9 - 1 < 999 < 2^10 - 1，所以二叉树有10层，其中前9层有 2^9 - 1个结点，第十层有 999 -（2^9 - 1）=488个结点，所以第9层的244个结点有孩子结点，12个结点没孩子结点，所以叶结点有488+12=500个
        - 其实完全二叉树有这个性质，最后一个节点/2就得到他的父节点了，而此时的父节点必然是最后一个父节点，也就是说他之后的结点都是叶子节点了所以叶子节点为，999-999/2 = 500.
+ 字符串”qiniu”根据顺序不同有多少种排列组合的方式？
    * 60
        - 可以分成2个种情况
            + 第一种,把两个i绑着一起,那么就是A(4,4)=24
            + 第二种,两个i不在一起,三个字符先全排列为A(3,3)再插空,C(4,2)所以为:A(3,3 )* C(4,2)=36
            + 所以为60
        - 先不看有没有重复的，共5个字母，有5×4×3×2×1 = 120种组合. 然后有两个重复的i，所以应该除以2，120 / 2 = 60
+ 若一棵二叉树具有10个度为2的节点，则该二叉树的度为0的节点个数为
    * 11
    * 任何二叉树中度为0的结点比度为2的结点多一个。
+ 和顺序栈相比,链栈有一个比较明显的优势是
    * 通常不会出现栈满的情况
        - 对于链表，插入/除结点是比较困难的，因为每个结点只保存与相邻结点间的关系，如果要插入/删除中间某结点，必须从头遍历到该节点
        - 链表采用的是非连续内存存储的模式，意味着可以从未使用的内存中开辟一个空间，很容易的添加一个结点，这样就不会出现栈满的情况，而对于连续存储的顺序栈而言，是很难增加大小的
        - 顺序栈用数组实现，必须事先确定栈的大小，对内存的使用效率并不高，无法避免因数组空间用光而引起的溢出问题, 而链栈因为动态申请内存，一般不会出现栈满情况，空栈还是会出现的
    * 无论是顺序存储还是链式存储都是操作最后一个元素，所以插入删除都很方便。
+ 如果要求一个线性表既能较快地查找,又能适应动态变化的要求,可以采用下列哪一种查找方法
    * 哈希表查找
        - [浅谈算法和数据结构: 十一 哈希表](http://www.cnblogs.com/yangecnu/p/Introduce-Hashtable.html)
            + [浅谈算法和数据结构: 九 平衡查找树之红黑树](http://www.cnblogs.com/yangecnu/p/Introduce-Red-Black-Tree.html)
        - [散列表](https://zh.wikipedia.org/wiki/%E5%93%88%E5%B8%8C%E8%A1%A8)
        - [十一、从头到尾解析Hash表算法](http://blog.csdn.net/v_july_v/article/details/6256463)
    * [分块查找](http://student.zjzk.cn/course_ware/data_structure/web/chazhao/chazhao9.2.3.htm)
+ 分段系统中信息的逻辑地址到物理地址的变换是通过 段表 来实现的
+ 移位指令中， 应先将移位次数放在 CL
+ 线程共享的内容包括
    * 进程 代码段
    * 进程 数据段
    * 进程打开的文件描述符
    * 信号的处理器
    * 进程的当前目录
    * 进程用户 ID 与进程组 ID
+ 线程独有的内容包括
    * 线程 ID
    * 寄存器组的值
    * 线程的堆栈
    * 错误返回码
    * 线程的信号屏蔽码
+ 哪些字段适合建立索引?
    * 查询,排序,分组 更快捷方便，也就是where，order by ，group by
        - 主键和外键建立索引
            + 因为相对的这两个值比较能确定一些数据，所以比较适合建立索引
        - 在where子句中的字段
            + 因为要在查询过程中减少数据检索，需要使用索引
    * rules
        - 表的 __主键、外键__ 必须有索引；
        - __数据量__ 超过300的表应该有索引；
        - 经常与其他表进行 __连接__ 的表，在连接字段上应该建立索引；
        - 经常出现在 __Where__ 子句中的字段，特别是大表的字段，应该建立索引；
        - 索引应该建在 __选择性高__ 的字段上；
        - 索引应该建在小字段上，对于大的文本字段甚至超长字段，不要建索引；
        - 复合索引的建立需要进行仔细分析；尽量考虑用单字段索引代替：
            + 正确选择复合索引中的主列字段，一般是选择性较好的字段；
            + 复合索引的几个字段是否经常同时以AND方式出现在Where子句中？单字段查询是否极少甚至没有？如果是，则可以建立复合索引；否则考虑单字段索引；
            + 如果复合索引中包含的字段经常单独出现在Where子句中，则分解为多个单字段索引；
            + 如果复合索引所包含的字段超过3个，那么仔细考虑其必要性，考虑减少复合的字段；
            + 如果既有单字段索引，又有这几个字段上的复合索引，一般可以删除复合索引；
        - __频繁进行数据操作的表，不要建立太多的索引；__
        - 删除无用的索引，避免对执行计划造成负面影响；
+ 基于封锁的并发控制
    * 锁的类型有三种
        - 共享（S)锁 （Share Locks，简称S锁）
            + 多个事务可封锁一个共享页；任何事务都不能修改该页
            + 通常是该页被读取完毕，S锁立即被释放。  
            + 如果事务Ti获得了数据项Q上的共享锁，则Ti可读Q但不能写Q
            + 共享锁与共享锁相容
            + 共享锁又称为读锁。若事务T对数据对象A加上S锁，则事务T可以读A但不能修改A，其他事务只能再对A加S锁，而不能加X锁，直到T释放A上的S锁。（因此，共享锁与共享锁相容）。
        - 排它（X)锁 （Exclusive Locks，简称X锁）
            + 仅允许一个事务封锁此页
            + 其他任何事务必须等到X锁被释放才能对该页进行访问
            + X锁一直到事务结束才能被释放。
            + 排他锁又称为写锁。若事务T对数据对象A加上X锁，则只允许T读取和修改A，其他任何事务都不能再对A加任何类型的锁，直到T释放A上的锁。这就保证了其他事务在T释放A上的锁之前不能再读取和修改A。
        - 更新（U)锁
            + 用来预定要对此页施加X锁，它允许其他事务读，但不允许再施加U锁或X锁
            + 当被读取的页将要被更新时，则升级为X锁
            + U锁一直到事务结束时才能被释放。
+ 常见利用内存断点调试的原理
    * 内存断点的实现方式是将你欲下断地址所在的内存页增加一个名为 __PAGE_NOACCESS__ 的属性，这个属性会把当前内存页设为禁止任何形式的访问，如果进行访问会触发一个内存访问异常。
        - 内存断点很消耗资源，因为PAGE_NOACCESS属性一设置就是一整个内存页无法访问，那么当程序访问该内存页中非断点地址的内容同样会触发异常，这时od收到异常后需要进行特殊处理，临时放行，非常消耗资源，甚至这使得内存断点在调试很多大型程序时慢到近乎不可用。
+ [对于Edit控件，如何抓防止密码框内容被抓取](https://www.nowcoder.com/profile/8784357/test/13070841/14275#summary)
    * 没有检查发送WM_GETTEXT或EM_GETLINE消息者的身份
    * 在处理消息事件的时候，对 WM_GETTEXT 和 EM_GETLINE 事件进行过滤
+ DNS欺骗的方式
    * hosts 文件篡改
    * 域名劫持
+ 应用层中简单的跨进程DLL注入的方法
    * CreateRemoteThread + LoadLibraryA/W
    * SetWindowsHook/SetWindowsHookEx
    * QueueUserAPC + LoadLibraryA
+ 以下是一段汇编代码，请用C语言实现相同功能。
    * .
        ```
        .data
        SourceStringdb "Hello, World!",0
        .code
        start:
        cld
        xoreax, eax
        movedi, offset SourceString
        mov al, 'd'
        movecx, 13
        repne scas
        jz wow
        invokeExitProcess, 0
        wow:
        invokeExitProcess, 1
        end start
        ```
        - .
            ```
            if (strstr (“Hello, World!”, “d”) != NULL))
                exitProcess(1);
            exitProcess (0);
            ```
+ 假设有如下所示的一个数字金字塔，现在，要求写一个程序来查找从顶点到底部任意处结束的路径，使路径经过的数字的和最大，并输出该路径的最大和。比如以下金字塔的和最大路径的和为7+3+8+7+5=30。
    * .
        ```
        7
        3 2
        8 1 0
        2 7 4 4
        4 5 2 6 5
        ```
        + .
            ```
            #include <cstdio>
            #include <algorithm>

            int a[500500] = {0};
            int dp[500500] = {0};

            int main(){
                freopen("numtri.in","r",stdin);
                int row_num = 0;
                scanf("%d", &row_num);
                int elem_num = row_num * (row_num + 1) / 2; // 数字金字塔中的元素个数
                for(int i = 0;i <elem_num;i++) {
                    scanf("%d",&a[i]);
                }
                for(int i=0; i<row_num; i++) {
                    dp[elem_num-1-i]=a[elem_num-1-i];
                }
                int n;
                for(int i=row_num-2; i>=0; i--){
                    n = i * (i + 1) / 2;
                    for(int j=0; j<=i; j++) {
                        dp[n+j] = a[n+j] + std::max(dp[n+j+i+1], dp[n+j+i+2]);
                    }
                }

                freopen("numtri.out","w",stdout);
                printf("%d\n",dp[0]);
                return 0;
            }
            ```
+ 假设有如下字符串： (234453)[234]{2324} 现在，要求编程分析其括号配对是否正确。请自行选择下列两种方案之一实现该程序
    * 方案一：不考虑括号优先级，只考虑配对正确性
        - 使用栈，碰到做半部分入栈，如(、[、{，碰到右半部分和栈顶比较，配对则出栈，不配对则返回false；最后判断栈是否为空。
    * 方案二：考虑括号优先级，比如{1[2（3）4]5} 是正确的。但是[1{2}3]是不正确的。 
        - 思路同上，但是检查压栈时要对括号做优先级检查。
+ 百度是一个大型网站，内部含有多个产品线，比如广为人知的贴吧、知道、空间等应用。然而设计这些应用的统一登录平台却是一件非常艰巨的挑战。需要考虑到通用性和安全性。
    * 对于一个Web应用程序，主要的身份验证和凭证保持的方法主要有cookie和session两种。他们又是如何起作用的？各有哪些优缺点？
        - cookie
            + 起作用
                * 保存在客户端, 浏览器内存
            + 优点
                * 实现方便
                * 性能
            + 缺点
                * 数量和长度的限制
                    - 每个domain最多只能有20条cookie，每个cookie长度不能超过4KB，否则会被截掉。
                * cookie不是很安全
                    - 可以分析存放在本地的cookie并进行cookie欺骗
                    - 有些状态不可能保存在客户端。例如，为了防止重复提交表单，我们需要在服务器端保存一个计数器。如果我们把这个计数器保存在客户端，那么它可能被修改。
        - session
            + 起作用
                * 保存在服务器文件
                * 依赖 session id, 而 session id 是存在 cookie 中的（但是可以通过其它方式实现，比如在 url 中传递 session_id）
            + 优点
                * 长度
                * 安全
            + 缺点
                * 性能问题
    * 影响到cookie值作用范围的因素有哪些？请一一说明。 
        - ref: http://blog.csdn.net/john2522/article/details/39324493
            + Cookie 的 Path 属性
                * 把 Cookies 的作用范围限制到服务器的目录，从而允许你把 Cookies 限制到网站的某个应用程序。
            + Cookie 的 Domain 属性
                * 默认时，Cookies 是与特定的域相关联的。 Cookie 的 Domain 属性可以限制 Cookie 的域范围
    * 从安全角度来考虑，一个大型网站的单点登录可能会引入哪些安全问题？如何设计安全的在线单点登录系统？
        - 安全问题
            + cookie 泄漏影响所有子站
            + 单点故障造成整个系统瘫痪
    * What gets printed?()
        - .
            ```
            numbers = [1, 2, 3, 4]
            numbers.append([5,6,7,8])
            print len(numbers)
            ```
        - 5
        - append直接新增一个数据 extend添加相同数据
    * What gets printed?()
        - .
            ```
            print type(1/2)
            ```
        - python2 `int`
        - python3 `float`
    * What gets printed?()
        - .
            ```
            print r"\nwoow"
            ```
        - the text like exactly like this: `\nwoow`
        - Python 用r' '表示' '内部的字符串默认不转义
    * What gets printed?()
        - .
            ```
            class Person:
                def __init__(self):
                    pass
                def getAge(self):
                    print __name__
            p = Person()
            p.getAge()
            ```
        - `__main__`? `__builtin__`?
    * C语言中字符串使用'\0'作为结束符以防止越界
        - python 中字符串其实是一个固定长度的字符数组，并不需要结束符。
        - python 中字符应该视为长度为1的字符串
        - Python 中没有字符类型 char，只有字符串类型 str，即字符也是用 str 类型表示
    * python 中 `global` 的意义，即在局部作用域函数中，声明对全局作用域中的变量的引用
    * `#include <algorithm>`
        - max_element
            + `*max_element(std::begin(v), std::end(v));`
            + `*max_element(v.begin(), v.end());`
            + `*max_element(n,n+len);`
    * `while (cin>>N>>M)`
    * `while(scanf("%d",&n)!=EOF)`
        - 即 `while(scanf("%d",&n)!=-1)`
        - `while(~scanf("%d",&n))`
            + 这种写法的漏洞在于：一但输入的值为字母、符号之类的，scanf赋值不成功把读到的内容又返回到stdin的缓冲区（假设这个值为t），其取反得到的值（scanf得到0，对0取反）使while又进入到下一次循环，scanf又从stdin缓冲区里读到了原先吐回的t，如此成了死循环
    * `while(scanf("%d",&n), n)`
        - 有些题目要求当输入n为0时则不进行处理
        - while(scanf("%d",&n)，n)在while括号里是一个逗号表达式。逗号表达式，它将两式联接起来，如：（3+5,6+8）称为逗号表达式，其求解过程先表达式1，后表达式2，整个表达式值是表达式2的值
    * `int getc(FILE *stream);`
        - `getc(stdin)`
    * `getchar`
        - 有回显，要回车
        - 等同于 `getc(stdin)`
    * `getch`
        - 无回显
        - 非标准函数
    * `getche`
        - 有回显
        - 非标准函数
* 多线程
    - 模型
        + 生产者消费者
    - cpp
        + [C++并发编程(中文版)](https://www.gitbook.com/book/chenxiaowei/cpp_concurrency_in_action/details)
        + 古董
            * `pthread.h`
        * cpp11
            + `<thread>`
            + `<condition_variable>`
            + `<atomic>`
            + `<mutex>`
        - `volatile`
            + `volatile` 与多线程无关
    - python
        + 一个全局解释器锁 (GIL)，使得操作系统原生的线程在Cpython解释器解释执行任何Python代码时，都需要先获得这把锁才行，在遇到 I/O 操作时会释放这把锁。在解释器的主循环中，同时只有一个线程在执行，即在任意时刻，只有一个线程在解释器中运行。
            * GIL并不是Python的特性，它是在实现Python解析器(CPython)时所引入的一个概念
            * CPU 密集型操作反而慢。如果是纯计算的程序，没有 I/O 操作，解释器会每隔 100 次操作就释放这把锁
                - 需要使用 Python 的 multiprocessing 模块
            * IO 密集型还可以，做 I/O 操作时，GIL 总是会被释放。且反正大部分时间都是在等待
                - 如从网上下载资源或者从本地读取文件或者目录
                - thread 模块的增强版 Threading 模块
                    + 直接调用 Thread
                    + 或 通过继承 threading.Thread 实现多线程
                - Python 的 logging 模块线程安全
                - join
                    + sleep等待固定的时间，而join是等待子线程执行完（阻塞）
                        * 如果两个线程a,b, 在a中调用b.join()，相当于合并(join)成一个线程。最常见的情况是在主线程中join所有的子线程。
                            - 这样子线程完了主线程才会完
                - wait
                    + 线程中执行wait()方法后，线程进入Waiting状态，等待其他线程的通知(notify）
                - 锁 try 
                    ```
                    lock = threading.Lock()

                    lock.acquire()
                    try:
                        total += amount
                    finally:
                        lock.release()
                    ```
                - 锁 with 
                    ```
                    lock = threading.Lock()

                    with lock:
                        total += amount
                    ```
                - 可重入锁 RLock
                    ```
                    ```
        