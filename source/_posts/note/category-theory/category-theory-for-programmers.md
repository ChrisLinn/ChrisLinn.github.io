---
title: Category Theory for Programmers
---

# Category Theory for Programmers

------
- Author: Bartosz Milewski
------

Notes taken from video lectures,
the chapter naming of which is different from the book.

- Source of the book: https://github.com/hmemcpy/milewski-ctfp-pdf
- Source of the video lectures:
  - Part I: https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
  - Part II: https://www.youtube.com/playlist?list=PLbgaMIhjbmEn64WVX4B08B4h2rOtueWIL
  - Part III: https://www.youtube.com/playlist?list=PLbgaMIhjbmElia1eCEZNvsVscFef9m0dm

## Note

- **[Xie]** One interesting feature of the teaching of the lecturer is that
  we do not emphasize the historical notes too much,
  but always re-construct the process of development from basic principles.
  By teaching in this way, student starts to think independently
  instead of appealing to authorities.

## I 1.1 Motivation and Philosophy

## I 1.2 What is a category?

Category is about object and arrow (morphism) and composition of arrows,
think of them as type and function and composition of functions.

``` js
f(A): B
g(B): C
(x) => g(f(x)) : (A) -> C
```

Category theory is about composition.

Category theory is also about identity.

The reason for having object is so you can type arrows.

Objects do not serve any propose other than identifying ends of arrows.

From category theory's view object has no structure.

We have mathematical structures like `set_t`, `group_t`, `vector_space_t`,
to define them in the language of category theory,
we must not reach for the concrete structure of their objects.

We must define mathematical structures by describing the relations between their objects,
and the relations we can describe are all equations about arrows.

- **[Xie]** We describe properties only by interface functions of abstract class.

## I 2.1 Functions, epimorphisms

A function is pure if you can memorize it and turning it into a lookup table.

The basic building blocks of programming are types and functions they form a category.

Take example properties from set theory
and limit the language to arrow equations
to translate such properties to category theory.

## I 2.2 Monomorphisms, simple types

## I 2.3 What Are Types?

We can make use of the set theoretical interpretation of type.
but the problem is polymorphic functions that involve circular definitions.

## I 3.1 Examples of categories, orders, monoids

Free category generated by a given graph.

It's an example of a free construction,
a process of completing a given structure
by extending it with a minimum number of items
that satisfy its laws (here, the laws of a category).

When view preorder as category, an arrow is not a function, but a relation.

Preorder is thin category, homset have 0 or 1 elements..

We can view category as generalized preorder, in which homset can have more elements.

- **[Xie]** We can have different proofs of the relation `pre_t`.

Monoid is like pre-group.

Monoid is category with only one object,
thus every two arrows are composable.

We can view category as generalized monoid, in which there can be more objects.

We can view preorder as category, or monoid as category.
We can view category as generalization of preorder, or generalization of monoid.

- **[Xie]** Viewing preorder as category,

  ``` js
  impl preorder_t {
    elem_t: type
    ...
  }

  develop preorder_t {
    as_category = new category_t {
      object_t = elem_t
      ...
    }
  }
  ```

  is different from study the category of all preorders,

  ``` js
  preorder_category: category_t = new category_t {
    object_t = preorder_t
    ...
  }
  ```

## I 3.2 Kleisli category

Objects of a category can be types,
while arrows between `a`, `b` can not only be functions of type `(a) -> b`,
but can also be functions of type `(a) -> (b, string_t)` by redefining composition.

- The `string_t` can be replaced by any `monoid_t`.

This technique can be used to implement logger.
- We can also use global variable to implement logger,
  but using global variable will increase complexity of the code base in a hidden way.
  Also when we need to use multiple core,
  we would have to add global lock to the global variable.

## I 4.1 Terminal and initial objects

One view is that a set is a thing that has elements.
Another view is to not talk about elements, but to talk about arrows.

We can begin with study structure implemented set theory,
then abstract the interface of the structure and forget about elements.

The general method of doing this is called **universal construction**.
It is like googling a pattern (described by arrows),
searching for all hits matching the pattern, and rank them.

Take singleton set as an example,
it is the `unit_t` type in type theory,
from any type `A` there is a function of type `(A) -> unit_t`.

But this is not enough to pin down singleton set yet,
because set is rich in arrows, for any set `X`, as long as it is not empty,
forall `A` there is a function of type `(A) -> X`.

We need to say the arrow from `A` to `unit_t` is unique, to pin down singleton set,
and we call such object **terminal object**.

Not metter what path you take to the terminal object, the path is always the same.

The `unit_t` type has this property,
but even we just add one element to it to get `bool_t`,
the set of paths to `bool_t` will be much more completed,
which is the set of all predicates.

The next question we should ask is how many terminal objects are there?
Terminal object is not unique.
Terminal object is unique up to unique isomorphism.

Actually, to express uniqueness of terminal object,
we need equivalence relation between objects,
but in category we can not use this equivalence relation.
We can compare arrows for equality, but we can not compare objects for equality.
Thus we can only ask for isomorphism between objects.

- **[Xie]** Is it true that we can not use the equivalence relation between objects?
  Maybe we can, but it is just that for universal construction,
  uniqueness expressed by the equivalence relation between objects is too strong,
  for example, product set `A * B` is not equal to `B * A`,
  but `A * B` is isomorphic to `B * A`.

The terminal object as an universal construction,
- The pattern is single object.
- The ranking is that `A` is better than `B`, if there is a unique arrow from `B` to `A`.
  - Note that the ranking is not total but partial order.
the terminal object is the best of such pattern.

An arrow from the terminal object `unit_t` to another object `X`,
can be viewed as picking up an element in `X` (if we view the object `X` as set).

## I 4.2 Products

The **product** of object `A` and `B` as an universal construction,
- The pattern is an object `C` and two arrow `p : C -> A` and `p : C -> B` (`p` for "projection").
- The ranking is that `(C, p, q)` is better than `(C', p', q')`,
  if there is a unique arrow `m : C' -> C` such that
  `p' == compose m p` and `q' == compose m q`,
  `p'` and `q'` have common factor `m`,
  the factor `m` take out the bad part from `p'` and `q'`,
  after which `p` and `q` will be good projections.
the product of object `A` and `B` is the best of such pattern.

- **[Xie]** We need to imagine the picture of the arrows to understand a construction.

- **[Xie]** Is it true that when factoring our programs,
  we have `p'` and `q'`, and we want to factor them into `compose m p` and `compose m q`.
  after which all functions (of type `C -> X`) we developed of `C` can be used for `C'`.

For example, bad candidates,

``` haskell
C = (int_t, bool_t)
p (x, b) = x
q (x, b) = b

C' = int_t
p' = id
q' = true
m : int_t -> (int_t, bool_t)
m x = (x, true)

C' = (int_t, int_t, bool_t)
p' (x, _, _) = x
q' (_, _, b) = b
m : (int_t, int_t, bool_t) -> (int_t, bool_t)
m (x, y, b) = (x, b)
```

- **[Xie]** The uniqueness of arrow `m : C' -> C` will help us to define operators in category,
  such as cross of two morphisms, for `f : A -> B` and `g : C -> D`,
  we can define `f * g : (A * C) -> (B * D)`,
  we needed the uniqueness, because to define functions (operators)
  the relation between arguments and return value must be univalent.

## I 5.1 Coproducts, sum types

The **coproduct** of object `A` and `B` as an universal construction,
is the dual of the construction of product,
- The pattern is an object `C` and two arrow `i : A -> C` and `j : B -> C` (`i` for "injection").
- The ranking is that `(C, i, j)` is better than `(C', i', j')`,
  if there is a unique arrow `m : C -> C'` such that
  `i' == compose i m` and `j' == compose j m`,
  `i'` and `j'` have common factor `m`,
  the factor `m` take out the bad part from `i'` and `j'`,
  after which `i` and `j` will be good injection.
the coproduct of object `A` and `B` is the best of such pattern.

``` haskell
data either_t A B
  = left A
  | right B
```

- **[Xie]** Remember that,
  seeking for interpretation of universal construction in programming language,
  is the same as seeking for interpretation in set theory.

## I 5.2 Algebraic data types

If we view datatypes as elements,
product type as `*` operator,
sum type as `+` operator,
isomorphic (set theoretical) as equivalence relation between elements.

- For example `A * B` is equal to `B * A` because there is a isomorphic between them
  `swap : (A * B) -> (B * A)`.

Then what is the algebraic structure of datatypes?
Is it a ring?
(Remember we use isomorphic as equivalence relation.)

We will see that (datatype, product) form a monoid,
and (datatype, sum) form a monoid,
and product is distributive over sum.

It is not a ring, because sum has no inverse.
It is thus a semiring (or "rig", "ring" without "n" (negative)).
- https://en.wikipedia.org/wiki/Semiring

Let us take (datatype, product) for a walk,
- product is commutative `A * B == B * A`,
  `swap` can be defined by simple pattern matching,
- product is associative `(A * B) * C == A * (B * C)`,
  `product_associative` can be defined by simple pattern matching,
- product has identity element, the `unit_t` type,
  `unit_id_left` and `unit_id_right` can be implemented by simple pattern matching.

Actually all the functions we need to define to verify the algebraic laws,
can be implemented by simple pattern matching.

The pair (datatype, sum) is the same,
in which the identity element will be `void_t`,
and forall `A`, we have `A + void_t == A`.

We also know `A * void_t == void_t`.

We also know `A * (B + C) == (A * B) + (A * C)`.

Examples,

``` haskell
data maybe_t A = nothing + (just A)
-- maybe_t A = 1 + A

data list_t A = null + (cons A * (list_t A))
-- list_t A = 1 + A * (list_t A)
-- list_t A = 1 + A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A * (list_t A)
-- list_t A = 1 + A  + A * A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A + A * A * A * (list_t A)
-- ...
```

- **[Xie]** During transformation of equations,
  the lecturer also used subtraction and division,
  the transformation seems still valid,
  as long as the resulting equation does not contain subtraction and division.

  This feels like using neutral expression in normalization by evaluation.

  We know that the validity of such transformation can be used to extend the algebraic structure,
  maybe the validity of neutral expression can also be used to extend the structure of type theory.

  In the extended theory the neutral expressions will be first class object.

## I 6.1 Functors

Functor is about recognizing pattern of structure in another category.
Functor is about recognizing one category in another category.
Functor is about mapping between two categories.

We generalize function between sets to functor between categories (mappings which preserve structure).
- Sets are structure-less, which is partly the reason why it is hard to implement set in computer.

A category with no structure is a category with no arrows, which is called discrete category.
Which can be used to model set.
If the category is also small, it is exactly set.

Since structure is expressed by arrows,
functor between categories (mappings which preserve structure)
must also describe how arrows are mapped,
and "preserving structure" means respect composition of arrows and id arrow of object.

Category formalize the concept of structure.
Functor formalize the concept of construction that preserving structure.
Functor is like continuous map, connected construction is still mapped to connected construction.

Faithful functor is defined as been injective on all homsets.
Full functor is defined as been surjective on all homsets.
(The mapping behavior on object does not need to be injective or surjective.)
We can also define fully faithful functor as both faithful and full.

Functor of type `functor_t(singleton_category, C)` can be used to pick up object in `C`.
Functor of type `functor_t(C, singleton_category)` is called constant functor.

We define `endofunctor_t(C) = functor_t(C, C)`.

In programming language, a unary type constructor is endofunctor of the category of datatypes.

## I 6.2 Functors in programming

In haskell `Functor` is endofunctor of types.

For example, array-like collections (or say, containers) are instances `Functor`.

``` haskell
type reader_t R A = R -> A
```

when fix `R`, `reader_t R` is a `Functor`.

## I 7.1 Functoriality, bifunctors

In the category of category, an object is a category, a morphism is a functor.

Example of composition of functors,

``` haskell
tail : list_t(A) -> maybe_t(list_t(A))
tail null = nothing_t
tail cons(x, xs) = just_t(xs)
```

All algebraic datatypes are functors,
in categorical semantics functors (initial algebra) can be used to model algebraic datatype.

The product `(a, b)` is called bifunctor, which means when fix one argument, it is a functor.
Bifunctor can also be defined as functor from product of two categories to a category `(A * B) -> C`.

``` haskell
bimap : [f : (type, type) -> type] ->
  (A -> A1) -> (B -> B1) -> f(A, B) -> f(A1, B1)
```

Note that, the canonical sum type `either_t(A, B)` (co-product in category) is still bifunctor,
we do not need sum of two categories to view it (co-product in category of category),
we only need product of two categories (product in category of category).

## I 7.2 Monoidal Categories, Functoriality of ADTs, Profunctors

In monoidal categories, we would like to multiply two object (to return an object),
bifunctor is what we need.

In monoidal categories, we can define tensor product, which has unit and associative.

The ADTs without type arguments can be viewed as constant functor.

For the function type `A -> B`,
fixing `A` we get `A -> _`, which is covariant functor (normal functor),
fixing `B` ww get `_ -> B`, which is contravariant functor.

``` haskell
function_space : (op(C) * C) -> C

dimap : [f : (type, type) -> type] ->
  (A1 -> A) -> (B -> B1) -> f(A, B) -> f(A1, B1)
```

The `function_space` above is called profunctor.

## I 8.1 Function objects, exponentials
## I 8.2 Type algebra, Curry-Howard-Lambek isomorphism
## I 9.1 Natural transformations
## I 9.2 Bicategories
## I 10.1 Monads
## I 10.2 Monoid in the category of endofunctors

A monad is just a monoid-object in the monoidal-category of endofunctors,
where in the monoidal-category tensor-product is functor composition,
thus a special endofunctor, with two morphisms `join` and `pure`.

## II 1.1 Declarative vs Imperative Approach

We have to know why we study category theory.

- **[Xie]**
  From the perspective of programming language,
  the answer is to use category theory to model
  concepts in programming language and type system (categorical semantics).
  When talk about "semantics" I mean both intuition and implementation
  (but nothing more than intuition and implementation).

  From the perspective of mathematics, logic or other knowledge domain,
  the answer would be different.

Can we always implement declarative language in imperative language?
Can we do all that we can do in imperative language in declarative language?

Imperative vs Declarative, like local vs global physics laws.

## II 1.2 Limits
## II 2.1 Limits, Higher order functors
## II 2.2 Limits, Naturality
## II 3.1 Examples of Limits and Colimits
## II 3.2 Free Monoids
## II 4.1 Representable Functors

TODO

``` js
category_t (t, arrow_t, arrow_eqv_t)
set_t : (type) -> type
hom_set : (a: t, b : t) -> set_t(arrow_t(a, b))
(x: t) -> hom_set(a, x)
```

## II 4.2 The Yoneda Lemma
## II 5.1 Yoneda Embedding
## II 5.2 Adjunctions
## II 6.1 Examples of Adjunctions
## II 6.2 Free-Forgetful Adjunction, Monads from Adjunctions
## II 7.1 Comonads
## II 7.2 Comonads Categorically and Examples
## II 8.1 F-Algebras, Lambek's lemma
## II 8.2 Catamorphisms and Anamorphisms
## II 9.1 Lenses
## II 9.2 Lenses categorically
## III 1.1 Overview part 1
## III 1.2 Overview part 2
## III 2.1 String Diagrams part 1
## III 2.2 String Diagrams part 2.webm
## III 3.1 Adjunctions and monads
## III 3.2 Monad Algebras.webm
## III 4.1 Monad algebras part 2
## III 4.2 Monad algebras part 3
## III 5.1 Eilenberg Moore and Lawvere
## III 5.2 Lawvere Theories
## III 6.1 Profunctors.webm
## III 6.2 Ends
## III 7.1 Natural transformations as ends
## III 7.2 Coends
