---
title: Category Theory for Programmers
---

# Category Theory for Programmers

------
- Author: Bartosz Milewski
------

Notes taken from video lectures,
the chapter naming of which is different from the book.

- Source of the book: https://github.com/hmemcpy/milewski-ctfp-pdf
- Source of the video lectures:
  - Part I: https://www.youtube.com/playlist?list=PLbgaMIhjbmEnaH_LTkxLI7FMa2HsnawM_
  - Part II: https://www.youtube.com/playlist?list=PLbgaMIhjbmEn64WVX4B08B4h2rOtueWIL
  - Part III: https://www.youtube.com/playlist?list=PLbgaMIhjbmElia1eCEZNvsVscFef9m0dm

## Note

- **[Xie]** One interesting feature of the teaching of the lecturer is that
  we do not emphasize the historical notes too much,
  but always re-construct the process of development from basic principles.
  By teaching in this way, student starts to think independently
  instead of appealing to authorities.

## I 1.1 Motivation and Philosophy

## I 1.2 What is a category?

Category is about object and arrow (morphism) and composition of arrows,
think of them as type and function and composition of functions.

``` js
f(A): B
g(B): C
(x) => g(f(x)) : (A) -> C
```

Category theory is about composition.

Category theory is also about identity.

The reason for having object is so you can type arrows.

Objects do not serve any propose other than identifying ends of arrows.

From category theory's view object has no structure.

We have mathematical structures like `set_t`, `group_t`, `vector_space_t`,
to define them in the language of category theory,
we must not reach for the concrete structure of their objects.

We must define mathematical structures by describing the relations between their objects,
and the relations we can describe are all equations about arrows.

- **[Xie]** We describe properties only by interface functions of abstract class.

## I 2.1 Functions, epimorphisms

A function is pure if you can memorize it and turning it into a lookup table.

The basic building blocks of programming are types and functions they form a category.

Take example properties from set theory
and limit the language to arrow equations
to translate such properties to category theory.

## I 2.2 Monomorphisms, simple types

## I 2.3 What Are Types?

We can make use of the set theoretical interpretation of type.
but the problem is polymorphic functions that involve circular definitions.

## I 3.1 Examples of categories, orders, monoids

Free category generated by a given graph.

It's an example of a free construction,
a process of completing a given structure
by extending it with a minimum number of items
that satisfy its laws (here, the laws of a category).

When view preorder as category, an arrow is not a function, but a relation.

Preorder is thin category, homset have 0 or 1 elements..

We can view category as generalized preorder, in which homset can have more elements.

- **[Xie]** We can have different proofs of the relation `pre_t`.

Monoid is like pre-group.

Monoid is category with only one object,
thus every two arrows are composable.

We can view category as generalized monoid, in which there can be more objects.

We can view preorder as category, or monoid as category.
We can view category as generalization of preorder, or generalization of monoid.

- **[Xie]** Viewing preorder as category,

  ``` js
  impl preorder_t {
    elem_t: type
    ...
  }

  develop preorder_t {
    as_category = new category_t {
      object_t = elem_t
      ...
    }
  }
  ```

  is different from study the category of all preorders,

  ``` js
  preorder_category: category_t = new category_t {
    object_t = preorder_t
    ...
  }
  ```

## I 3.2 Kleisli category

Objects of a category can be types,
while arrows between `a`, `b` can not only be functions of type `(a) -> b`,
but can also be functions of type `(a) -> (b, string_t)` by redefining composition.

- The `string_t` can be replaced by any `monoid_t`.

This technique can be used to implement logger.
- We can also use global variable to implement logger,
  but using global variable will increase complexity of the code base in a hidden way.
  Also when we need to use multiple core,
  we would have to add global lock to the global variable.

## I 4.1 Terminal and initial objects

One view is that a set is a thing that has elements.
Another view is to not talk about elements, but to talk about arrows.

We can begin with study structure implemented set theory,
then abstract the interface of the structure and forget about elements.

The general method of doing this is called **universal construction**.
It is like googling a pattern (described by arrows),
searching for all hits matching the pattern, and rank them.

Take singleton set as an example,
it is the `unit_t` type in type theory,
from any type `A` there is a function of type `(A) -> unit_t`.

But this is not enough to pin down singleton set yet,
because set is rich in arrows, for any set `X`, as long as it is not empty,
forall `A` there is a function of type `(A) -> X`.

We need to say the arrow from `A` to `unit_t` is unique, to pin down singleton set,
and we call such object **terminal object**.

Not metter what path you take to the terminal object, the path is always the same.

The `unit_t` type has this property,
but even we just add one element to it to get `bool_t`,
the set of paths to `bool_t` will be much more completed,
which is the set of all predicates.

The next question we should ask is how many terminal objects are there?
Terminal object is not unique.
Terminal object is unique up to unique isomorphism.

Actually, to express uniqueness of terminal object,
we need equivalence relation between objects,
but in category we can not use this equivalence relation.
We can compare arrows for equality, but we can not compare objects for equality.
Thus we can only ask for isomorphism between objects.

- **[Xie]** Is it true that we can not use the equivalence relation between objects?
  Maybe we can, but it is just that for universal construction,
  uniqueness expressed by the equivalence relation between objects is too strong,
  for example, product set `A * B` is not equal to `B * A`,
  but `A * B` is isomorphic to `B * A`.

The terminal object as an universal construction,
- The pattern is single object.
- The ranking is that `A` is better than `B`, if there is a unique arrow from `B` to `A`.
  - Note that the ranking is not total but partial order.
the terminal object is the best of such pattern.

An arrow from the terminal object `unit_t` to another object `X`,
can be viewed as picking up an element in `X` (if we view the object `X` as set).

## I 4.2 Products

The **product** of object `A` and `B` as an universal construction,
- The pattern is an object `C` and two arrow `p : C -> A` and `p : C -> B` (`p` for "projection").
- The ranking is that `(C, p, q)` is better than `(C', p', q')`,
  if there is a unique arrow `m : C' -> C` such that
  `p' == compose m p` and `q' == compose m q`,
  `p'` and `q'` have common factor `m`,
  the factor `m` take out the bad part from `p'` and `q'`,
  after which `p` and `q` will be good projections.
the product of object `A` and `B` is the best of such pattern.

- **[Xie]** We need to imagine the picture of the arrows to understand a construction.

For example, bad candidates,

``` haskell
C = (int_t, bool_t)
p (x, b) = x
q (x, b) = b

C' = int_t
p' = id
q' = true
m : int_t -> (int_t, bool_t)
m x = (x, true)

C' = (int_t, int_t, bool_t)
p' (x, _, _) = x
q' (_, _, b) = b
m : (int_t, int_t, bool_t) -> (int_t, bool_t)
m (x, y, b) = (x, b)
```

## I 5.1 Coproducts, sum types

The **coproduct** of object `A` and `B` as an universal construction,
is the dual of the construction of product,
- The pattern is an object `C` and two arrow `i : A -> C` and `j : B -> C` (`i` for "injection").
- The ranking is that `(C, i, j)` is better than `(C', i', j')`,
  if there is a unique arrow `m : C -> C'` such that
  `i' == compose i m` and `j' == compose j m`,
  `i'` and `j'` have common factor `m`,
  the factor `m` take out the bad part from `i'` and `j'`,
  after which `i` and `j` will be good injection.
the coproduct of object `A` and `B` is the best of such pattern.

``` haskell
data either_t A B
  = left A
  | right B
```

- **[Xie]** Remember that,
  seeking for interpretation of universal construction in programming language,
  is the same as seeking for interpretation in set theory.

## I 5.2 Algebraic data types

If we view datatypes as elements,
product type as `*` operator,
sum type as `+` operator,
isomorphic (set theoretical) as equivalence relation between elements.

- For example `A * B` is equal to `B * A` because there is a isomorphic between them
  `swap : (A * B) -> (B * A)`.

Then what is the algebraic structure of datatypes?
Is it a ring?
(Remember we use isomorphic as equivalence relation.)

We will see that (datatype, product) form a monoid,
and (datatype, sum) form a monoid,
and product is distributive over sum.

It is not a ring, because sum has no inverse.
It is thus a semiring (or "rig", "ring" without "n" (negative)).
- https://en.wikipedia.org/wiki/Semiring

Let us take (datatype, product) for a walk,
- product is commutative `A * B == B * A`,
  `swap` can be defined by simple pattern matching,
- product is associative `(A * B) * C == A * (B * C)`,
  `product_associative` can be defined by simple pattern matching,
- product has identity element, the `unit_t` type,
  `unit_id_left` and `unit_id_right` can be implemented by simple pattern matching.

Actually all the functions we need to define to verify the algebraic laws,
can be implemented by simple pattern matching.

The pair (datatype, sum) is the same,
in which the identity element will be `void_t`,
and forall `A`, we have `A + void_t == A`.

We also know `A * void_t == void_t`.

We also know `A * (B + C) == (A * B) + (A * C)`.

Examples,

``` haskell
data maybe_t A = nothing + (just A)
-- maybe_t A = 1 + A

data list_t A = null + (cons A * (list_t A))
-- list_t A = 1 + A * (list_t A)
-- list_t A = 1 + A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A * (list_t A)
-- list_t A = 1 + A  + A * A * (1 + A * (list_t A))
-- list_t A = 1 + A  + A * A + A * A * A * (list_t A)
-- ...
```

- **[Xie]** During transformation of equations,
  the lecturer also used subtraction and division,
  the transformation seems still valid,
  as long as the resulting equation does not contain subtraction and division.

  This feels like using neutral expression in normalization by evaluation.

  We know that the validity of such transformation can be used to extend the algebraic structure,
  maybe the validity of neutral expression can also be used to extend the structure of type theory.

  In the extended theory the neutral expressions will be first class object.

## I 6.1 Functors

Functor is about recognizing pattern of structure in another category.
Functor is about recognizing one category in another category.
Functor is about mapping between two categories.

TODO

## I 6.2 Functors in programming

TODO

## I 7.1 Functoriality, bifunctors
## I 7.2 Monoidal Categories, Functoriality of ADTs, Profunctors
## I 8.1 Function objects, exponentials
## I 8.2 Type algebra, Curry-Howard-Lambek isomorphism
## I 9.1 Natural transformations
## I 9.2 Bicategories
## I 10.1 Monads
## I 10.2 Monoid in the category of endofunctors

A monad is just a monoid-object in the monoidal-category of endofunctors,
where in the monoidal-category tensor-product is functor composition,
thus a special endofunctor, with two morphisms `join` and `pure`.

## II 1.1 Declarative vs Imperative Approach
## II 1.2 Limits
## II 2.1 Limits, Higher order functors
## II 2.2 Limits, Naturality
## II 3.1 Examples of Limits and Colimits
## II 3.2 Free Monoids
## II 4.1 Representable Functors

TODO

``` js
category_t (t, arrow_t, arrow_eqv_t)
set_t : (type) -> type
hom_set : (a: t, b : t) -> set_t(arrow_t(a, b))
(x: t) -> hom_set(a, x)
```

## II 4.2 The Yoneda Lemma
## II 5.1 Yoneda Embedding
## II 5.2 Adjunctions
## II 6.1 Examples of Adjunctions
## II 6.2 Free-Forgetful Adjunction, Monads from Adjunctions
## II 7.1 Comonads
## II 7.2 Comonads Categorically and Examples
## II 8.1 F-Algebras, Lambek's lemma
## II 8.2 Catamorphisms and Anamorphisms
## II 9.1 Lenses
## II 9.2 Lenses categorically
## III 1.1 Overview part 1
## III 1.2 Overview part 2
## III 2.1 String Diagrams part 1
## III 2.2 String Diagrams part 2.webm
## III 3.1 Adjunctions and monads
## III 3.2 Monad Algebras.webm
## III 4.1 Monad algebras part 2
## III 4.2 Monad algebras part 3
## III 5.1 Eilenberg Moore and Lawvere
## III 5.2 Lawvere Theories
## III 6.1 Profunctors.webm
## III 6.2 Ends
## III 7.1 Natural transformations as ends
## III 7.2 Coends
