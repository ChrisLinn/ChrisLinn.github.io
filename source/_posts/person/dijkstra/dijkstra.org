#+title: dijkstra

* ===================================
* note
*** 動機
    * EWD 所關心的問題是
      如何展示數學結果
      用什麼語言去描述它們
      呈現證明的方式並不該被認爲是隨意的個人風格
      EWD 所設計的語言
      能以很好的方式描述日常的數學證明
      儘管這種語言並非完全形式化
* -----------------------------------
* [EWD]
*** [NumerMath59] a note on two problems in connexion with graphs
***** 術語
      點 point node
      邊 branch
      路 path
      點邊相接 connected
      點點相鄰
***** 前提
      1. 聯通圖
      2. 這裏的圖的模型來自於 "運輸貨物"
         其中
         邊 無向
         邊 有一個長度值 [邊無長度者爲此處性質的退化]
***** 選取最小支撐樹
      1. 此類算法階圖之遍歷
      2. <選取之點> <選取之邊>
         <待定之點> <待定之邊>
      3. 以點集爲主來敘述算法
      4. 初 任取
         得一 <選取之點>
         其相鄰者爲 <待定之點>
         自得 <待定之邊>
         於 <待定之邊> 中 取最短者 入 <選取之邊>
         自得 <選取之點>
         其相鄰者爲 <待定之點>
         然而再取 <待定之邊> 時
         則短路而從
         循環此法
         而遍歷所有點
         則算法完
      5. 算法是簡單直觀的
         有趣的是
         這個問題應該如何用程序來表達
         這個問題的解應該如何用數據來呈現
         是複製呢?
         還是做副作用[以標記]呢?
         還是複製之後又與原圖有關聯呢?
***** 求兩點之間的最短路徑
      1. 像波的傳播一樣
*** >< [EWD459] the pattern matching problem
*** [EWD498] how do we tell truths that might hurt?
    1. 如何說真話 即使這些真話非常刺耳?
       只有一個辦法
       那就是 通過把它們說出來 來把它們說出來
       沒有別的辦法
    2. 下面是 EWD 的血腥諷刺
    3. 編程是應用數學中最困難的分支之一
       缺乏相應能力的數學家最好把自己留在純粹數學領域
       不要涉足編程
    4. 跟科學計算有關的應用程序
       都是最簡單的程序
    5. 我們所使用的工具對我們思維習慣有深刻而複雜的影響
       對我們思維的能力而言
       這種影響也是同樣
    6. fortran 這種幼稚之亂
       已經 20 多年了 [到 1982 年]
       對於當今你想要寫的任何應用程序來說
       它都是 能力不足的 笨拙的 危險的
    7. 在實踐中我發現
       想要把優良的編程技術
       教授給 之前學過 basic 的學生
       是不可能的
       因爲作爲潛在的程序員
       這些學生的智力已經被殘廢了
       並且沒有任何補救的希望了
    8. 使用 cobol 會導致腦殘
       因此教授 cobol 是一種犯罪
    9. APL 是把一個錯誤堅持到底
       它看起來很先進很
       其實其技術是落後的
       它製造了新一代的沒有價值的編程
    10. 商業監管中的問題
        尤其是數據庫管理的問題
        是很複雜的
        是超出商人的智力範圍的
        也是超出 sql 這種語言的能力範圍的
    11. 關於程序語言的使用
        要知道
        一把很鈍的斧子是沒法削鉛筆的
        十把也不行
    12. 除了數學能力
        一個程序員想要勝任自己的工作
        他還需要 熟練的掌握自己的母語
    13. 那些出賣自己靈魂
        讓自己的產品依賴於 IBM 的公司
        將會被它們的數據處理系統的龐大的複雜性壓垮
    14. 國防部 [一個電腦製造商]
        所犯下的技術錯誤表明
        其中的人們毫無科學準則可言
    15. 在計算系統中使用擬人化的術語
        代表了這個人職業上的不成熟
    16. 聲稱自己的工作對軟件工程有所貢獻的 "軟" 科學家
        更顯得滑稽可笑
        可悲可嘆的是
        其滑稽可笑並不減少其危險性
        不論 "軟件工程" 這個名字如何
        它都需要殘酷的 "硬" 科學的支持
    17. 古時候物理學家們重複彼此所做的實驗
        正是爲了確認其正確性啊
        而今人們重用代碼
        而不顧代碼的錯誤
    18. 那些標榜自己用自然語言編程者註定毀滅
*** [EWD692] a review of the 1977 turing award lecture by john backus
    1. john backus 是一個好的文學家
       儘管他的文章
       沒有什麼可取的內容
       但是其修辭手法很不錯
    2. 程序被機器執行 機器並不理解程序
       程序被人類自己 人類並不執行程序
       關於 數學語言 與 程序語言 之分離性 EWD 的觀點不對
       但是 關於 不尋求單一的語言  EWD 之觀點正確
    3. 批判 john backus 不懂如何用 "語義映射" 來把理解語言的過程分成層次
       我的蟬語是否也應該接受這個批判呢?
       要知道
       我確實把 參數棧 和 返回棧 都暴露給用戶了
       而我的某些設計決策也確實是爲了減少 "理解的層次"
       就這一點我的辯解有以下幾點
       1) 爲了教學
       2) 儘管使用了 RPN
          但是 我並沒有失去
          以高階的語義去理解我的代碼的能力
       3) 考慮 CPS 之類的編譯技術
          把 一般的代碼轉換到 CPS [RPN] 的過程
          就是試圖重新暴露出某些被抽象掉的語義的過程
          而直接使用 RPN 就避免了抽象泄漏
          並且所獲得的語法其實比 lisp 還好看很多
    4. 我想 EWD 想要進行批判的主要原因是對實現效率的考量
       但是 近40年 過去了
       實現技術已經不可比了
    5. 但是 不論如何
       EWD 的批判教育我們的是
       獲 turing 獎者 不過是平庸之輩而已
    6. FP 作爲一個程序語言
       想要用狹隘的語義來獲得數學上的良好性質
       惘然矣
       其之所以 惘然 EWD 看的很清除
       [即 "函數作用" 作爲一個運算[二元函數] 根本沒有結合性]
       這說明了 狹隘的語義是不可取的
       [比如 haskell 所謂的純粹函數式 就是不可取的]
    7. EWD 之問
       把語言設計得如此這般
       我們獲得了什麼?
       難不成 只獲得了一個新的進行編譯器優化的對象?
       [本身沒有困難 創造困難也要上]
       這種批評同樣能夠適用於 非 RPN 的任何語法
       我並不是說所有的語法都應該是 RPN 的
       我只是說 EWD 的批評能夠成立而已
    8. EWD 批評
       FP 聲稱自己 不使用約束變元
       要知道約束變元其實是爲了
       在 代入語義 中
       標記函數體中的位置的
       因爲 FP 是具有代入語義的[用矩陣來完成]
       所以 其實
       它是在用自然數來[以隱式]標記函數體中的位置
       其實是在用矩陣匹配函數體的形狀
       然後通過在矩陣中標記位置
       來達到對函數體中的位置的間接標記
    9. 其實 john backus 並不是個好的文學家
       他行文顛三倒四 連論理都論不清
    10. EWD 批評了對 "平庸程序員" 這一個詞的使用
        還批評了對 "歷史的必然" 這一個詞的使用
        哦
        其實不是批評
        因爲 EWD 根本就不屑多慮這類詞
    11. 關於 代數系統 EWD 諷刺說
        這裏用以支持作者論點的 "數學證明"
        並不是我學過的那種數學證明
    12. 另外
        EWD 還嘲笑了
        作者用希臘字母來修飾自己的論文
        的愚蠢行爲
*** >< [EWD878] a monotonicity argument
    1. 關於 等邊 對 等角
       因此 等邊三角形 是 等角三角形
       反之亦然
*** [EWD1240a] a little bit of lattice theory
    * *type-constructor*
      (<lattice> = <lattice>)
      (<lattice> under <lattice>)
    * *axiom*
      reflexive of under
      (x : <lattice> -> (x under x))
    * the following proposition is equal to reflexive
      (x y : <lattice> (x = y) -> (x under y) (y under x))
      one-point-rule
      (x x : <lattice> (x = x) -> (x under x) (x under x))
      drop
      (x : <lattice> -> (x under x))
    * *axiom*
      antisymmetric of under
      (x y : <lattice> (x under y) (y under x) -> (x = y))
    * by reflexive of under
      we can proof indirect under
      1. ((x y z : <lattice> (z under x) -> (z under y)) -> (x under y))
      2. ((x y z : <lattice> (y under z) -> (x under z)) -> (x under y))
      proof 1
      (x y z : <lattice> (z under x) -> (z under y))
      instantiate
      (x y x : <lattice> (x under x) -> (x under y))
      reflexive of under
      (x y x : <lattice> true -> (x under y))
      drop
      (x y : <lattice> -> (x under y))
      end proof
    * by antisymmetric of under
      we can proof indirect equal
      1. ((x y z : <lattice> (z under x) <-> (z under y)) -> (x = y))
      2. ((x y z : <lattice> (y under z) <-> (x under z)) -> (x = y))
      proof 1
      (x y z : <lattice> (z under x) <-> (z under y))
      instantiate 2 times
      (x y : <lattice>  ((x under x) <-> (x under y))  ((y under x) <-> (y under y)))
      reflexive of under
      (x y : <lattice>  (true <-> (x under y))  ((y under x) <-> true))
      drop
      (x y : <lattice>  (x under y)  (y under x))
      antisymmetric of under
      (x y : <lattice>  (x = y))
      end proof
    * *axiom*
      the existence of w
      use under to define join [up] [lowest upper bound] [superemum]
      (x y : <lattice> -> w : <lattice> (z : <lattice> -> ((w under z) <-> (x under z) (y under z))))
      define
      (x y : <lattice> -> (x join y))
      or
      (x y : <lattice> -> w : (x join y))
      a new type constructor is defined
      need to proof w is unique
      to view this type constructor as function
    * join
      1. idempotent
         (x join x) = x
      2. symmetry
         (x join y) = (y join x)
      3. associative
         ((x join y) join z) = (x join (y join z))
      proof associative
      ><><><
      end proof
    * wish to proof
      (x y : <lattice> ((x join y) = y) <-> (x under y))
      and use it to proof the transitive of under
      (x y z : <lattice> (x under y) (y under z) -> (x under z))
      thus under is partial-order
      1. reflexive
      2. antisymmetric
      3. transitive
*** [EWD1300] the notational conventions I adopted, and why
***** note
      1. 首先我聲明
         這裏的論點是相當個人化的
         我知道這裏的論點可能有很多反對者
         並且我認爲我的反對者都是愚蠢的
         我瞧之不起
      2. 必須使用優良的記法以對讀者負責
      3. 必須把論點分成
         小的 明顯的 步驟
         以使讀者能夠在不救助於筆和紙的條件下
         僅僅通過閱讀 就能驗證你的論點
         - 否則的話
           爲了理解你的論點
           實讀者其實需要 把你的表達重新組織一遍
           這顯然是不合理的
         - 雖然這裏主要討論的是 數學證明
           但是 寫程序何嘗不是如此呢
      4. 有人懷疑
         "小的 明顯的 步驟"
         這個原則
         會影響表達的間接性與優雅性
         但是其實這種懷疑是沒有根據的
         簡潔並不是省略[省略是不好的]
         - 漢語 中的 省略 會導致對一個文本的多種解釋的可能
           在 使用 漢語 時
           我是不是總在通過 "省略" 以達到簡潔的呢?
           在之後使用 漢語 的過程中我會注意這一點
      5. 有一種撰寫數學文本的風格是
         把證明組織成 一串無由頭的神奇技巧
         這是不對的
         正確的做法是
         去說明論證中的每個 "下一步" 是如何被想到的
         即 你怎麼想到要去嘗試
         這個能夠引導你 到所希望的結論的 "下一步" 的
      6. 模擬天啓以獲尊敬者皆卑鄙小人也皆蠢貨也
      7. 如若
         對變換的表達
         也大部分被省略到你思想的語境中去了
         那麼 "語" 就失去其交流之義
         而退化到記錄爲己了
         這並沒有什麼錯誤
         但是這種文本並不適合呈現給[廣大]讀者
      8. 也就是說
         必須讓文本能夠在最大程度上
         在脫離你個人的思想的語境之時
         也能精確表意
      9. 爲了達到這種效果
         一個技巧是
         經常[嘗試]向你的讀者描述你的思想語境
***** 中綴表達式 [infix notation]
      1. 具有結合性[associative]的運算[二元函數]
         適合使用 中綴表達式
      2. 如果 你使用了中綴表達式
         你可以
         規定 結合順序 和 運算優先級
         以簡化表達式的書寫
         但是不要太多 否則不好記
         當 兩個運算對稱的時候[互逆或對偶]
         不要 引入 運算優先級 而破壞對稱性
      3. 反思了把乘法作爲隱形的中綴符號的歷史錯誤
      4. curry 很重要
         例如使用 "." 作爲中綴的函數作用
         ":" 作爲中綴的函數複合
         並約定其向左結合那麼
         f.x.y == f(x, y)
         f.x == λy.f(x, y)
         f:g.x == f.(g.x)
***** 量詞 [quantification]
      1. 其實是關於約束變元的使用的討論
      2. 約束變元是爲了標記出它的作用域[函數體]中的某些位置
         所以對於每個約束變元 都必須先明白它的作用範圍是什麼
      3. 使用圖的時候 可以避免歧義
         而 利用約束變元 可以對[某類]圖的結構作出線性的表達
      4. 約束變元 在函數體中標記出一個位置
         1) 有待在函數作用時被代入
            - 這是 lambda 的效果
         2) 這個位置的變元跑遍一個集合
            而在函數的作用下
            把一個集合映射成另一個集合
            - 這是 lambda 和 map 的效果
            - 如果被 map 的集合是一個由某個謂詞限定的無窮集
              那麼就必須使用 lazy-list 了
         3) 關於謂詞演算
            如果函數的返回值如果是真假
            那麼 當這個位置的變元遍一個集合時
            在函數的作用下
            就得到一個真假值的集合
            對這個集合用 and 或 or
            就得到 全稱量詞 和 存在量詞
            - 顯然可以看出
              有些量詞是可以消去的
              比如被 map 的集合只有很少個元素的時候
            - 這是 lambda 和 map 和 and或or 的效果
            - 是要注意
              謂詞邏輯引入這兩個量詞
              並不是爲了用它們來計算真假值
              而是爲了給它們賦予運算律
              而使得我們能夠用這些運算律來給邏輯公式做恆等變形
      5. EWD 給出的記法是
         < 約束變元列表 : 謂詞列表 : 函數體 >
         這種記法
         相當於用
         鏈表[集合]這個數據類型 和 約束變元
         一起設計了一個使用這種語法的接口
         也許應該把這個數據結構從接口中分離出來
      6. 可以發現上面的對用謂詞來限定約束變元的集合的行爲
         就類似於給約束變元指定一個類型
         所以說靜態的類型系統還是有一些道理的
      7. 例如
         < i : i < 100 : i * 2 >
         可以看出 把 i 是自然數這個事實作爲類型聲明
         而寫到周圍的語境中
         就將更接近數學表達[的精神]
      8. EWD 的設計是
         1) 無名函數
            < 約束變元列表 : 函數體 >
         2) 集合
            < 約束變元列表 : 謂詞列表 : 函數體 >
         3) 真值
            < 帶量詞的約束變元列表 : 謂詞列表 : 函數體 >
            其實這裏的 "量詞"
            被換成了一個類型爲 :: 集合 -> 值
            的函數
            比如 sum max min sup inf 等等
      9. 上面的設計是不錯的
         [其實 第一個是我加的]
         尤其是對集合的表達
         考慮我以 map 爲基礎而設計的語法
         就知道這種融合性的語法接口是必要的了
         [融合指 數據類型 和 函數 的融合]
      10. 其實
          這種約束變元所能表達的東西更豐富
          考慮多元函數就知道了
          對於多元函數 map 是很不好用的
***** 證明的格式
      1. 把論證的中間步驟寫出
         並用 hint 來說明推導過程
         #+begin_src
           A
         --> { hint why A --> B }
           B
         --> { hint why B --> C }
           C
         #+end_src
         上面的 "-->" 其實可以是偏序關係中的箭頭
         也可以是 對等式的變換 等等
         只要記住其意義靈活就可以了
      2. 把某些對變元的類型聲明放在全局的語境[context]中
         所謂的 "embeddng calculation in context"
         這種有助於明確語義的優良技術
         對於程序員來說是很好接受的
      3. 對等式的證明
         應該用對等式的變形來描述
         而把某些關於等式中的局部變量的聲明作爲語境
         在語境中進行計算
      4. 例子
         若 * 是具有結合性的二元運算
         則 (x * y = y) (y * z = z) -> (x * z = z)
         leibniz-principle : (p = q) (F p) -> (F q)
         associative : ((x * y) * z) -> (x * (y * z))
         證明
         (x * y = y) (y * z = z)
           tuck
         (y * z = z) (x * y = y) (y * z = z)
           leibniz-principle [for y]
         (y * z = z) ((x * y) * z = z)
           associative
         (y * z = z) (x * (y * z) = z)
           leibniz-principle [for y * z]
         (x * z = z)
         證完
      5. 再證明一次
         這次
         leibniz-principle : F (p = q) -> ((F q) = (F p))
         並且直接對等式變形
         x * z
           (y * z = z) leibniz-principle
         x * (y * z)
           apply associative
         (x * y) * z
           (x * y = y) leibniz-principle
         y * z
           (y * z = z) leibniz-principle
         z
         證完
         EWD 認爲 後者的優點在於 使用了更豐富的 "context"
         因而 不必把某些條件在每行都重複
         - 可以理解爲
           有很多信息重複的時候
           就可以通過轉換到局部的更特殊的語境當中
           來避免這些重複
           也就是說
           特殊的語境捕捉重複出現的信息
           有點像是 monad 嘛?
      6. 也就是說
         如果想設計出實用的證明論語法
         在證明等詞的時候
         就必須能夠 直接對等式兩邊的公式進行恆等變形
         而不要 總是以帶有等詞的命題爲單位進行推演
         "->" 與 "=" 是類似的
         對 "->" 使用推演規則時 已經有了記錄語法
         對 "=" 使用變形規則時 也將使用類似的記錄語法
         這就涉及到語法的局部轉換
         也就是說 語法擴展機制 在設計之初就要被考慮到
***** 心得
      1. 如果通過引入對變元的類型
         我能夠讓我的語言獲得更好的性質
         並且不破壞 sexp 和 gexp 中保存各種類型數據的能力
         那麼我就不再排斥類型系統
      2. 我可能沒法實現
         嚴格的類型推導
***** 符號重載
      1. 函數要作爲信息傳遞給數據
         只有當信息和數據類型都明瞭的時候
         才能決定應該調用哪個處理函數去作用於數據
         這樣 在我的語言中我就能把加號重載很多次
      2. 等號所帶來的兩難境地
         當 f, g 是函數的時候
         首先想把 f == g 理解爲一個真值
         其次想把 f == g 理解爲一個函數
         (f == g).x =定義= f.x == g.x
         假設 f, g :: A --> B
         第一次 (==) :: (A --> B) --> (A --> B) --> Bool
         第二次 (==) :: (A --> B) --> (A --> B) --> (A --> Bool)
         - 注意 "-->" 是向右結合的
           也就是說 當輸入是個函數的時候需要加括號
           當輸出是函數的時候不需要加括號
           因爲是完全 curry 的
         - 我現在知道爲什麼數學家喜歡 haskell 了
      3. 上面的兩難性在於
         EWD 想要用同一個函數名 去命名兩個函數
         這兩個函數的輸入數據的類型是一樣的
         - 要知道當輸入的數據的類型不一樣的時候
           我可以通過看輸入的數據的類型來決定使用那個函數
         這兩個函數只是輸出的數據的類型不同
         這樣在就不可能使用相同的名字來命名這兩個函數
      4. 然而蟬語能夠解決這個問題
         [不論第一種函數到底能不能被定義出來]
         #+begin_src cicada
         第一次
           f <:用來返回真假值
           g <:用來返回真假值
           (==)

         第二次
           f <:用來返回謂詞
           g <:用來返回謂詞
           (==)
         #+end_src
      5. 可以從很多角度來看待蟬語的解法
         1) 因爲
            作用時的明顯的參數名[三角名]
            可以被看成是函數名的輔名
            所以
            其實蟬語是在使用不同的名字來命名這連個函數
         2) 這裏 "明顯的參數名" 這種行爲
            可以被理解爲
            當函數作用時
            以明顯的形式指出
            你想要以什麼方式來理解函數的參數
            也就是說
            蟬語認爲
            參數的意義不止是類型而已
            同樣類型的參數也可以以不同的方式去理解
         3) 但是注意
            命名輔名的
            其實就是返回值的類型而已
* -----------------------------------
* 兩個演講
*** 更高效地推理
    1. EWD 很關心證明的風格
    2. 發現對稱性
       避免對問題的過度描述
       即 進行抽象
    3. 避免逐一排查與
       1) 如果條件是 被逐一列舉的
          嘗試 用一個一般性質 重新陳述它
          也許稍微加強條件
       2) 形成小的定理
          來捕捉曖昧的性質
    4. 其實結構主義去形成抽象的意義也在於此
       數的抽象意識也在於此
       當說 三減一 的時候 你不會問 減三個中的哪個一
       因爲它們被視作是對稱的
       即在論證和敘述中
       不需要的干擾信息應該被除去
       直接讓我認識到問題的本質就好了
    5. 在做命名時
       不要引入不必要的[點之間的]區別
       這樣就能保持點之間的對稱性
    6. 如果發現某個命名會破壞圖中點之間的對稱性
       那麼可能就要重新考慮了
    7. 如果名只是爲了區別
       那麼
       當我有它法以示區別時
       就不用名了
    8. 把所需要的性質抽象出來
       在論述中
       用具有這個性質的物體的集合
       代替具有這個性質的物體本身
    9. 用計數法來達到更廣泛的結論
    10. 在形式證明中
        你知道你要把一個 bool 表達式變換成另一個
        第一個和最後一個表達式中的符號會有很多特點
        通過對某些符號的計數
        [比如 函數f的作用的個數 運算y出現的個數 等等]
        你可以捕捉某些一般的性質
        [引入的某個符號 必須在達到證明結果之前被消去 等等]
        這些性質能夠啓發你的證明
        [幫助你檢驗證明的正確性]
        [幫助你認識到自己證明的方向]
    11. 避免試錯試錯算法
    12. EWD 說
        我們沒有一個好的符號來記錄無序的集合[對子]
        所以我們就要在很多地方引入不必要的不對稱性
        但是這很好解決
        只要不把自己限制在線性的表達式上就行了
        使用圓圈把一個對子圈出來
        圓的對稱性就表示了這個對子是無序的對子
    13. 當加法具有交換性的時候
        它的兩個參數必須作爲無序對被填入加法的函數體中
        以維持對稱性
*** 令人[EWD]機動的數學結論
    1. 用向量的等式
       證明三垂線相交於一點
    2. 用乘方來一位一位地算[以10爲底的]對數的算法
       以 log.2 爲例
       第一位爲
       10*log.2 ==
       log.1024 ==
       3
       第二位爲
       10*(log.1024-[第一位]) ==
       10*(log.(1024/10^[第一位])) ==
       10*(log.(1.024)) ==
       log.(1.024^10) ==
       0
       等等
       用到的性質在於十進制下一個數的以十爲底的對數是很顯然的
    3. 引入兩個附加的變量
       一起做循環
       就可以
       在算最大公因子的同時
       算出最小公倍數
       [只用加減法而已]
       因爲新變量和主要變量還有初始量之間可以維持一個等式
       [程序中的不變量的力量]
    4. 用換妻遊戲來介紹兩種風格的證明
       一次是逐情分析
       一次是計數不變量[並且形式化]
* on the shape of mathematical arguments
*** >< a termination argument
*** note
    1. 值得一提的是這本書的作者 van Gasteren
       是一位女性
    2. 只要強調某些常識性的原則
       就 敘述論證而言
       很多的風格選擇問題
       就不成爲題了
       該遵從什麼樣的約定將是顯然的
    3. 形式化 應該幫助數學家思考
       而不應該成爲數學家的負擔
       而這本書的核心結論將是
       形式化 有利無害
       [當然進行形式化的過程要複合一定的原則]
    4. 重要的論點是
       1) 別去命名沒有後必要命名的東西
       2) 千方百計以維護對稱性
    5. 一個錯誤是
       作者的在敘述的時候把自己限制在線性的文本當中
       整本書連一副圖都沒有
       用笨拙的語言描述很久也描述不好的場景
       通過一副圖就能很容易來說明
       作者沒有認識到這一點
*** >< a problem on bichrome 6-graphs
*** >< proving the existence of the euler line
*** in adherence to symmetry
    1. 不要給那些
       在論證中根本不會出現的
       全局變量[比如序列的長度]
       以名字
    2. 這是關於古典的不等式的
       在敘述方面
       也許
       先給出古典的大家熟悉的敘述方式
       再介紹新的敘述方式 會更好一些
    3. 兩種敘述方式的區別在於
       |------------------+----------------|
       | 古典             | 新             |
       |------------------+----------------|
       | 兩個數列         | 兩個無序數集   |
       |------------------+----------------|
       | 數列的長度       | 集合 其大小    |
       | 數列中的每個元素 | 其元素         |
       | 都有名字         | 都無名         |
       |------------------+----------------|
       | 規定 單調性      | 一一映射       |
       | 並命名 置換      | 以說明對應關係 |
       | 以說明對應關係   |                |
       |------------------+----------------|
       | 展開以定義和     | 遞歸以定義和   |
       |------------------+----------------|
       | 結論很直觀       | 利用兩個引理   |
       | 但是這裏的敘述   | 來敘述結論     |
       | 稍顯笨拙         |                |
       |------------------+----------------|
    4. 可見
       這種敘述風格的衝突
       在數論和數學分析中是多麼尋常
*** 心得
    1. 這裏我已經看到在敘述中
       把與所關心的問題無關的東西明顯的表述出來
       都是有害於敘述的清晰性的
       這是顯然的
       因爲這些額外的東西帶來了 "認知的負擔"
    2. 尤其是關於 "命名"
       去命名的能力是必要的
       但是不恰當的 "命名"
       是最主要的把無關的東西引入敘述的方式
*** on a proof by Arbib, Kfoury, and Moll
    1. 這篇是對上面三個作者的論證風格的批判
       - 他們證明的命題是很簡單的
         當你明白什麼是同餘符號 mod 之後
         這個定理是不證自明的
       他們的風格展示了一種可怕的反面教材
       基本上說明了
       上面三個作者不足以任其學者之職
    2. 批判
       用相互推導 來證明兩個命題的等價
       - 類似的有
         用兩個不等式 來證明一個等式
    3. 批判
       不知使用 mod 這個記號
    4. 批判
       論證時的含糊其辭
    5. 批判
       使用最原始形式的歸納法
       要知道就計算機科學而言
       論證某個程序的運行會在有限的時間內結束時
       經常以相當自由的方式 來使用歸納法
    6. 其罪過真是罄竹難書
       所以我就不多說了
    7. 沒有東西相加就是 0
       沒有東西相乘就是 1
       所以我們有 2^0 == 1
       即 沒有 2 來相乘的時候得到的就是 1
       所以說
       "除了 1 以外所有的正整數 要麼是素數 要麼是素數的乘積"
       應該被改成
       "除了 1 以外所有的正整數 是素數的乘積"
       進一步 應該被改成
       "所有的正整數 是素數的乘積"
*** not about open and closed sets
    1. 這是一個由論證的語法[而不是語義]
       引導證明者到結論的例子
       - 在這裏所使用的形式敘述風格下
         解[證明]幾乎是唯一的
    2. 同時這也是對另外一種證明風格的批評
       這種證明風格在這裏的標準看來根本就不算是證明
    3. 在學習拓撲之初
       我也觀察到了一系列非常對稱的定理
       那時 我也想發明自己的論證風格以整理這些定理
       但是 那時我並沒有能力完成這個任務
       現在我明白了
       EWD 的符號系統[也許加上我的一些改進]
       正是當時我所求而未得的
    4. 這一節的討論說明了
       在使用 EWD 的符號系統的時候
       最好先給這個符號系統建立一些簡單的規則[引理性的]
       即 這個[用來記錄集合的]符號系統跟某些函數的關係
       - 所說的函數
         比如
         謂詞演算中的量詞
         算數中的求和
         命題演算中的推導
    5. 用集合論的謂詞演算解釋
       而不用集合論本身
       來進行論證的敘述
       有的時候方便很多
       因爲謂詞演算[命題演算]是對等式的形變
       而集合論更爲複雜一點
       - 因爲它們都是 [抽象的] bool 代數
         這在與
         集合計算中
         對 空集和全集的等式 可以被翻譯成 bool 代數
    6. 對一個對象的表示揭示了這個對象的內部結構
       如果在論證中這些內部結構並不重要
       那麼就別去使用這個對象的表示
       而直接使用這個對象的名字
    7. 仔細的辨別出來那些東西是需要命名的
       那些東西是不需要命名的
    8. 也許在使用蟬語編程的時候也是如此
       在使用程序語言編寫代碼的時候
       某些時候人們寫出的代碼可能非常難讀
       這可能是因爲
       1) 應該省略命名[約束變元[局部變量]]的時候
          編碼者 還是在命名
          也許語言根本就沒有提供 不命名而引用一個數據的機制
          [比如 scheme]
       2) 應該使用命名[約束變元[局部變量]]的時候
          編碼者 沒有使用命名
          也許語言根本就沒有提供 臨時地形成一個名到值的映射的機制
          [比如 forth]
       3) 應該使用全局變量[在語境中做一些約定以避免某些重複]的時候
          編碼者 沒有使用全局變量
          也許語言根本就沒有提供機制 來讓你形成全局範圍內的名到值的映射
          [比如 CPS 和 monad]
       4) 不應該使用全局變量的時候
          編碼者 還是在使用全局變量
          [比如 匯編語言]
    9. 可見
       造成難以閱讀的困境的
       可能是語言的設計錯誤
       也可能是編碼者的風格錯誤
    10. 那麼
        想要把一個語言設計正確
        就必須提供機制
        以讓編碼者能夠
        在需要的時候
        選擇以使用各種風格來進行編碼
        這就是蟬語要做的
    11. 名在蟬語中有三種
        1) 全局變元名
        2) 約束變元名在函數定義中的出現
        3) 約束變元名在函數作用中的出現
        在數學證明中
        通過減少命名 我能夠 揭示 對象之間的對稱性
        而通過 命名我能夠隱藏 對象的內部結構
        那麼在 編程之時 情況如何呢???
*** 心得
    1. 在讀上一節的時候
       我同時學習了
       關於 抽象的 bool 代數結構的知識
       利用抽象的代數結構[數學結構 因爲還有 格]的術語
       我甚至能夠把上面的證明敘述地更清晰簡練
    2. 這就凸顯了現代數學的重要方法論
       即
       在類比中觀察
       把共性進行抽象
       以形成更好的認識
       [控制複雜性]
*** >< a monotonicity argument
    1. 這一小節的內容是 EWD878 的改進版
    2. 以相互推出證等價是初等幾何中常見的論證方式
       但是並不要濫用這種論證方式
    3. 我覺得這篇不好看
*** >< on the inverse of a function
*** ><><>< a calculational proof of Helly's theorem on convex figures
*** ----------------------------------
*** >< clarity of exposition
*** on naming
***** note
      1. 這是關於名的一般討論
      2. "名的意義是什麼"
         這是一個[極爲]困難的題目
         其難度幾乎和語言這個題目相當
      3. 相對簡單的是
         "如何命名" 還有 "命名什麼"
         這兩個問題
***** 數學論證中的非形式語言
      1. 人對語言要素的辨認有歧義
      2. 數學語言和程序語言在用名時
         其人所慾義 與 其詞之本義 之間有衝突
         即 與自然語言有衝突
         - 除非讓用名之詞源 脫離自然語言
         - 我在讀用英文寫的數學文獻[比如這本書]的時候
           就能體會到某些非數學層面上的困難
           首先書的作者是荷蘭人
           而書用英語寫成
           荷蘭語與英語雖然同源
           但是其基本詞和用詞習慣亦有分疏
           而讀者是中國人
           其母語漢語與英語[荷蘭語]分屬不同語系
           我所遇到的閱讀困難也不足爲奇了
           而這些困難都是非數學層面上的
      3. 數學語言和程序語言在用名時
         用 顏色 聲調 之類的
         語義單純的詞似乎是一種解決辦法
         [比如三染色算法]
      4. 數學語言和程序語言在用名時
         如果選取了一個 在自然語言中 具有豐富語義的詞
         儘管重新定義以聲明 詞之義 在文本中是受限制的
         但是當遇到這個詞的時候
         這個詞的原本語義還是會對讀者的思維形成干擾
      5. 在鑄造術語[漢語]時
         也許 我應該去選擇一些意義陌生的字
         以避免與自然語言相互衝突
      6. 從這裏也可以看出
         設計有別於自然語言的數學形式語言的必要性
         對程序語言而言 情況也是同樣
      7. 關於
         對應與某一個術語的否定性術語的缺乏
         這裏有一個有趣的討論
         這裏的觀點是
         否定性術語應該有自己的特名
         而不該用肯定性術語加以詞綴來獲得
         [這樣能夠減少讀者認知上的負擔]
         - 否則 就有 "單調不增函數" 這種術語
           這裏建議的術語是 "上升函數" [ascending]
           有例如
           不等於 --> 異於
           不大與[小於等於] --> 至多[at most]
           不小與[大於等於] --> 至少[at least]
           其實上面兩個例子的漢語版本
           還是在用否定前綴
           至 == 不
           多 == 大
           這是漢語的問題
           還有 "正整數" "正或零" 這種例子
***** 啓示
      1. 這裏所描述的自然語言之困難
         也許暗指了
         在設計程序語言[數學語言]時
         可以去考慮使用類似 solresol 這種人造語言的詞法系統
      2. 這就需要良好的設計
         否則很難被接受
         比如就程序語言而言
         怎麼利用七個音符呢?
         用它們來命名 數據類型?
         用它們來命名 棧處理函數之類的小精靈?
      3. 這種意義上來看
         如果引入得當
         solresol 就可以被作爲
         數學和計算機科學中的輔助語言
***** 數學論證中的形式語言
      1. 首先這裏對語素的辨認是沒有[不應該有]歧義的
         這一點 蟬語 就做的很好
         即 所有的語素都必須用空格隔開
         比如
         在蟬語中 p^ 不可能是
         一個名字叫 "^" 的函數
         作用與 "p"
         要想達函數的作用就必須用空格
         把 函數 和 參數 分開
         在數學符號中
         這種討論就引起了對 上[下]標記法 的批評
         因爲它們會與函數作用相互混淆
         又比如
         當 "x" 以有他用的時候
         又引入 "x_1 x_2 ..."
         來命名一個 與 "x" 之原來的用處 不相關的數列
      2. 關於 如何命名
         首先 符號的意義在於[在論證中]被處理
         所以 選取符號就應該以易於處理爲原則
      3. 注意上面那個是本書中的原則
         而我個人則認爲 "易讀性" 比 "易寫性" 要重要的多
         - "易讀性" 之定義爲
           在最大程度上減少閱讀者對語義的 "認知負擔"
         如果 "易寫性" 被等同於 "易處理性" 的話
         那麼關於這個問題
         我所認同的原則
         就完全與本書的原則相反了
      4. "名字越簡短越好"
         在數學論證中這也許被認爲是好的原則
         但是在編程中這絕對是錯誤的原則
         事實是在數學文獻中
         幾乎所有的作者都很少使用 詞 來命名
         而都使用字母
         這種現象值得被好好討論一下
         1) 在寫程序的時候
            我並沒有感受到長的命名所帶來的不變
            而在寫數學公式的時候
            我卻能夠感受到長的命名所帶來的不變
            可能是因爲在一個設計好的文本編輯器的幫助下
            打字的輸出效率比手寫要高出很多很多
            如果真是這樣
            那麼
            在數學中不使用長命名的主要原因就是
            不利於寫
         2) 另一個原因是
            機器可以把長的公式排版地很整齊
            而人在書寫數學手稿的時候常常疏於排版
            所以當使用長的命名的時候
            就會感覺很亂
         3) 但是要知道
            [至少是目前爲止]
            書寫手稿的優越性在於能夠突破線性文本的限制
         4) 在蟬語中 在不同的時候
            空格 可以被當作 函數複合 或 函數作用
            因爲在手寫中卻不行
            因爲手寫體中的空格太不穩定了
      5. 還可以發現
         由於西方拼寫語言與漢語的本質不同
         很多的討論在漢語方面是不適用的
         [比如 大小寫 字母的順序 等等]
      6. 在今後的書寫中
         我會利用在程序語言中的經驗
         來審視書寫數學文本時的某些習慣
         尤其是嘗試使用長的詞[或漢字]
         來命名某些約束變元將是很有趣的
      7. 作者批評了對希臘字母的使用
         但是其實
         使用希臘字母和使用大小寫字母的本質是一樣的
      8. 關於 命名什麼
         第一個原則是 儘量少命名東西
         沒必要進行的命名的例子是
         "任意一個正整數 n 都可以被以唯一的方式分解成素數的乘積"
         其中 "n" 就是一個沒有必要的命名
         因爲之後就再也引用不到 "n" 了
         另外一種常見的過度描述的例子是
         "不失一般性我們可以取什麼爲什麼"
         既然 取一個特殊的元素 也 "不失一般性"
         [那麼 一定是因爲有某種對稱性存在]
         那麼如果不取這個特殊的元素
         我們就能維護原本的對稱性
         - 本書作者的觀點是
           此時如果維護對稱性
           那麼我們就常常能把
           "逐一分析組合方式" 這種風格的證明
           改寫成
           "量化某個性質而計數這個量" 這種風格的證明
      9. 除了命名過剩對對稱性的破壞之外
         還有命名不足最對象細節的暴露
      10. 在變換等式或邏輯表達式的時候
          當有一個子表達式被拖着走了很長時間
          那麼可能就應該給這個子表達式以名字
          或者把這個子表達式所代表的條件敘述於論證的語境中
          以避免重複
      11. 另外
          如果
          當用一個抽象的名字掩蓋起來某個對象的內部細節之後
          論證還是能夠正常進行
          那就說明這段論證根本與被掩蓋起來的內部細節沒有關係
          這樣就能幫助我們進行正確的抽象
          其次 推遲對名的展開 其實是在控制複雜性
      12. 另外
          蟬語[或 forth]中的 re-factoring
          其實就是重新命名的過程
          所以也可以稱之爲 re-naming
          這裏 通過改變命名方式
          我們對某個算法[函數]的理解
          可能完全被改變
      13. 推遲對名的展開
          在蟬語中也是常見的
          尤其是當從上倒下地來寫一個函數的時候
      14. 這種對名的逐漸展開還具有引導性
          數學論證方面 還有 蟬語方面都一樣
          考錄一個大函數
          和一個被良好因子化了的函數就知道了
      15. 另外
          要注意這裏的論點其實都是
          圍繞某些典型的例子來總結的
      16. 命名錯誤的對象
          這種情況的例子是
          如果函數 f 總是 以所用於值 a 的面貌出現
          即 f.a
          那麼就不應該用兩個名去分別命名 函數與參數
          而應該直接用一個名去命名這個表達式
      17. 另外一個設計數學證明時的設計決策是
          去使用 集合
          還是去使用 生成這個集合的謂詞
          本書的作者的觀點是謂詞好
          因爲命題演算中的等式比集合論的等式更容易進行變形
          - 但是爲什麼會有這種現象?
            集合運算 和 命題演算
            同屬於 抽象的 bool 代數
            而 命題演算 是最簡單的 非平凡 bool 代數
            所以 它的性質要正規的多
            [同時它的性質也比較貧乏]
      18. 最後一個論點是關於下標和上標的
          要知道矩陣運算的發明
          完全是爲了避免書寫過多的線性方程組
          後者是不方便書寫的
          因爲其中充滿了 下標和上標
***** 關於 "易閱讀" 與 "易書寫" 的衝突
      1. 其實 都是爲了 減少思想者認知上的負擔
         思想者 就 既包含了 寫者 與 讀者
*** on the use of formalism
***** note
      1. 其實這裏的某些論點都是歷史性的
         現在形式主義已經處主導地位了
         尤其是考慮到計算科學對形式化的要求
         這種主導地位的正確性就更加明顯
      2. 計算科學給形式主義所提出的新的要求
         不光是具有精確性和簡潔性
         更重要的是
         用來給算法和證明以形式的數據結構本身
         也要能夠被算法和證明來處理
***** 啓示
      1. 我應該試着用我設計的語言表達一些標準算法
         並且在這個過程中觀察我語言的實用性質是否如我所願
***** 關於中綴表達式
      1. 具有類型 set --> value
         的函數
         都是由具有結合性的運算所生成的
         - 考慮 ewd 的記號系統就知道了
         反之也一樣
         當一個運算具有結合性的時候
         就可以用它來生成
         有序集 --> value
         當它又具有交換性的時候
         就可以用它來生成
         無序集 --> value
      2. 並且這個所生成的函數作用於空集時
         就得到這個運算的單位元
         [這其實又是一次生成]
***** 作爲數據結構的形式語法
      1. 在設計形式語法的時候
         注意
         1) 語法解析的可能性
         2) 對稱性
            以二項式係數爲例子
      2. 函數作用具有很多形態的形式記法
         運算[作用]優先級被認爲是很高的函數
         就會被以上下標 或 括號等方式記錄
         - 我顯然要避免使用這種記錄方式
      3. 一定要把運算律表達爲對公式的變換
         [而不要使用其他奇怪的表達方式]
      4. 算數運算中的等號
         還有 謂詞演算中的等號
         使用了不同的符號
         這是因爲沒有使用運算符重載
      5. 使用運算符重載的缺點是
         每當一個函數作用的時候
         爲了明確其意義
         都必須知道被作用的參數[可能是一個約束變元]的數據類型是什麼
      6. 這就給蟬語中的運算符重載提出了一個難點
         因爲在一個函數定義中調用了一個動態的消息傳遞
         消息傳遞給一個約束變元
         如果約束變元的類型是不確定的
         那麼對這個函數作用的返回值的控制
         就超出了函數定義的能力範圍
         也許
         合理的是
         此時爲了讓一個數據類型能夠被某個函數處理
         必須把這個函數登記到這個數據類型下
         在做登記的時候
         你同時擁有兩方面的信息
         此時你才能確定這個函數作用與這個參數之後會不會形成有效的操作
         也就是說一個函數體被重用以處理多種數據結構了
         在登記的時候
         如果 你必須保證這種處理能夠有效進行
         - 上面的討論其實說明了
           我對這種消息傳遞的考慮還是不夠充分的
           考慮其他語言對這種問題的處理方式就知道了
           比如 ocaml 和 haskell
      7. 關於推演規則的選擇
         注意如何形成輔助性的推演規則
         [就像輔助函數的使用一樣]
         [推演規則和對等式的變換規則是一樣的]
      8. 關於表達證明的格式
         形成 證明[尤其是形式證明] 的感覺類似於
         在森林裏尋找一條從條件到結論的路
         但是又有區別 比如 條件可以是很多個
         有時兩個條件才足夠讓你達到一個結論
         [所使用的圖論模型必須捕捉到這個性質]
         所以
         有點像是 在一個有向圖中
         給定了一些點
         需要從這些節點出發
         用有向邊達到目的節點
         [目的節點 將作爲最終形成的有向樹的根[注意定向]]
         但是某些有向邊能夠行走[這些有向邊的存在]
         是以某些點的存在爲前提的
         [有向邊就代表了推理規則]
         這個模型就對了
         - 可以發現這一定是一個無限的有向圖
           對這個有向圖的操作
           一定是以對這個 無限有向圖 的特殊編碼[良好編碼]爲基礎的
         - 證明幾乎就是純粹的遊戲
           這說明了
           如果設計一個輔助證明系統
           那麼它的用戶界面一定要設計地像一個遊戲一樣
         - 在這裏由已有的推演規則可以形成輔助性的推演規則
           就像輔助函數一樣
           每個推演規則的語義都是
           [每個推演規則所捕捉的概念都是]
           一種形成有向邊的模式
         - 一定是 格 嗎???
         - 需要實際的經驗以檢驗上面的模型的可行性
      9. 重要的認識是有向圖有層次
         比如
         命題演算中的推演規則
         被認爲是在一個有向圖中做遊戲
         而
         命題演算本身作爲 抽象的 bool 代數
         也是一個有向圖 [bool 格]
         所以
         在各個層次 都有有向圖
      10. 邏輯推演 與 運算又有什麼區別呢?
          既然機器輔助證明系統存在
          那麼 邏輯推演 與 運算 就沒有區別
***** 疑惑
      1. 說 X -> Y 與 X and Y = X 等價 是什麼意思??
         是說 它們 的真值表 相同??
         是說 它們 作爲[二元]函數 是相同的函數??
         是說 (X -> Y) = (X and Y = X) 永真??
         如果這上面的三個定義是 "等價" 的
         那麼 "等價" 在上面那句話中又是什麼意思???
      2. 真假不重要
         重要的是函數相等不相等
         但是對 "函數是相等的" 這句話的肯定
         卻會返回一個 真假 值
      3. 這裏的困難在於我不知道思想的根基是什麼
      4. 而我認爲思想的根基可以[應該]被取爲基本等詞
         但是這又需要命題演算了
         因爲我必須能夠說 "等詞爲真"
      5. 只要解決了命題演算這個數學結構
         我就能獲得其他數學結構所需要的基本等詞了
         也就是說
         我需要假設人們能夠區分 true 和 false
         這樣
         一個等詞 就是一個到 true 和 false 的[二元]映射而已
         但是當我說我能夠區分 true 和 false
         就是說我能夠判斷它們是否相等
         這裏又需要一個基本的等詞
         我必須假設這個等詞是公理性的
         這個基本的等詞不能用 其到自身的映射來解釋
         因爲只有當我們能夠區分映射的結果的不同的時候
         這種映射作爲等詞才有意義
         然而 爲了區分映射結果的不同
         我們又需要一個等詞
         這樣就循環了
      6. 事實是
         我選取了這個基本的等詞爲公理性的東西
      7. 而一種重要的認識就在於
         對公理的選擇是任意的
         我完全可以選擇一個三元集合爲公理性的東西
         我也可以選擇有向圖爲公理性的東西
         我也可以選擇三維流行爲公理新的東西
*** guarded-command programs
    * 用對全局[局部]變量的謂詞
      把一段程序夾起來
      在函數編程範式下
      兩個謂詞就是對程序的參數和返回值的類型說明
* ===================================
