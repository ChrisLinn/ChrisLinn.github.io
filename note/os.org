#+title: os

* (2010) (michael kerrisk) the linux programming interface

*** background and concepts

***** 1: history and standards

      - unlike most commercial unix implementations,
        linux separates implementation from distribution.
        - x - one more level of market.

***** 2: fundamental concepts

***** 3: system programming concepts

      - system calls and c library.

      - whenever we make a system call or call a library function,
        we should always check the return status of the call
        in order to determine if it was successful.

*** fundamental features of the system programming interface

***** 4: file i/o: the universal i/o model

******* intro

        - all system calls for performing i/o
          refer to open files using a file descriptor,
          a (usually small) nonnegative integer.

          universal i/o model means
          to view everything as file
          - regular-file
          - terminal
          - socket
          - fifo
          - pipe
          - device

          each process has its own set of file descriptors.

******* note everything as file

        - x -
          'everything as file' is like
          to optimize the the syntax[the language] of API of devices
          for file storage device.

******* open

        #+begin_src c
        #include <sys/stat.h>
        #include <fcntl.h>
        int open(const char *pathname, int flags);
        int open(const char *pathname, int flags, mode_t mode);
        // Returns file descriptor on success, or –1 on error
        #+end_src

******* read

        #+begin_src c
        #include <unistd.h>
        ssize_t read(int fd, void *buffer, size_t count);
        // Returns number of bytes read, 0 on EOF, or –1 on error
        #+end_src

******* write

        #+begin_src c
        #include <unistd.h>
        ssize_t write(int fd, void *buffer, size_t count);
        // Returns number of bytes written, or –1 on error
        #+end_src

******* close

        #+begin_src c
        #include <unistd.h>
        int close(int fd);
        // Returns 0 on success, or –1 on error
        #+end_src

******* lseek

        #+begin_src c
        #include <unistd.h>
        off_t lseek(int fd, off_t offset, int whence);
        // Returns new file offset if successful, or –1 on error
        #+end_src

******* ioctl -- for operations outside the universal i/o model

        #+begin_src c
        #include <sys/ioctl.h>
        int ioctl(int fd, int request, ... /* argp */);
        // Value returned on success depends on request, or –1 on error
        #+end_src

***** 5: file i/o: further details

******* atomicity and race conditions

        - all system calls are executed atomically.
          all of the steps in a system call
          are completed as a single operation,
          without being interrupted by another process or thread.

        - race conditions [race hazards]
          is a situation where
          the result produced by two processes (or threads)
          operating on shared resources
          depends, in an unexpected way,
          on the relative order
          in which the processes gain access to the CPU(s).

        - O_CREAT and O_EXCL flags should be used for open(),
          if the function needs to know the file is created by itself.
          [exclusive-create]

        - O_APPEND flag should be used for open(),
          to let the seek to the end of the file
          and the write operation happen atomically.

******* fcntl -- control operations on an open file descriptor

        #+begin_src c
        #include <fcntl.h>
        int fcntl(int fd, int cmd, ...);
        // Return on success depends on cmd, or –1 on error
        #+end_src

******* file flag

        #+begin_src c
        int flags, accessMode;

        flags = fcntl(fd, F_GETFL); /* Third argument is not required */
        if (flags == -1)
          errExit("fcntl");

        if (flags & O_SYNC)
          printf("writes are synchronized\n");

        // need mask O_ACCMODE to check
        // O_RDONLY (0)
        // O_WRONLY (1)
        // O_RDWR (2)
        accessMode = flags & O_ACCMODE;
        if (accessMode == O_WRONLY || accessMode == O_RDWR)
          printf("file is writable\n");

        // use fcntl() F_SETFL command
        // to modify O_APPEND O_NONBLOCK O_NOATIME O_ASYNC O_DIRECT

        int flags;
        flags = fcntl(fd, F_GETFL);
        if (flags == -1)
          errExit("fcntl");
        flags |= O_APPEND;
        if (fcntl(fd, F_SETFL, flags) == -1)
          errExit("fcntl");
        #+end_src

******* file descriptors and open files

        - ><

***** 6: processes
***** 7: memory allocation
***** 8: users and groups
***** 9: process credentials
***** 10: time
***** 11: system limits and options
***** 12: system and process information

*** more advanced features of the system programming interface

***** 13: file i/o buffering
***** 14: file systems
***** 15: file attributes
***** 16: extended attributes
***** 17: access control lists
***** 18: directories and links
***** 19: monitoring file events
***** 20: signals: fundamental concepts
***** 21: signals: signal handlers
***** 22: signals: advanced features
***** 23: timers and sleeping

*** processes, programs, and threads

***** 24: process creation
***** 25: process termination
***** 26: monitoring child processes
***** 27: program execution
***** 28: process creation and program execution in more detail
***** 29: threads: introduction
***** 30: threads: thread synchronization
***** 31: threads: thread safety and per-thread storage
***** 32: threads: thread cancellation
***** 33: threads: further details

*** advanced process and program topics

***** 34: process groups, sessions, and job control
***** 35: process priorities and scheduling
***** 36: process resources
***** 37: daemons
***** 38: writing secure privileged programs
***** 39: capabilities
***** 40: login accounting
***** 41: fundamentals of shared libraries
***** 42: advanced features of shared libraries

*** interprocess communication (ipc)

***** 43: interprocess communication overview
***** 44: pipes and fifos
***** 45: introduction to system v ipc
***** 46: system v message queues
***** 47: system v semaphores
***** 48: system v shared memory
***** 49: memory mappings
***** 50: virtual memory operations
***** 51: introduction to posix ipc
***** 52: posix message queues
***** 53: posix semaphores
***** 54: posix shared memory
***** 55: file locking

*** sockets and network programming

***** 56: sockets: introduction

******* overview

        - client and server

          - each application creates a socket.
            A socket is the thing” that allows communication,
            and both client and server require one.

          - the server binds its socket to a well-known address (name)
            so that clients can locate it.

        - A socket is created using the socket() system call,
          fd = socket(domain, type, protocol);

        - in the internet domain :

          | internet domain stream socket   | SOCK_STREAM |
          | Transmission Control Protocol   | TCP         |
          |---------------------------------+-------------|
          | internet domain datagram socket | SOCK_DGRAM  |
          | User Datagram Protocol          | UDP         |

        - socket system calls :
          #include <sys/socket.h>

******* socket

        - int socket(int domain, int type, int protocol);
          Returns file descriptor on success, or –1 on error.

          creates a new socket.

          domain := AF_UNIX | AF_INET | AF_INET6
          type := SOCK_STREAM | SOCK_DGRAM
          protocol := 0 [for now]

          for example,
          protocol = IPPROTO_RAW for raw sockets (SOCK_RAW)
          but protocol = 0 for now

******* bind

        - int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

          Returns 0 on success, or –1 on error

          binds a socket to an address.
          usually, a server employs this call
          to bind its socket to a well-known address
          so that clients can locate the socket.

        - struct sockaddr
          #+begin_src c
          struct sockaddr {
            // Address family (AF_* constant)
            sa_family_t sa_family;

            // Socket address
            // (size varies according to socket domain)
            char sa_data[14];
          };
          #+end_src

        - UNIX domain sockets use pathnames.
        - Internet domain sockets use IP address + port number.

******* stream sockets

********* phone analog of stream sockets

          | socket(domain, type, protocol); | setup phone        |
          | bind(sockfd, addr, addrlen);    | to have a number   |
          | listen(sockfd, backlog);        | ready to be called |
          |---------------------------------+--------------------|
          | connect(sockfd, addr, addrlen); | dialing number     |
          | accept(sockfd, addr, addrlen);  | pick up the phone  |

          server : socket -- bind -- listen -- accept -- (send and recv) -- close
          client : socket -- connect -- (send and recv) -- close

********* listen

          - int listen(int sockfd, int backlog);

            Returns 0 on success, or –1 on error

            allows a stream socket to accept
            incoming connections from other sockets.

********* accept

          - int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

            Returns file descriptor on success, or –1 on error

            accepts a connection from a peer application
            on a listening stream socket,
            and optionally returns the address of the peer socket.

            If there are no pending connections when accept() is called,
            the call blocks until a connection request arrives.

            accept(sockfd, addr, addrlen) creates a new socket,
            and it is this new socket
            that is connected to the peer socket
            that performed the connect(sockfd, addr, addrlen).

            the listening socket remains open,
            and can be used to accept further connections.
            [phone analog breaks]

            accept(sockfd, addr, addrlen);
            set the addr to the addr of the peer socket.

********* connect()

          - int connect(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

            Returns 0 on success, or –1 on error

            establishes a connection with another socket.

            If connect() fails and we wish to reattempt the connection,
            then SUSv3 specifies that
            the portable method of doing so
            is to close the socket,
            create a new socket,
            and reattempt the connection with the new socket.

******* datagram sockets

********* postal analog of datagram sockets

          server : socket -- bind -- (sendto and recvfrom) -- close
          client : socket -- (sendto and recvfrom) -- close

********* recvfrom and sendto

          - ssize_t recvfrom(
            int sockfd,
            void *buffer,
            size_t length,
            int flags,
            struct sockaddr *src_addr,
            socklen_t *addrlen);

            Returns number of bytes received, 0 on EOF, or –1 on error

          - ssize_t sendto(
            int sockfd,
            const void *buffer,
            size_t length,
            int flags,
            const struct sockaddr *dest_addr,
            socklen_t addrlen );

            Returns number of bytes sent, or –1 on error

***** 57: sockets: unix domain
***** 58: sockets: fundamentals of tcp/ip networks
***** 59: sockets: internet domains

******* 59.15 further information

***** 60: sockets: server design
***** 61: sockets: advanced topics

*** advanced i/o topics

***** 62: terminals
***** 63: alternative i/o models
***** 64: pseudoterminals

*** appendix

***** a: tracing system calls
***** b: parsing command-line options
***** c: casting the null pointer
***** d: kernel configuration
***** e: further sources of information
***** f: solutions to selected exercises

* (2015) the design and implementation of the freebsd operating system

*** intro

    - (1993)
      The NetBSD group emphasized portability and the minimalist approach,
      porting the systems to nearly 60 platforms and they were determined to keep the system lean
      to aid embedded applications.

      The FreeBSD group emphasized maximal support for the PC architecture
      and pushed to ease installation for, and market their system to, as wide an audience as possible.

    - (1995)
      the OpenBSD group split from the NetBSD group
      to develop a distribution that emphasized security.

    - (2003)
      the Dragonfly group split from the FreeBSD group
      to develop a distribution that used a significantly lighter-weight mechanism to support multiprocessing.

    - The licensing terms of FreeBSD do not require the distribution of changes
      and enhancements to the system.

      The licensing terms of Linux require that
      all changes and enhancements to the kernel be made available in source form at minimal cost.
      Thus, companies that need to control the distribution of their intellectual property
      build their products using FreeBSD.

    - Because of the intense peer review
      and insistence on well-defined coding standards throughout its 35-year lifetime,
      the FreeBSD kernel is considerably cleaner, more modular,
      and thus easier to understand and modify
      than most software projects of its size and age.
      Sample course material is available at www.teachbsd.com.
