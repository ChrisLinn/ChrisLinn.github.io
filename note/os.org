#+title: os

* (2010) (michael kerrisk) the linux programming interface

*** background and concepts

***** 1: history and standards

      - unlike most commercial unix implementations,
        linux separates implementation from distribution.
        - x - one more level of market.

***** 2: fundamental concepts

***** 3: system programming concepts

      - system calls and c library.

      - Whenever we make a system call or call a library function,
        we should always check the return status of the call
        in order to determine if it was successful.

*** fundamental features of the system programming interface

***** 4: file i/o: the universal i/o model

******* intro

        - all system calls for performing i/o
          refer to open files using a file descriptor,
          a (usually small) nonnegative integer.

          file descriptors are used to refer to all types of open files,
          including pipes, fifos, sockets, terminals, devices, and regular files.

          each process has its own set of file descriptors.

******* universality of i/o

********* opening a file: open()

          - ><

***** 5: file i/o: further details

***** 6: processes
***** 7: memory allocation
***** 8: users and groups
***** 9: process credentials
***** 10: time
***** 11: system limits and options
***** 12: system and process information

*** more advanced features of the system programming interface

***** 13: file i/o buffering
***** 14: file systems
***** 15: file attributes
***** 16: extended attributes
***** 17: access control lists
***** 18: directories and links
***** 19: monitoring file events
***** 20: signals: fundamental concepts
***** 21: signals: signal handlers
***** 22: signals: advanced features
***** 23: timers and sleeping

*** processes, programs, and threads

***** 24: process creation
***** 25: process termination
***** 26: monitoring child processes
***** 27: program execution
***** 28: process creation and program execution in more detail
***** 29: threads: introduction
***** 30: threads: thread synchronization
***** 31: threads: thread safety and per-thread storage
***** 32: threads: thread cancellation
***** 33: threads: further details

*** advanced process and program topics

***** 34: process groups, sessions, and job control
***** 35: process priorities and scheduling
***** 36: process resources
***** 37: daemons
***** 38: writing secure privileged programs
***** 39: capabilities
***** 40: login accounting
***** 41: fundamentals of shared libraries
***** 42: advanced features of shared libraries

*** interprocess communication (ipc)

***** 43: interprocess communication overview
***** 44: pipes and fifos
***** 45: introduction to system v ipc
***** 46: system v message queues
***** 47: system v semaphores
***** 48: system v shared memory
***** 49: memory mappings
***** 50: virtual memory operations
***** 51: introduction to posix ipc
***** 52: posix message queues
***** 53: posix semaphores
***** 54: posix shared memory
***** 55: file locking

*** sockets and network programming

***** 56: sockets: introduction

******* overview

        - client and server

          - each application creates a socket.
            A socket is the thing” that allows communication,
            and both client and server require one.

          - the server binds its socket to a well-known address (name)
            so that clients can locate it.

        - A socket is created using the socket() system call,
          fd = socket(domain, type, protocol);

        - in the internet domain :

          | internet domain stream socket   | SOCK_STREAM |
          | Transmission Control Protocol   | TCP         |
          |---------------------------------+-------------|
          | internet domain datagram socket | SOCK_DGRAM  |
          | User Datagram Protocol          | UDP         |

        - socket system calls :
          #include <sys/socket.h>

******* socket

        - int socket(int domain, int type, int protocol);
          Returns file descriptor on success, or –1 on error.

          creates a new socket.

          domain := AF_UNIX | AF_INET | AF_INET6
          type := SOCK_STREAM | SOCK_DGRAM
          protocol := 0 [for now]

          for example,
          protocol = IPPROTO_RAW for raw sockets (SOCK_RAW)
          but protocol = 0 for now

******* bind

        - int bind(int sockfd, const struct sockaddr *addr, socklen_t addrlen);

          Returns 0 on success, or –1 on error

          binds a socket to an address.
          usually, a server employs this call
          to bind its socket to a well-known address
          so that clients can locate the socket.

        - struct sockaddr
          #+begin_src c
          struct sockaddr {
            // Address family (AF_* constant)
            sa_family_t sa_family;

            // Socket address
            // (size varies according to socket domain)
            char sa_data[14];
          };
          #+end_src

        - UNIX domain sockets use pathnames.
        - Internet domain sockets use IP address + port number.

******* stream sockets

********* phone analog of stream sockets

          | socket(domain, type, protocol); | setup phone        |
          | bind(sockfd, addr, addrlen);    | to have a number   |
          | listen(sockfd, backlog);        | ready to be called |
          |---------------------------------+--------------------|
          | connect(sockfd, addr, addrlen); | dialing number     |
          | accept(sockfd, addr, addrlen);  | pick up the phone  |

          server : socket -- bind -- listen -- accept -- (send and recv) -- close
          client : socket -- connect -- (send and recv) -- close

********* listen

          - int listen(int sockfd, int backlog);

            Returns 0 on success, or –1 on error

            allows a stream socket to accept
            incoming connections from other sockets.

********* accept

          - int accept(int sockfd, struct sockaddr *addr, socklen_t *addrlen);

            Returns file descriptor on success, or –1 on error

            accepts a connection from a peer application
            on a listening stream socket,
            and optionally returns the address of the peer socket.

            If there are no pending connections when accept() is called,
            the call blocks until a connection request arrives.

            accept(sockfd, addr, addrlen) creates a new socket,
            and it is this new socket
            that is connected to the peer socket
            that performed the connect(sockfd, addr, addrlen).

            the listening socket remains open,
            and can be used to accept further connections.
            [phone analog breaks]

            accept(sockfd, addr, addrlen);
            set the addr to the addr of the peer socket.

          - connect()
            establishes a connection with another socket.

******* datagram sockets

        - ><

***** 57: sockets: unix domain
***** 58: sockets: fundamentals of tcp/ip networks
***** 59: sockets: internet domains

******* 59.15 further information

***** 60: sockets: server design
***** 61: sockets: advanced topics

*** advanced i/o topics

***** 62: terminals
***** 63: alternative i/o models
***** 64: pseudoterminals

*** appendix

***** a: tracing system calls
***** b: parsing command-line options
***** c: casting the null pointer
***** d: kernel configuration
***** e: further sources of information
***** f: solutions to selected exercises

* (2015) the design and implementation of the freebsd operating system

*** intro

    - (1993)
      The NetBSD group emphasized portability and the minimalist approach,
      porting the systems to nearly 60 platforms and they were determined to keep the system lean
      to aid embedded applications.

      The FreeBSD group emphasized maximal support for the PC architecture
      and pushed to ease installation for, and market their system to, as wide an audience as possible.

    - (1995)
      the OpenBSD group split from the NetBSD group
      to develop a distribution that emphasized security.

    - (2003)
      the Dragonfly group split from the FreeBSD group
      to develop a distribution that used a significantly lighter-weight mechanism to support multiprocessing.

    - The licensing terms of FreeBSD do not require the distribution of changes
      and enhancements to the system.

      The licensing terms of Linux require that
      all changes and enhancements to the kernel be made available in source form at minimal cost.
      Thus, companies that need to control the distribution of their intellectual property
      build their products using FreeBSD.

    - Because of the intense peer review
      and insistence on well-defined coding standards throughout its 35-year lifetime,
      the FreeBSD kernel is considerably cleaner, more modular,
      and thus easier to understand and modify
      than most software projects of its size and age.
      Sample course material is available at www.teachbsd.com.
