#+title: category theory for programmers

- by Bartosz Milewski

* video

*** 1.2: What is a category?

    - three concepts

      | abstraction | type-class |
      | composition | function   |
      | identity    | quotient   |

    - category theory is about composition and identity

    - two concepts

      | object              |
      | arrow [or morphism] |

      the reason for having object is so you can type arrows

    - objects do not serve any propose other than identifying ends of arrows

    - from category theory's view
      object has no structure

      we have Set, Group, VectorSpace, ...
      to define them in the language of category theory
      we must not reach for the concrete structure of their objects

      we must define them by
      describing the relations between their objects

      and the relations we can describe
      are all equations about arrows

      [describe properties only by interface functions]

    - equality between arrows:
      what are equality introductions ?
      equations (axioms) of specific category are equality introductions.

*** [note] mathematical model of type system

    - what should we use to model type system ?
      set theory or category theory ?

    - if we use category theory,
      how to model `list_t(t: type)` ?
      and dependent type `vect_t(t: type, length: nat_t)` ?

*** 2.1: Functions, epimorphisms

    - a function is pure if you can
      memorize it and turning it into a lookup table.

    - the basic building blocks of programming
      are types and functions
      they form a category

    - take example properties from set theory
      and limit the language to arrow equations
      to translate such properties to category theory

*** [note] properties in category theory

    - category theory 中所定義的 property
      是沒法被寫成謂詞
      用來判斷這個 property 是否成立的

      這些 property 是在 implement 時被保證的
      而不是需要被判斷的

*** 2.2: Monomorphisms, simple types

*** 3.1: Examples of categories, orders, monoids

    - in preorder as category, an arrow is not a function, but a relation.

    - preorder is thin category, homset have 0 or 1 elements.

      we can view category as generalized preorder,
      in which homset can have more elements.

      like we can have different proofs of the relation `<=`.

    - monoid is like pre-group.

    - monoid is category with only one object,
      thus every two arrows are composable.

      we can view category as generalized monoid,
      in which there can be more objects.

    - we can view preorder as category,
      or monoid as category.

      we can also view category as generalization of preorder,
      or generalization of monoid.

*** 3.2: Kleisli category

    - objects of a cat can be types
      while arrows between a, b
      can not only be functions of type (a -> b)
      but also be functions of type (a -> (b, String))
      where String can be replaced by any Monoid
      and function composition is redefined

*** 4.1: Terminal and initial objects

    - universal construction

*** 4.2: Products
*** 5.1: Coproducts, sum types
*** 5.2: Algebraic data types
*** 6.1: Functors
*** 6.2: Functors in programming
*** 7.1: Functoriality, bifunctors
*** 7.2: Monoidal Categories, Functoriality of ADTs, Profunctors
*** 8.1: Function objects, exponentials
*** 8.2: Type algebra, Curry-Howard-Lambek isomorphism
*** 9.1: Natural transformations
*** 9.2: bicategories
*** 10.1: Monads
*** 10.2: Monoid in the category of endofunctors

    - a monad is just a monoid-object in the monoidal-category of endofunctors,
      where in the monoidal-category tensor-product is functor composition,
      thus a special endofunctor, with two morphisms `join` and `pure`.

*** II 1.1: Declarative vs Imperative Approach
*** II 1.2: Limits
*** II 2.1: Limits, Higher order functors
*** II 2.2: Limits, Naturality
*** II 3.1: Examples of Limits and Colimits
*** II 3.2: Free Monoids
*** II 4.1: Representable Functors

    - ><

      #+begin_src cicada
      category_t (t arrow_t arrow_eqv_t)
      set_t : (type) -> type
      hom_set : ([a b] : t) -> set_t (arrow_t (a b))
      (x : t) -> hom_set (a x)
      #+end_src

*** II 4.2: The Yoneda Lemma
*** II 5.1: Yoneda Embedding
*** II 5.2: Adjunctions
*** II 6.1: Examples of Adjunctions
*** II 6.2: Free-Forgetful Adjunction, Monads from Adjunctions
*** II 7.1: Comonads
*** II 7.2: Comonads Categorically and Examples
*** II 8.1: F-Algebras, Lambek's lemma
*** II 8.2: Catamorphisms and Anamorphisms
*** II 9.1: Lenses
*** II 9.2: Lenses categorically

* book

*** 1 Category: The Essence of Composition

    - category is about object and arrow and composition of arrows,
      think of them as type and function and composition of functions.

    - in haskell:
      #+begin_src haskell
      f :: A -> B
      g :: B -> C
      g . f :: A -> C
      #+end_src

    - in scala:
      #+begin_src scala
      f: A => B
      g: B => C
      g after f: A => C
      // we might wish to use infix notation here,
      // because composition is associative.
      #+end_src

*** 2 Types and Functions

***** 2.3 What Are Types?

      - we can make use of the set theoretical interpretation of type.
        but the problem is polymorphic functions that involve circular definitions.

      - x -
        what is the problem ?
        list: List[T]
        f: List[T] => List[T]

        they seems ok to be interpreted as set.

        even viewing a relation (or function) as a subset of product
        is useful in relational database

*** 3 Categories Great and Small

    - free category generated by a given graph.
      It's an example of a free construction,
      a process of completing a given structure
      by extending it with a minimum number of items
      to satisfy its laws (here, the laws of a category).
