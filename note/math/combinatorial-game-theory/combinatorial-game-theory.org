#+title: combinatorial game theory

* Chapter I. Combinatorial Games

*** intro

    - characteristic
      - two-player
      - no hidden information
      - no chance elements

    - objectives
      - exact solutions to particular games
        usually in the form of an algebraic description of their outcomes
      - an understanding of the general combinatorial structure of games
      - hardness results, suggesting that for certain games
        or in certain situations, no concise solution exists

    - outcomes and solutions
      for example nim has two outcome classes -- win and loss
      (a function from a nim game to the set of win and loss)
      - first player has winning strategy
      - second player has winning strategy

      to solve a combinatorial game
      is to find a function to calculate the game's general outcome

      it is often simple to get a winning strategy from such function

    - normal play is additive
      misere play is not additive

    - partizan games with normal play (like hackenbush) have more outcome
      - first player has winning strategy
      - second player has winning strategy
      - left has winning strategy
      - right has winning strategy

      the game can bias one player

    - game, position, option
      - the author uses "ruleset, game, option"
        which is unnecessary term juggling

      game-t
      state-t

      direct-option
      indirect-option

      subposition
      proper-subposition

      run
      play

    - disjunctive sum

    - the fundamental equivalence

    - x -
      就 short, normal play 而言
      在 disjunctive sum 下 game 构成 abelian group

      可以想象到的 value of game 有五种
      利用归纳法可以证明其中没有制胜策略的情况不会出现

      surreal number 作为 value of game
      是用最优 move 对 game tree 的进行的总结

      注意 surreal number 中
      同时包含了 left 先手 和 right 先手 的情况

* [note] formalization

*** game-t

    #+begin_src cicada
    game-t = conj {
      position-t : type
      choice-t : type
      init-position : position-t
      left-choices  : (position-t) -> list-t (choice-t)
      right-choices : (position-t) -> list-t (choice-t)
      left-move  : (choice-t, position-t) -> position-t
      right-move : (choice-t, position-t) -> position-t
    }
    #+end_src

*** game-t.sum

    #+begin_src cicada
    game-t
    .sum : (game-t) -> game-t
    .sum = (that) => {
      game-c {
        position-t = [this.position-t, that.position-t]
        choice-t = either-t (this.choice-t, that.choice-t)
        init-position = [this.init-position, that.init-position]
        left-choices = (position) => list-append (
          left-t (this.left-choices (position.0))
          right-t (that.left-choices (position.1)))
        right-choices = (position) => list-append (
          left-t (this.right-choices (position.0))
          right-t (that.right-choices (position.1)))
        left-move = (choice, position) => case choice {
          left-t -- [
            this.left-move (choice.value, position.0)
            position.1
          ]
          right-t -- [
            position.0
            that.left-move (choice.value, position.1)
          ]
        }
        right-move = (choice, position) => case choice {
          left-t -- [
            this.right-move (choice.value, position.0)
            position.1
          ]
          right-t -- [
            position.0
            that.right-move (choice.value, position.1)
          ]
        }
      }
    }
    #+end_src

* Chapter II. Short Games

* Chapter III. The Structure of G

* Chapter IV. Impartial Games

* Chapter V. Misere Play

* Chapter VI. Loopy Games

* Chapter VII. Temperature Theory

* Chapter VIII. Transfinite Games
