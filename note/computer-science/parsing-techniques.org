#+title: parsing techniques

- A Practical Guide
  - Second Edition

* links

  https://en.wikipedia.org/wiki/L-system

  http://algorithmicbotany.org/papers/

* [note]

*** goal

    - x -
      our goal of this reading
      is to learn about the classification of parsing algorithms.
      we will still write parser by hand (not generate them from grammar)
      but we will use a fromal language to document the grammar
      and to guide the design of our parsing program.

* intro

  - parsing is the process of structuring a linear representation
    in accordance with a given grammar.

    - x -
      the above statement seems is the reverse of the action of a parser.
      because a parser construct AST from linear representation.
      but actually, if given grammar,
      we can generate the linear pattern
      and match it against the concrete linear representation,
      then we can get the AST,
      because the grammar is the type of a AST node,
      and the matched pattern give us the body of the node.

  - The reverse problem -- given a (large) set of sentences,
    find the/a grammar which produces them
    -- is called grammatical inference.

    - https://en.wikipedia.org/wiki/Grammar_induction

    - x -
      this seems is the true art.

* grammars as a generating device

*** intro

    - "grammar describe language"

    - "language" -
      to a formal-linguist,
      "language" does not have the usual meaning of the word "language",
      but instead means a set of sentences.
      which means given a sentence, we can decide
      whether it is in the set -- the language.

    - "grammar describe" -
      grammar rules enumerate all sentences of a language,
      i.e. generative grammar.
      - x - it is  constructive!

*** can all languages be described by finite descriptions ?

    - The dis-proof of
      > Can all languages be described by finite descriptions ?
      by diagonalization, is wrong.

    - For descriptions can not be Enumerated,
      because for a specific description,
      there alreay are infinitely many ways to interpret
      how the specific description describe a language.

*** 2.1.4 Describing a Language through a Finite Recipe

    #+begin_src cicada
    example-sentences {
      tom
      tom and dick
      tom, dick and harry
    }

    formal-grammar {
      Name -> tom
      Name -> dick
      Name -> harry

      Sentence -> Name
      Sentence -> List End

      List -> Name
      List -> Name, List

      , Name End -> and Name

      :-> Sentence
    }
    #+end_src

*** 2.2.2 Generating Sentences from a Formal Grammar

    #+begin_src cicada
    formal-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List End
      List -> Name | Name, List
      , Name End -> and Name
    }

    production-process {
      Sentence
      -- Sentence -> List End
      List End
      -- List -> Name, List
      Name, List End
      -- List -> Name, List
      Name, Name, List End
      -- List -> Name
      Name, Name, Name End
      -- , Name End -> and Name
      Name, Name and Name
      -- Name -> tom
      -- Name -> dick
      -- Name -> harry
      tom, dick and harry
    }
    #+end_src

*** 2.2.3 The Expressive Power of Formal Grammars

    - any set that can be generated by a program
      can be generated by a phrase structure grammar.

    #+begin_src cicada
    formal-grammar = {
      ;; circle-movements-for-manhattan-turtle
      Moves -> north Move south | east Move west | Îµ
      ;; the following are just
      ;;   swapping pathes generated by the above rule
      north east -> east north
      north south -> south north
      north west -> west north
      east north -> north east
      east south -> south east
      east west -> west east
      south north -> north south
      south east -> east south
      south west -> west south
      west north -> north west
      west east -> east west
      west south -> south west
    }
    #+end_src

*** 2.3 The Chomsky Hierarchy of Grammars and Languages

    - restrictions over formal-grammar, for simpler parsing algorithm.
      type-0 type-1 type-2 type-3

    - type-0 is unrestricted formal-grammar.
      no general parsing algorithm for them can exist,
      and all known special parsing algorithms
      are either very inefficient or very complex.

*** 2.3.1 Type 1 Grammars

    - A grammar is Type 1 monotonic
      if it contains no rules in which
      the left-hand side consists of more symbols
      than the right-hand side.

      This forbids, for example, the rule
      -- , N E -> and N

    - A grammar is Type 1 context-sensitive
      if all of its rules are context-sensitive.

      A rule is context-sensitive
      if actually only one (non-terminal) symbol in its left-hand side
      gets replaced by other symbols,
      while we find the others back,
      undamaged and in the same order,
      in the right-hand side.

      Example:
      -- Name Comma Name End -> Name and Name End
      which tells that the rule `-- Comma -> and` may be applied
      if the left context is `Name` and the right context is `Name End`.
      The contexts themselves are not affected.

    #+begin_src cicada
    type-0-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List End
      List -> Name | Name, List
      , Name End -> and Name
    }

    type-1-monotonic-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List
      List -> EndName | Name, List
      , EndName -> and Name
    }

    type-1-context-sensitive-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List
      List -> EndName | Name Comma List
      Comma EndName -> and EndName
      and EndName -> and Name
      Comma -> ,
    }
    #+end_src
