#+title: parsing techniques

- parsing techniques -- A Practical Guide
  -- Second Edition

* links

  https://en.wikipedia.org/wiki/L-system

  http://algorithmicbotany.org/papers/

* [note]

*** goal

    - x -
      our goal of this reading
      is to learn about the classification of parsing algorithms.
      we will still write parser by hand (not generate them from grammar)
      but we will use a fromal language to document the grammar
      and to guide the design of our parsing program.

* 1 intro

  - parsing is the process of structuring a linear representation
    in accordance with a given grammar.

    - x -
      the above statement seems is the reverse of the action of a parser.
      because a parser construct AST from linear representation.
      but actually, if given grammar,
      we can generate the linear pattern
      and match it against the concrete linear representation,
      then we can get the AST,
      because the grammar is the type of a AST node,
      and the matched pattern give us the body of the node.

  - The reverse problem -- given a (large) set of sentences,
    find the/a grammar which produces them
    -- is called grammatical inference.

    - https://en.wikipedia.org/wiki/Grammar_induction

    - x -
      this seems is the true art.

* 2 grammars as a generating device

*** grammar describe language

    - language -- set of sentences
      describe -- constructive generating
      grammar -- generative grammar

*** can all languages be described by finite descriptions ?

    - The dis-proof of
      > Can all languages be described by finite descriptions ?
      by diagonalization, is wrong.

    - For descriptions can not be Enumerated,
      because for a specific description,
      there alreay are infinitely many ways to interpret
      how the specific description describe a language.

*** 2.1.4 Describing a Language through a Finite Recipe

    #+begin_src cicada
    example-sentences {
      tom
      tom and dick
      tom, dick and harry
    }

    formal-grammar {
      Name -> tom
      Name -> dick
      Name -> harry

      Sentence -> Name
      Sentence -> List End

      List -> Name
      List -> Name, List

      , Name End -> and Name

      :-> Sentence
    }
    #+end_src

*** 2.2.1 The Formalism of Formal Grammars

    - symbols
      - non-terminal symbols
      - terminal symbols

      two type of symbols must be mutual exclusive

    - rules
      a rule can rewrite symbol-pattern to symbol-pattern
      where left-hand side must be non-empty
      which right-hand side might be empty

    - a non-terminal symbol as starting-symbol

      from the starting-symbol,
      we generate symbol-patterns by rules.

      the result can be viewed as a sentence in the language,
      if it contains only terminal symbols

*** 2.2.2 Generating Sentences from a Formal Grammar

    - this kinds of formal-grammar
      is called phrase structure grammar [PS].

    #+begin_src cicada
    formal-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List End
      List -> Name | Name, List
      , Name End -> and Name
    }

    production-process {
      Sentence
      List End
      Name, List End
      Name, Name, List End
      Name, Name, Name End
      Name, Name and Name
      tom, dick and harry
    }
    #+end_src

*** 2.2.3 The Expressive Power of Formal Grammars

    - any set that can be generated by a program
      can be generated by a phrase structure grammar.

    #+begin_src cicada
    formal-grammar = {
      // circle-movements-for-manhattan-turtle
      Moves -> north Move south | east Move west | Îµ
      // the following are just
      //   swapping pathes generated by the above rule
      north east -> east north
      north south -> south north
      north west -> west north
      east north -> north east
      east south -> south east
      east west -> west east
      south north -> north south
      south east -> east south
      south west -> west south
      west north -> north west
      west east -> east west
      west south -> south west
    }
    #+end_src

*** 2.3 The Chomsky Hierarchy of Grammars and Languages

    - restrictions over formal-grammar, for simpler parsing algorithm.
      type-0 type-1 type-2 type-3

    - type-0 is unrestricted formal-grammar.
      no general parsing algorithm for them can exist,
      and all known special parsing algorithms
      are either very inefficient or very complex.

*** 2.3.1 Type 1 Grammars

    - A grammar is Type 1 monotonic
      if it contains no rules in which
      the left-hand side consists of more symbols
      than the right-hand side.

      This forbids, for example, the rule
      -- , N E -> and N

    - A grammar is Type 1 context-sensitive [CS]
      if all of its rules are context-sensitive.

      A rule is context-sensitive
      if actually only one (non-terminal) symbol in its left-hand side
      gets replaced by other symbols,
      while we find the others back,
      undamaged and in the same order,
      in the right-hand side.

      Example:
      -- Name Comma Name End -> Name and Name End
      which tells that the rule `-- Comma -> and` may be applied
      if the left context is `Name` and the right context is `Name End`.
      The contexts themselves are not affected.

    #+begin_src cicada
    type-0-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List End
      List -> Name | Name, List
      , Name End -> and Name
    }

    type-1-monotonic-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List
      List -> EndName | Name, List
      , EndName -> and Name
    }

    type-1-context-sensitive-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List
      List -> EndName | Name Comma List
      Comma EndName -> and EndName
      and EndName -> and Name
      Comma -> ,
    }
    #+end_src

*** 2.3.1.2 Constructing a Type 1 Grammar

    - The standard example of a Type 1 language
      is the set of words that consist of
      equal numbers of as, bs and cs, in that order:
      [a a a b b b c c c]

    #+begin_src cicada
    type-1-monotonic-grammar {
      S -> a b c | a S Q
      b Q c -> b b c c
      c Q -> Q c
    }

    production-process {
      S
      a S Q
      a a S Q Q
      a a a b c Q Q
      a a a b Q c Q
      a a a b b c c Q
      a a a b b Q c c
      a a a b b b c c c
    }
    #+end_src

*** 2.3.2 Type 2 Grammars

    - A context-free grammar [CF] is like a context-sensitive grammar,
      except that both the left and the right contexts
      are required to be absent (empty).

      As a result, the grammar may contain only rules that
      have a single non-terminal on their left-hand side.

    #+begin_src cicada
    type-1-context-sensitive-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List
      List -> EndName | Name Comma List
      Comma EndName -> and EndName
      and EndName -> and Name
      Comma -> ,
    }

    type-2-context-free-grammar {
      Name -> tom | dick | harry
      Sentence -> Name | List and Name
      List -> Name | Name, List
    }
    #+end_src

*** 2.3.2.1 Production Independence

    - production process is simplified to production tree.

    - we do not need a non-terminal symbol as starting-symbol,
      every non-terminal can be viewed as a set.

    #+begin_src cicada
    production-tree {
      Sentence
      List and Name
      Name, List and Name
      Name, Name and Name
      tom, dick and harry
    }
    #+end_src

*** 2.3.3 Type 3 Grammars

    - Type 2 is for no context
      Type 3 is for no nesting

    - for Type 3 grammars
      a right-hand side may only contain one non-terminal
      and it must come at the end.

      This means that there are only two kinds of rules:
      - a non-terminal produces zero or more terminals
      - a non-terminal produces zero or more terminals
        followed by one non-terminal.

    - The original Chomsky definition of Type 3
      restricts the kinds of rules to
      - a non-terminal produces one terminal
      - a non-terminal produces one terminal
        followed by one non-terminal.

    - Our definition is equivalent and more convenient,
      although the conversion to Chomsky Type 3
      is not completely trivial.

    - Type 3 grammars are also called regular grammars [RE]
      or finite-state grammars [FS]

      - right-regular-grammar -- the default regular-grammar
        the only non-terminal in a rule
        is found at the right end of the right-hand side

      - left-regular-grammar
        the only non-terminal in a rule
        is found at the left end of the right-hand side

    - Since regular grammars are used very often
      to describe the structure of text
      on the character level,
      it is customary for the terminal symbols of a regular grammar
      to be single characters.

    #+begin_src cicada
    regular-grammar {
      Sentences -> t | d | h | List
      List -> t ListTail | d ListTail | h ListTail
      ListTail -> , List | & t | & d | & h
    }

    left-regular-grammar {
      Sentences -> t | d | h | List
      List -> ListHead & t | ListHead & d | ListHead & h
      ListHead -> ListHead , t | ListHead , d | ListHead , h
                | t | d | h
    }

    // a production-tree degenerates into a production-chain

    production-chain {

    }
    #+end_src

*** linear-grammar

    - There is a natural in-between class, Type 2.5 so to speak,
      in which only a single non-terminal
      is allowed in a right-hand side,
      but where it need not be at the end.
      This gives us the so-called linear-grammars.
