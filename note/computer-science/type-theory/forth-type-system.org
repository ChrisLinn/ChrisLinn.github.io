#+title: forth type system

* forth type system

  ctx_lookup(ctx, f) == [A] -> [B]
  ---------------------------------- (variable lookup)
  ctx |- f : [A] -> [B]

  ctx |- f : [A] -> [B, X]
  ctx |- g : [X] -> [C]
  ----------------------------- (cut)
  ctx |- f g : [A] -> [B, C]

  ctx |- f : [A] -> [X]
  ctx |- g : [B, X] -> [C]
  ----------------------------- (cut-deep)
  ctx |- f g : [B, A] -> [C]

  ctx, x: A |- f : [B] -> [C]
  ----------------------------------- (let)
  ctx |- (x: A) f : [B, A] -> [C]

  ctx |- f : [A] -> [B]
  ------------------------------------- (quote)
  ctx |- { f } : [] -> [[A] -> [B]]

* about exe (nullary-apply)

  ctx |- f : [] -> [[A] -> [B]]
  ------------------------------- (exe)
  ctx |- f exe : [A] -> [B]

  ctx |- f : [] -> [[A] -> [B]]
  ------------------------------- (exe by let)
  ctx |- f (x: [A] -> [B]) x : [A] -> [B]

  ------------------------------- (exe alone)
  ctx |- exe : [A, [A] -> [B]] -> [B]

  ------------------------------- (exe alone by let)
  ctx |- (x: [A] -> [B]) x : [A, [A] -> [B]] -> [B]

* type level computation

  ctx_lookup(ctx, f) == { (x: A) B }
  ---------------------------------- (variable lookup)
  ctx |- f : (x: A) B

  ctx |- f : (a: A) B X
  ctx |- g : (x: X) C
  ----------------------------- (cut)
  ctx |- f g : (a: A) B C

  ctx |- f : (a: A) X
  ctx |- g : (x: X) (b: B) C
  ----------------------------- (cut-deep)
  ctx |- f g : (a: A) (b: B) C

  ctx, x: A |- f : (b: B) C
  ----------------------------------- (let)
  ctx |- (x: A) f : (x: A) (b: B) C

  ctx, x: A |- f : C
  ----------------------------------- (let-simple)
  ctx |- (x: A) f : (x: A) C

  ctx |- f : (a: A) B
  ------------------------------------- (quote)
  ctx |- { f } : { (a: A) B }

* disambiguate (x: A)

  `$` reads `match`

  ctx |- f : ($ A) B X
  ctx |- g : ($ X) C
  ----------------------------- (cut)
  ctx |- f g : ($ A) B C

  ctx |- f : ($ A) X
  ctx |- g : ($ X) ($ B) C
  ----------------------------- (cut-deep)
  ctx |- f g : ($ A) ($ B) C

  ctx, x: A |- f : ($ B) C
  ----------------------------------- (let)
  ctx |- (let x: A) f : ($ A) ($ B) C

  ctx, x: A |- f : C
  ----------------------------------- (let-simple)
  ctx |- (let x: A) f : ($ A) C

  so we have (let x: A) : ($ A)

  how about ($ A) : ???

  maybe

  ctx |- A : A2
  ------------------------------
  ctx |- ($ A) : ($ A2)

* [todo] operational semantic of eval

  by using a stack, we have call-by-value operational semantic

  can we also have call-by-name
  and call-by-need operational semantic ?

* [todo] encoding simple type system in forth type system

  encoding application by composition

* [todo] forth type system framework

  like pure type system framework
