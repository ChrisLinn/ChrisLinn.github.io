#+title: forth type system

* forth type system

  ctx_lookup(ctx, f) == [A, ...] -> [B, ...]
  ------------------------------------------- (variable lookup)
  ctx |- f : [A, ...] -> [B, ...]

  ctx |- f : [A, ...] -> [B, ..., C, ...]
  ctx |- g : [C, ...] -> [D, ...]
  ------------------------------------------ (cut)
  ctx |- f g : [A, ...] -> [B, ..., D, ...]

  ctx.ext(x: A, ...) |- f : [B, ...] -> [C, ...]
  -------------------------------------------------------- (let)
  ctx |- (x: A, ...) f : [A, ..., B, ...] -> [C, ...]

  ctx |- f : [A, ...] -> [B, ...]
  ---------------------------------------------------- (quote)
  ctx |- { f } : [] -> [[A, ...] -> [B, ...]]

  ctx |- f : [] -> [[A, ...] -> [B, ...]]
  ------------------------------------------- (exe)
  ctx |- f exe : [A, ...] -> [B, ...]

  problem of the above rule is that
  (x: A, ...) is meaningful even without a `f` after it
  `exe` is meaningful even without a `f` before it

* [todo] specify rules by stack

  problem of specify rules by stack is that
  the operational semantic will be call-by-value

* [todo] encoding simple type system in forth type system

  encoding application by composition

* [todo] forth type system framework

  like pure type system framework
