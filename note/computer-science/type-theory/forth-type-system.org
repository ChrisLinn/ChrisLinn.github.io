#+title: forth type system

* forth type system

  ctx_lookup(ctx, f) == [A] -> [B]
  ---------------------------------- (variable lookup)
  ctx |- f : [A] -> [B]

  ctx |- f : [A] -> [B, X]
  ctx |- g : [X] -> [C]
  ----------------------------- (cut)
  ctx |- f g : [A] -> [B, C]

  ctx |- f : [A] -> [X]
  ctx |- g : [B, X] -> [C]
  ----------------------------- (cut-deep)
  ctx |- f g : [B, A] -> [C]

  ctx.ext(x: A) |- f : [B] -> [C]
  ----------------------------------- (let)
  ctx |- (x: A) f : [A, B] -> [C]

  ctx |- f : [A] -> [B]
  ------------------------------------- (quote)
  ctx |- { f } : [] -> [[A] -> [B]]

  about exe (nullary-apply):

  ctx |- f : [] -> [[A] -> [B]]
  ------------------------------- (exe)
  ctx |- f exe : [A] -> [B]

  ctx |- f : [] -> [[A] -> [B]]
  ------------------------------- (exe by let)
  ctx |- f (x: [A] -> [B]) x : [A] -> [B]

  ------------------------------- (exe alone)
  ctx |- exe : [A, [A] -> [B]] -> [B]

  ------------------------------- (exe alone by let)
  ctx |- (x: [A] -> [B]) x : [A, [A] -> [B]] -> [B]

* [todo] operational semantic of eval

  by using a stack, we have call-by-value operational semantic

  can we also have call-by-name
  and call-by-need operational semantic ?

* [todo] encoding simple type system in forth type system

  encoding application by composition

* [todo] forth type system framework

  like pure type system framework
