#+title: Do-it-yourself Type Theory

- by Roland Backhouse, Paul Chisholm, Erik Saaman and Grant Malcolm, 1988

* 2 Propositions As Types

* 2.1 The Membership Judgement Form

  P type
  p : P
  p == q in P
  P == Q as type

* 2.2 An Example Derivation

  A type
  ------------------
  { x : A -- x : A }

  { x : A -- f(x) : B }
  ------------------------
  (x) => f(x) : A -> B

  a : A
  f : A -> B
  --------------
  f(x) : B

  a : A
  ----------------
  inl(a) : A + B

  b : B
  ----------------
  inr(b) : A + B

  example proof:

  (f) => f(inr((x) => f(inl(x)))) : ((A + ((A) -> B)) -> B) -> B

  example steps:

  #+begin_src js
  { f : (A + ((A) -> B)) -> B
    ----------
    { x : A
      -----------
      inl(x) : A + ((A) -> B)
      f(inl(x)) : B
    }
    (x) => f(inl(x)) : (A) -> B
    inr((x) => f(inl(x))) : A + ((A) -> B)
    f(inr((x) => f(inl(x)))) : B
  }
  (f) => f(inr((x) => f(inl(x)))) : ((A + ((A) -> B)) -> B) -> B
  #+end_src

* 3 The Structure of the Rules

  On first encounter, however, the universal reaction among computing scientists appears to
  be that the theory is formidable. Indeed, several have specifically referred to the overwhelming
  number of rules in the theory. On closer examination, however, the theory betrays a rich structure
  -- a structure that is much deeper than is suggested by the superficial observation that types
  are defined by formation, introduction, elimination and computation rules. Once recognised, this
  structure considerably reduces the burden of understanding. The aim of this section is, therefore,
  to convey that structure to you.
