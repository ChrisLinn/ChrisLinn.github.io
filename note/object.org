#+title: object

* type of type system

  - dynamic v.s. static

  - different subtype semantic

* classify functions according to different information

  - classify functions according to their output arguments

    (: f1 (* -> t1))
    (: f2 (* -> t1))

    in algebraic data structure
    all data-constructors of a type returns this data of this type

  - classify functions according to their input arguments

    (: m1 (c1 -> *))
    (: m2 (c1 -> *))

    when pass a message to an object
    the object is the main input argument
    of the function denoted by the message

  - classify functions according to both their input and output arguments

    for example, type class of haskell

* data-constructors in ocaml

  - ocaml 裏面
    同一個數據構造子
    可以接收各種類型的參數
    接收不同類型的參數的時候 可以返回各種不同類型數據
    並且
    接收相同類型參數而構造出的數據 也可以被認爲是屬於多種類型

* encoding of type and subtype realtion by poset structure of set

  - poset -- partially ordered set

  - encoding type by its data-constructor list
    the more its data-constructors,
    the bigger the type is.

  - encoding type[class] by its interface-function list
    the more its interface-functions,
    the smaller the type[class] is.

  - note that,
    when encoding by data-constructor list or interface-function list,
    we not only need their name,
    but also need their types.

* inheritance in oo

  - (: m1 (c1 -> *))
    (: m2 (c1 -> *))

    (c2 < c1)

    (: m1 (c2 -> *))
    (: m2 (c2 -> *))

    add-method :
    (: m3 (c2 -> *))
    (: m4 (c2 -> *))

* pattern match in functional language

  - pattern match is possible because of :

    1. data-constructor separate the type to disjoint parts
       or say, separate the type into disjoint subtypes
       [this is for totality-check]

    2. data-constructor as function is trivially reversible

* pattern match in oo

  - a class in oo also has constructor
    for example, sending message 'new' to class

    (: new ([* c1-it-self] -> c1))

  - such functions might not be reversible
    thus no pattern match in oo

    even they are reversible
    it will still be hard to do totality-check

    - might be done by explicitly assert subtype relations
      syntaxly, this would hardly be an acceptable solution

* inheritance in functional language

  - can be done, for example, in type class of haskell

    thus, 'classify functions according to their input arguments'
    is not what makes inheritance possible

    what makes it possible
    is encoding class by interface-function list
