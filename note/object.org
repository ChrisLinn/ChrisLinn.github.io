#+title: object

* subtype

*** 對子類型的處理方式 分類靜態類型系統

    - 之前說過
      類型系統是用來分類語言的重要依據
      重要的兩大類是 動態類型 和 靜態類型
      其中 靜態類型 又可細分
      細分時
      分類的又一個重要依據就是
      不同語言對 子類型 的不同理解方式

*** 討論 <2016-01-12>

    - x ::
         type as set
         以相同的返回類型來分類函數
         f1 : ? -> t
         f2 : ? -> t
         class as set
         以相同的接收類型來分類函數
         m1 : c -> ?
         m2 : c -> ?

    - k ::
         ocaml 裏面
         同一個數據構造子
         可以接收各種類型的參數
         接收不同類型的參數的時候 可以返回各種不同類型數據
         並且
         接收相同類型參數而構造出的數據 也可以被認爲是屬於多種類型

    - x ::
         type
         可以用 數據構造子集合 來編碼
         一個 type 的數據構造子越多 這個 type 就越 大
         class
         可以用 接口函數集合 來編碼
         一個 class 的接口函數越多 這個 class 就越 小
         注意
         編碼的時候
         不光需要 數據構造子 或 接口函數 的名字
         還需要它們的類型
         這樣
         它們就都能獲得 '子類型' 這個偏序關係
         [因爲 集合的子集之間有這個偏序關係]

    - k ::
         面向對象範式 容易重用代碼
         只要定義一個新類型 c2
         聲明 c2 爲 c1 的子類型
         就能使用 c1 的所有接口函數了
         並且還能隨意添加新的接口函數

    - x ::
         函數式範式 容易以簡練模式匹配實現新的函數
         每個 pattern 都是一個 t1 的[無名]子類型
         並且這些子類型之間是不交的
         模式匹配之可能
         在於 數據構造子 作爲函數爲平凡 因而可逆
         並且
         定義新類型 t2 時
         可以通過聲明 有名不交子來興 來用到已有的 t1 t2 類型
         但是這裏子類型關係是 '有名' 的
         比如
         #+begin_src caml
         type number =
           | Int of int
           | Float of float
         ;;
         #+end_src

    - k ::
         要知道
         如果 數據構造子 作爲運行時的標籤
         那麼它就是相當平凡而自由的函數
         可以先考慮它們自由生成的空間
      1. 在 ocaml 中 每個 數據構造子 都只能作用於一個參數
         需要多個參數時 不能用 curry
         只能用 笛卡爾積
         ><><><
         這裏可以做很形式化的討論

    - k ::
         回到 面向對象範式 來
         class c1 也要有一個 構造這個類型的值的函數
         這種構造函數通常只有一個
         即使有多個也不能模式匹配
         因爲不一定有可逆性
         就算有可逆性也很難做玩全性檢查
      1. 我能想像到的方式
         就是去聲明 值域 之間的子類型關係
         但是這是難以接受的方式
