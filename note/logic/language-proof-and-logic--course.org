#+title: language proof and logic (course)

* links

  https://lagunita.stanford.edu/courses/Philosophy/LPL-SP/SelfPaced/course/

* Chapter 1: Atomic Sentences

  - a formal language for FOL
    with syntax difference between constant symbol -- `socrate`
    and predicate symbol -- `Man`
    and function symbol -- `father_of`

    they are called "symbol"
    because we need a model to make them meaningful

  - x -
    FOL is an untyped language

    a type-constructor in a typed language
    is of type (a : A) -> type
    it can be viewed as a predicate in FOL

    a predicate in a typed language
    is of type (a : A) -> bool-t
    it can be viewed as a predicate in FOL

    a type-constructor (conj or disj, not type valued functions)
    give us an algorithm, to generate
    all elements of the type-constructor
    - as long as the arguments of the type-constructor is of first-order

    a predicate, in general, does not induces an algorithm
    to generate all elements for which the predicate is true

  - x -
    why we have
    odd-t : (n : nat-t) -> type
    even-t : (n : nat-t) -> type
    but we do not have
    prime-t : (n : nat-t) -> type

    because elements of odd-t and even-t are generated
    by adding two to one and zero

    the space only have one base

    but elements of nat-t is generated by
    producting elements of prime-t together

    - unique-prime-factorization
      https://en.wikipedia.org/wiki/Factorization
      https://en.wikipedia.org/wiki/Fundamental_theorem_of_arithmetic

    and prime-t is defined by the unique-prime-factorization
    thus the base of the generation is prime-t itself
    which is an infinite space

    it seems all generation can only be done for finite base

  - all FOL model have basic identical predicate

    - x -
      although identical predicate is present in all FOL models
      but it is of each specific model
      but not of FOL itself

  - x -
    for general model theory
    we need existing theory (always set theory)
    to assign truth value to all atomic sentences

    - this assignment can be viewed as
      defining subjects and defining predicates

  - x -
    ever type in type theory can be translated to
    a predicate in a FOL model together with
    - generation of elements in the model which satisfy the predicate only
      (we can say "elements of the type")
    - basic equivalent relation between elements of the type

  - x -
    function symbol's meaning rely on model
    there are not function definition in FOL

    thus in FOL we can only handle functions by axioms about them

* Chapter 2: The Logic of Atomic Sentences

  - What does it mean when we say that sentence S
    is a logical consequence of sentence T ?

    S is a logical consequence of T if
    whenever T is true, S must be true as well

    it is impossibile for T to be true and S false

    - x -
      left player can play in both S and T
      (two games are dependent on each other)
      whenever she loss in S, she have winning strategy to win in T.

  - an argument is a chain of consequence

    an argument is valid if its consequences
    must follow from its premises

    an argument is sound (in some model) if it is valid
    and its premises are true

  - In everyday life, we rarely construct
    long chains of inference
    but think, for example, of mathematics
    and related disciplines.
    In these situations we often build large theories
    by proving results, and then using
    these results in later proofs, and then using
    those results yet later.

    - x -
      this is where we need to make use the knowledge
      we learned from developing software

  - Fitch notation
    https://en.wikipedia.org/wiki/Fitch_notation

    - example :

    #+begin_src cicada
    #1 Cube (c)
    #2 c = b
    ------
    #3 Cube (b) -- =-elim (#1 #2)
    #+end_src

  - x -
    comparing to game semantics,
    inference rules are highly non-symmetric

  - x -
    basic equivalent relation is part of every FOL model
    this means for a class to be used as a model of FOL
    it must have a basic equivalent relation with

  - x -
    substitution principle is closely related with
    unification in our implementation

  - x -
    in our interpretation
    we need to give every inference rule
    a constructive meaning

    what is the meaning of `=-elim` ?
    maybe :
    by c = b
    we can view Cube (b) as Cube (c)

    or we can view an element of Cube (b)
    as an element of Cube (c)

* Chapter 3: The Boolean Connectives

* Chapter 4: The Logic of Boolean Connectives

* Chapter 5: Methods of Proof for Boolean Logic

* Chapter 6: Formal Proofs and Boolean Logic

* Chapter 7: Conditionals

* Chapter 8: The Logic of Conditionals

* Chapter 9: Introduction to Quantification

* Chapter 10: The Logic of Quantifiers

* Chapter 11: Multiple Quantifiers

* Chapter 12: Methods of Proof for Quantifiers

* Chapter 13: Formal Proofs and Quantifiers

* Chapter 14: More about Quantification

* Summary of the Rules of F

* Glossary
