#+title: homology-note

* todo

  - to be constructive
    a quotient space should be defined by a natural-projection
    maybe fiber bundle should also be defined by projection

  - ><
    the gluing of adjunction is the same as
    that of the gluing of fibers ?

* note continuous

  - to say a map is continuous
    is to allow it to be used in the language

* note set theory vs type theory

  - ><
    what is this vs ?

  - class (in oo) is encoded by a list of interface functions
    type-class (in haskell) is encoded by a list of abstract interface functions
    which all seem like the dual of the poset structure of set as cat

  - the methods of set theory have no fault
    the fault is to not to view them with implementation in mind

* homology

*** definition

    #+begin_src scheme
    (~ H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ H/induce : ((:X :A -> :Y :B) (:q : int) ->
                   (:X :A :q H -> :Y :B :q H)))
    (~ boundary : (:X :A :q H -> :X empty-space :q 1 sub H))

    (~ co-H : ((:X : space) (:A < :X) int -> abelian-group))
    (~ co-H/induce : ((:X :A -> :Y :B) (:q : int) ->
                      (:Y :B q co-H -> :X :A q co-H)))
    (~ co-boundary : (:X empty-space :q 1 sub co-H -> :X :A :q co-H))
    #+end_src

*** >< axioms

    #+begin_src scheme
    (~ H/identity : ({:id : (:X :A -> :X :A)} :id space/iso {:q : int} ->
                     :id :q H/induce abelian-group/iso))

    (~ H/compose : ()
       (note
         this is always true
         for H/induce is recursively defined over function composition))

    (~ >< : ())
    #+end_src

* the extension problem

  - in the view of sze-tsen-hu
    extension problem is the main kind of general problem of topology

  - to solve the extension problem
    is to solve an equation in the continuous function space

  #+begin_src scheme
  (~ A X inclusion : (A < X) -> X)
  (~ g : ((A < X) -> Y))
  (~ f : (X -> Y
          (g = A X inclusion f)))
  #+end_src

* the method of algebraic topology

  - to induce algebraic equation from continuous equation
    is the method of algebraic topology

  #+begin_src scheme
  (~ g H/induce : ({A < X} A empty-space :m H -> Y empty-space :m H))
  (~ f H/induce : (X empty-space :m H -> Y empty-space :m H
                   (g H/induce = A X inclusion H/induce f H/induce)))
  #+end_src

* retraction

  #+begin_src scheme
  (~ r : (X -> A
          (A id = A X inclusion r)))

  (~ r H/induce : (X empty-space :m H -> A empty-space :m H
                     (A empty-space :m H id =
                      A X inclusion H/induce r H/induce)))
  #+end_src

* note quotient space

  - to define a quotient space
    is to lessen the equality

  - the construction of quotient space
    is also called topological identification

  - there are many patterns by which we can re-implement equality of a type

  - when one is trying to formalize a concept in math
    he should try to use all the implementation tech
    and all the language paradigms

  - but it seems we have a basic uniformed equality in the term-lattice
    re-implement of equality is to be built on top of it

* quotient/natural-projection

  - which can always be done by natural-projection

  #+begin_src scheme
  (~ quotient/natural-projection
     : ({:y : type}
        (:x : type) (:x -> :y) -> (:z : type))
     (:x :p ->
         {:z = (dr-from :x)}
         {:z.equal = (:a :b -> :a :p apply :b :p apply :y.equal apply)
                   (note
                     by apply
                     -> type without sugar)}
         {:z.equal = (:a :b -> ((:a :p) (:b :p) :y.equal))
                   (note
                     () as and sugar
                     -> type with sugar)}
         :z))
  #+end_src

* quotient/acting-group

  #+begin_src scheme
  (~ quotient/acting-group
     : ((:x : type) (:g < (:x -> :x))  -> (:z : type))
     (:x :g ->
         {:z = (dr-from :x)}
         {:z.equal = (:a :b -> {search :e : :g} :a :e apply :b :x.equal apply)}
         {:z.equal = (:a :b -> {search :e : :g} ((:a :e) :b :x.equal))}
         :z))
  #+end_src

* quotient/identity-element

  - by enlarging zero (or one) in algebraic structure

  #+begin_src scheme
  (~ quotient/identity-set
     : ((:x : type) {:x with sub}
        (:x0 < :x)  -> (:z : type))
     (:x :x0 ->
         {:z = (dr-from :x)}
         {:z.equal = (:a :b -> {:a :b sub : :x0})}
         :z))
  #+end_src

* >< adjunction space

  - note that
    g is directed
    X and Y are not 對稱

  #+begin_src scheme
  ;; adjoining X to Y by (~ g : (A -> Y))
  (~ X Y g adjoin : {A < X} (+ X Y))

  ;; instead of adding more equal tests
  ;; we specify a natural-projection
  (~ adjunction/p : ((+ X Y) -> (X Y g adjoin))
     ({:x : A} :x -> :x g)
     ({:x : (+ X Y)} :x -> :x))
  #+end_src

* >< extension equal to retraction of adjunction

  #+begin_src scheme
  (~ g : ((A < X) -> Y))

  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion r)))
  (~ f : (X -> Y
            (g = A X inclusion f))
     (:x -> :x p r))

  (~ f : (X -> Y
            (g = A X inclusion f)))
  (~ r : ((X Y g adjoin) -> Y
          (Y id = Y (X Y g adjoin) inclusion r))
     ><><><)
  #+end_src

* >< mapping cylinder

  #+begin_src scheme
  (~ f : (X -> Y))
  (~ mapping-cylinder/p : ((+ (X I) Y) -> f mapping-cylinder)
     (:x 1 -> :x f)
     (:x :i -> :x :i)
     (:y -> :y))
  #+end_src

* >< from chain-complex to homology

* >< the cat of top

  - for the cat of top
    a top constructor is defined by
    specifying set-level construction
    and specifying the open set or closed set

* >< cell-complex

  - CW-complex
    C for closure-finite
    W for weak-topology
