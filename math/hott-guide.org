#+title: hott guide

* todo

  - 現在有了
    1. 構造幾何對象的形式語法
    2. 判斷(低階)幾何對象之間的同倫等價的方法
    而 引入同倫等價這個概念 最初就是爲了在計算同倫群時
    給出 判斷群中元素是否等價的方式

  - 但是這只不過是最近本的概念的形式化處理而已
    已經可以用來形成某些定義了
    但是要想計算同倫群 就還要有更精進的理論

* a reading guide of hott

  - always concern yourself about the geometry aspects
    of the formal language,
    because the language is to be used as a formalization
    of the geometry intuition of human.

  - a type is a geometry object.
    a definition of a geometry object is just like
    a description of how you could draw a picture of the geometry object.

  - constructors are used to construct geometry objects.
    | level | geometry object |
    |-------+-----------------|
    |     0 | point           |
    |     1 | path            |
    |     2 | surface         |
    |   ... | ...             |

  - cell complex
    注意 不能跨階粘貼邊界
    boundary
    ><><><
    note that the '=' based syntax is not 對稱
    因爲 (例如就二階元素而言) p = q 等價於 p q^{-1} = 1
    在高階的情形更是如此

  - a dependent type is a type family,
    a type family is a fibration,
    a function of such type is a section of the fibration.

  - all functions are considered continuous.
    when you want to find a function of certain type,
    such as (A -> B), (x:A -> B(x)),
    it must satisfy some constrains to be continuous.
    what are such constrains ?

    - a fibration is a type family,
      a type family can be used as a function.
      to be able to describe the constraint of continuous function,
      what constrains a type family must satisfy ?

  - a type is a proposition,
    a function body of such type is its proof.
    a proof is a record of deduction steps
    that finally would arrive the proposition.

  - what is the meaning of being constructive ?

* the meaning of being constructive

  - deduction system 與 rewrite system 之間的關係
    首先以 deduction system 爲本
    設計用來記錄 record of deduction steps 的語法
    此時的語法並沒有 rewrite 的意義

  - rewrite 的意義來原於
    1. constructor 作爲平凡的函數體
    2. 定義函數體的 pattern match 語法使得新定義的函數體描述 rewrite

  - 注意
    type class 的接口函數名字 與 constructor 不同
    不能被當作平凡函數體
    我想這就是 logic harmony
    constructor 構造
    而 pattern match 解構

* constraint of fibration

  - to be able to describe the constraint of continuous function,
    a fibration must also has a function body for its transport.
    because constraints of continuous function of fibration
    are described by transport.

  - 如果 一個 dependent type 不足以確定一個 fibration
    即 還需要明確指定其 transport
    那麼 就不可能有一般的 獲得 transport 的函數體 的方式

* 單值性 與 連續性

  - 當把 path 理解爲 geometry object 時
    函數定義的基本限制是 連續性

  - 當把 path 理解爲 引入的等詞時
    函數定義的基本限制是 也可以被理解爲 單值性

* higher inductive definition

  - ~ 是遞歸展開
    = 是遞歸基礎

* >< continuous

  - (A -> B)

  - (x:A -> B(x))

* (Σ2 ~> S^1) 與 (ΣΣ2 ~> S^2)

  - 函數之間的 同倫 記 '~'
    空間之間的 同倫等價 記 '~>'

  - 目前所有的計算都來源於想要證明
    Σ2 ~> S^1 與 ΣΣ2 ~> S^2
    證明 '~>'
    即 構造兩個作爲 fibration 的特殊 path space 中的元素
    f : (A ~> B) {g : (B ~> A)}
    k : ((x : A) -> x f g = x)
    z : ((x : B) -> x g f = x)

* (bool-suspend ~> sphere-1)

  #+begin_src scheme
  (+ sphere-1 : type
     b : sphere-1
     loop : (b = b))

  (+ bool : type
     0 : bool
     1 : bool)

  (+ bool-suspend : type
     n : bool-suspend
     s : bool-suspend
     m : (bool -> (n = s)))

  (~ f : (bool-suspend -> sphere-1)
     (n -> b)
     (s -> b)
     f : ((n = s) -> (b = b))
     (0 m -> loop)
     (1 m -> b rf))

  (~ g : (sphere-1 -> bool-suspend)
     (b -> n)
     g : ((b = b) -> (n = n))
     (loop -> {0 m 1 m rev}))

  (~ g f : (sphere-1 -> sphere-1)
     (b -> b)
     g f : ((b = b) -> (b = b))
     (loop -> loop))

  (~ f g : (bool-suspend -> bool-suspend)
     (n -> n)
     (s -> n)
     f g : ((n = s) -> (n = n))
     (0 m -> {0 m 1 m rev})
     (1 m -> n rf))

  (~ :k : ((:x : bool-suspend) -> (:x f g = :x))
     {n :k : (n = n)}
     {s :k : (n = s)}
     :k : ((:p : (n = s)) -> (n :k (:p :k tp) = s :k))
     {0 m :k : ((0 m f g) rev n :k 0 m = s :k)}
     {1 m :k : ((1 m f g) rev n :k 1 m = s :k)}
     (<solve>
      n :k == n rf
      s :k == 1 m
      0 m :k == 1 m rf
      1 m :k == 1 m rf))
  #+end_src

* (bool-suspend-suspend ~> sphere-2)

  #+begin_src scheme
  (+ sphere-1 : type
     b : sphere-1
     loop : (b = b))

  (+ sphere-2 : type
     b2 : sphere-2
     surf : (b2 rf = b2 rf))

  (+ bool : type
     0 : bool
     1 : bool)

  (+ bool-suspend : type
     n : bool-suspend
     s : bool-suspend
     m : (bool -> (n = s)))

  (+ bool-suspend-suspend : type
     n2 : bool-suspend-suspend
     s2 : bool-suspend-suspend
     m2 : (bool-suspend -> (n2 = s2)))

  (~ f : (bool-suspend-suspend -> sphere-2)
     (n2 -> b2)
     (s2 -> b2)
     f : ((n2 = s2) -> (b2 = b2))
     (n m2 -> b2 rf)
     (s m2 -> b2 rf)
     f : ((n m2 = s m2) -> (b2 rf = b2 rf))
     (0 m m2 -> surf)
     (1 m m2 -> b2 rf rf))

  (~ g : (sphere-2 -> bool-suspend-suspend)
     (b2 -> n2)
     g : ((b2 rf = b2 rf) -> (n2 rf = n2 rf))
     (surf -> {0 m m2 1 m m2 {n m2 s m2 rev}}))

  (~ f g : (bool-suspend-suspend -> bool-suspend-suspend)
     (n2 -> n2)
     (s2 -> n2)
     f g : ((n2 = s2) -> (n2 = n2))
     (n m2 -> n2 rf)
     (s m2 -> n2 rf)
     f g : ((n m2 = s m2) -> (n2 rf = n2 rf))
     (0 m m2 -> {0 m m2 1 m m2 {n m2 s m2 rev}})
     (1 m m2 -> n rf rf))

  (~ g f : (sphere-2 -> sphere-2)
     (b2 -> b2)
     g f : ((b2 rf = b2 rf) -> (b2 rf = b2 rf))
     (surf -> surf))

  (~ :k : ((:x : bool-suspend-suspend) -> (:x f g = :x))
     {n2 :k : (n2 = n2)}
     {s2 :k : (n2 = s2)}
     :k : ((:p : (n2 = s2)) -> (n2 :k (:p :k tp) = s2 :k))
     {n m2 :k : (n2 :k n m2 = s2 :k)}
     {s m2 :k : (n2 :k s m2 = s2 :k)}
     :k : ((:h : (n m2 = s m2)) -> (n m2 :k (:h :k tp2) = s m2 :k))
     ;; 這裏的 tp2 使用比 hott 更高階的類型
     {0 m m2 :k : (><><><)}
     {1 m m2 :k : (><><><)}
     (solve-by
      ><><><))
  #+end_src

* >< tp 與 apd

  #+begin_src scheme
  ;; fibration
  F := ((:x : A) -> :x P)
  ;; 每個 fibration 必須有 tp
  (* (F tp) : ((:x = :y) -> (:x P ~> :y P)))
  ;; section
  (* k : ((:x : A) -> :x P))
  ;; k 和 (F tp) 的作用 出現在 (k apd) 的類型中
  (* (k apd) : ((:p : (:x = :y)) -> (:x k (:p F tp) = :y k)))
  ;; (k apd) 的函數體的存在性 就是限制 k 的函數體的方程
  ;; 所謂 限制
  ;;   即 x k 與 y k 不能在 x P 與 y P 中任意取值
  ;;   即 有邊相連的點 x 與 y 其值 x k 與 y k 受邊所生成的方程的限制
  #+end_src

  - 而古典理論中 描述 fibre bundle 的方式是
    projection : total-space -> base-space
    這裏 total-space 的定義本身就描述了全局結構

  - fibre bundle 中 fibre 是固定的空間
    而 fibration 中 fibre 是可依賴 x 的
    此時 fibre 不必是相等的空間
    但是必須是同倫等價的
    這就是 要求 tp 存在的原因

  - 而在形式理論中 描述 fibration 的方式是
    F := (x : base-space -> x P)
    此時 total-space 是構造出來的 F
    需要額外用 tp 給出 fibration 的全局結構
    - 所謂 全局結構 或 全局信息
      其實也是局部的 只不過不是就 point 來描述
      而是就 path 或高階幾何元素來描述而已

  - apd 的類型中 有 tp 的作用 可能是爲了
    能夠以線性的方式表示封閉的高階 path
