#+title: 等式的语言 / a language for equation

* todo

*** 之前的語言中對空間的同倫等價的證明

    - x -
      之前的設計中
      爲了證明一些 subdivision 之間的等價
      我們花費了很大篇幅的代碼
      現在我們知道
      這種等價關係也許不應該用空間之間的同倫等價的古典定義來處理

    - k -
      事實上 我們還是不知道應該如何處理空間之間的等價
      subdivision 可以有代數解釋
      它也可以看成是代數結構的細化

    - x -
      combinatorial topology 中用一些基本變換來定義空間之間的同倫等價
      我們是否也應該採取這種定義方式呢 ?

    - k -
      首先來看 subdivision
      我們知道
      用一對函數來定義的倫等價
      可以用來解釋 subdivision 所得到的空間之間的等價
      這甚至不是同倫而是同胚

    - x -
      既然 subdivision 有代數解釋
      函數所定義的等價 對 subdivision 的解釋
      是否也有代數解釋呢 ?
      即 用代數的觀點 來解釋之前的解釋

    ------

    - x -
      我們不能迴避古典的用兩個函數定義空間之間的等價的方法
      我們要試着給出解釋
      subdivision 所給出的 空間之間的兩個函數是特殊的
      其中一個函數是不降階的
      也許這正是區分 同倫 和 同胚 的關鍵

*** 需要一個形式語言來描述 abelianization

*** refl

    - x -
      我們還沒有考慮 (refl ...) 與一般元素的相乘問題

    - k -
      但是我們現在有了一個指導原則
      那就是 chain 的語法 == 等式組變換的忠實記錄
      在這個指導原則下
      語法的設計應該輕鬆多了
      在需要做決策的時候 我們可以使用這個原則

*** 現在的語法是否已經足夠描述 product-space 的 boundary rule 了 ?

    - fiber-space = dependent product-space

*** 從低維低組合數開始

    - 從低維低組合數開始
      列舉 complex 與 manifold

      給這些列舉以細分
      使得能夠得到 simplicial-complex 而計算 homology group

      不用 simplicial-complex 而直接計算 homology group
      觀察 homology 可否作爲高階代數的 abelianization

      對於 2-man 觀察 normalization
      對於 3-man 嘗試 normalization

      對於 2-man 觀察沒有 normalization 的條件下 獲得 universal-covering-space
      對於 3-man 嘗試獲得 universal-covering-space

*** 嘗試以形式化的方式描述 covering-space 與 universal-covering-space

*** 找到一個合適的講解 simplicial-complex 的 homology theory 的方法

    - 從古典的作者入手
      max newman
      james alexander
      j h c whitehead

    - to generalize homology theory
      from simplicial-complex to polyhedron-complex

* note

*** intro

    - topology, or at least combinatorial topology,
      give raise to algebraic topology,
      the aim of which is to find
      algebraic structures as invariants of topology space.

      my argument is that combinatorial topology it self
      can be viewed as an higher algebraic structure,
      finding different algebraic invariants
      of a combinatorially defined topology space
      is to simplify the higher algebraic structure in different ways.

    - 組合羣論中說羣是由生成子和關係展示的
      其實這裏所說的關係都是特殊的關係 即 等式
      在我的語言中 我強調這一點
      並且給等式的方向以解釋

    - my aim is to provide a language in which
      all the phenomena of algebraic topology can be expressed and explained.

    - [並非劃歸 圖形是必要的]
      在觀察這些從圖形得到的代數結構時
      我們不能脫離對這些圖形的想象本身
      因爲不藉助這些圖形來處理
      等式的兩種恆等變形之間的等價
      是難以想象的

    - [recover geometry]
      am i to reduce topology to algebra ?
      by no means, since topology, as and reduction of geometry,
      relies on geometry;
      so will my higher algebraic structure relies on geometry.

*** neighborhood 與 幾何 [recover geometry]

    - x -
      如果想要引入 neighborhood 的概念
      那麼是否也要同時引入 幾何 呢 ?
      如果要的話
      那麼所有的線都應該理解爲空間中的直線[測地線]
      而所有的面都應該理解爲空間中的什麼 ?

    - k -
      使用 neighborhood 的意義在於有限覆蓋定理
      但是我們所定義 neighborhood 的方式
      目前只是爲了把它聯繫於 用邊界所定義的連續性

    - x -
      我想我們必須引入幾何了

    - k -
      我想你之所以這樣說
      是因爲當考慮到有限覆蓋的時候
      就像是給了圖形以座標系

*** 之前的錯誤在於沒有考慮定向 [現在知道定向就是等式的方向]

    - 一個 disk 或 ball 的邊界多種表示方式
      當圖形作爲代數結構中的元素而自乘時
      之前的想法是
      只要有公共公共邊界就可以相乘
      其中某種相乘 被認爲是 same-position-self-gluing
      這種相乘將消除一對元素

      現在知道必須把這些
      作爲 disk 或 ball 的邊界的 circle 或 sphere
      所形成的 close chain
      理解爲等式
      等式是有固定方向的
      這個方向對應於 disk 或 ball 的定向
      多種表示方式和相乘方式 = 等式的恆等變換
      允許 左右兩邊的移項 這種恆等變換
      但是 當改變等式的方向的時候 必須要給出明顯的記錄
      因此 same-position-self-gluing 不能理解爲簡單的自乘了
      而應該被理解爲取反向之後的相乘
      想要相消 必須是 (+ A -A) 而不能是 (+ A A)
      這樣 有關相消的信息就被明顯地表達出來了

*** 代數結構

    - [generator and chain]
      chain 是代數中的元素
      即 生成子的複合
      這裏所考慮的 chain 不是交換的

    - [boundary operator]
      組成 chain 的元素可能屬各個層次
      層次之間有 boundary 算子
      邊界爲空的 chain 是閉的

    - [adding generator as adding equation to free algebraic structure]
      disk 與 ball 是 chain 所形成的等式

    - [generator 的複合 就是 等式的融合]
      disk 與 ball 在 glue 下形成 二階或者三階 chain
      這種 glue 記錄了 一階或二階等式之間的融合 [或者形成等式組]
      - 在爲這種記錄設計語法時
        需要能夠表達 移項 這種對等式的變換
        移項 可以把等式化爲更好看的形式
      - 更重要的是
        還要有語法來表達 兩個等式之間 就某個元素的代入
        代入之後 兩個等式將被融合爲一個等式

    - [語法難點]
      假設我們的語法是線性的
      - 一階代數中
        | 非閉合元素 | line segment | 有唯一的表達方式 |
        | 閉合元素   | circle       | 有很多表達方式   |
        | 等式       | circle       | 有很多表達方式   |
      - 二階代數中
        | 非閉合元素 | sphere with holes [disk = sphere with one hole] |
        | 閉合元素   | sphere                                          |
        | 等式       | sphere                                          |

    - [等式可以用來 rewrite chain]
      用一個等式去變換一個 chain
      利用等式來做 rewriting
      這種 rewriting 可以看成是函數的同倫
      因爲 空間 A 中的 chain 可以看成是某個空間 X 嵌入 A
      (: f (-> X A))

      如何區分 同倫變換 與 同痕變換 與 外在同痕變換

      如果這樣想
      我們就是在用高階代數中的元素[chain]來取代函數
      高階代數中的元素的性質 就反映了 空間 X 的性質
      二者之間應該有嚴格的對應

      有了函數之間的同倫等價
      那麼空間之間的同倫等價如何呢 ?
      [即 hauptvermutung 問題]

    - [同倫時維數變化的代數解釋]
      每個元素本身都蘊含着一個平凡的等式
      那就是 其與自身相等

*** 高階代數結構的同臺定理

    - x -
      不用過多地考慮古典的 hauptvermutung
      其實我們現在已經有了不錯的理解函數之間同倫的方式
      重要的是找到在我們的語言中解釋空間之間的等價的方式
      [其定義可能有別於 Hurewicz 的 homotopy-equivalence]
      我們要找在我們的語言中自然的等價關係
      然後看看這個等價關係在更古典的語言中的解釋

      函數空間 (-> A B) 就是 B 的具有特殊性質的 chain 的空間
      對於函數空間之間的等價
      我們也是不知道該如何定義的
      我們目前知道的只是
      元素之間的等價 和 函數之間的等價
      這二者都可以說是一階的等價

    - k -
      我想 對於空間之間的等價關係而言
      公共細分所定義的等價關係就已經夠了
      細分是有代數解釋的 [考慮 group 被細分爲 group]
      並且 把類型當作數據的時候
      細分也可以用函數來實現 [考慮二維流形的分類定理]

    - x -
      如果這樣說的話 我們其實是在用 hauptvermutung
      但是我們不知道古典意義上的 hauptvermutung 的意義是什麼
      我們不知道 爲什麼 hauptvermutung 是需要證明的
      低維時這個定理是如何被證明的 ?
      高維是這個定理爲什麼會被否定 ?
      四維時爲什麼還沒有結果 ?
      當證明 hauptvermutung 的時候 我們證明的是什麼 ?
      其構造性如何 ?
      - 既然在高維這個定理可以被否定
        那麼就是說 有另外一種定義空間之間的等價的方式
        並且在高維的時候
        這種定義 比 公共細分所做的定義 帶有的信息要多

    - k -
      但是我們也要明白
      如果採用這種方式的話
      我們就離開了同倫
      而回到了對同胚研究
      維數之間不能有變化了

    - x -
      首先 跨越維數的映射
      在我們的語言中本來就是不自然的
      其次 從等式的角度看 維數的變化也是可以解釋的
      因爲對等式的平凡的恆等變形也算是恆等變形

    - k -
      我們還需要考慮如何定義函數空間之間的等價關係

    - x -
      某個函數空間可以看成是
      限制對 chain 所施行的代數操作
      這類似於羣的同態定理

      考慮羣同態 (: f (-> G1 G2))
      (~~ (/ G1 (ker f)) (img f))

      考慮連續函數 (: f (-> A B))
      它被理解爲 B 中的 chain
      但是 A 的形式限制了 chain 的性質
      並且 (ker f) 是 A 中那些被放棄不用的 對 chain 的限制
      [有很多的限制方式 但是我放棄使用其中一些]

    - x -
      如果我能找到一個高階代數結構之間的等價關係
      使得它介於同倫與古典的同胚之間
      我就能證明高階同倫羣是不重要的了
      因爲同倫羣所帶有的信息
      就是同倫等價所需要的所有信息

    - k -
      首先我們已經有代數結構的細分了
      如果想要定義更強的等價
      就要允許更多的對代數結構的變換
      還有什麼可以允許的呢 ?

    - x -
      可能這種想法太刻意了
      不如想想能夠如何模仿 homology group
      來給我們的高階代數結構做去類型化與交換化
      我們可以試着找出同調羣無法區分的空間
      然後以新的方式弱化代數結構
      使得如此獲得的代數結構之間的同構問題可解
      並且能夠區分那些同調羣無法區分的空間

    - k -
      如果我們的理論與語言有效的話
      我們應該能自己構造出很多這種空間
      不用 knot 而用 polyhedron

*** 計數

    - x -
      語法和語義之間的關係在於
      多種語法可以描述同樣的數據

      [問題 1]
      當以一種語法描述出數據之後
      根據數據本身 可以生成出
      所有可能的描述這個數據的語法
      試着做一些窮舉
      然後看看有沒有正規形式

      [問題 2]
      如果要用有向圖來實現這些數據
      那麼如何判斷兩個數據是否相等呢 ?

    - k -
      我發現
      只要能想象出圖形
      就是能在程序語言中用數據結構實現它們
      因此 '語義' 一詞
      就機器實現而言
      也就人的想象而言

* 一維自由代數結構 / 1 dimensional free algebraic structure

  - 首先我們有很多點
    點之間有很多被標記以方向的邊 稱爲有向邊
    我們可以認爲這樣一個圖是一個代數結構 稱爲 free-groupoid
    有向邊爲生成子
    生成子相乘可以得到這個代數中的一般元素

    代數的元素之間有等式
    比如平凡的等式 (= a a)

    沿着一條有向邊走 過去又馬上走回來 就等同於留在原地
    這樣我們就得到了一個看似非平凡的等式 (= (+ a (- a)) (+))
    我們可以說這是一種消去
    當 (+ a (- a)) 出現時它們可以被消除

    但是我們發現 (= a a) 與 (= (+ a (- a)) (+)) 其實是同一個等式
    因爲經過移項 二者之間可以相互轉化
    這就是等式的恆等變形

    或者我們可以說
    對於代數中的每個元素
    我們都能形成平凡的等式
    #+begin_src scheme
    (: (refl a) (= a a))
    (: (refl (+ a b)) (= (+ a b) (+ a b)))
    #+end_src

    我們還可以利用移項來對這些等式進行恆等變形
    即 基本恆等變形
    #+begin_src scheme
    (: (refl a) (= a a))
    (: [(refl a) (=> a)] (= (+ a (- a)) (+)))
    (: [(refl a) (=< a)] (= (+ (- a) a) (+)))
    (: [(refl a) (>= a)] (= (+) (+ a (- a))))
    (: [(refl a) (<= a)] (= (+) (+ (- a) a)))
    #+end_src

    一般的規則如下
    #+begin_src scheme
    (: =< (-> [<::> = <::>] [(- <:) <::> = :>]))
    (: => (-> [<::> = <::>] [<::> (- :>) = <:]))
    (: <= (-> [<::> = <::>] [:> = (- <:) <::>]))
    (: >= (-> [<::> = <::>] [<: = <::> (- :>)]))
    #+end_src

    我們可以說這些是同一個元素
    只不過我們用來表達這些元素的語言是線性的
    所以對同一個元素 產生了不同的表達方式
    當把形式語言實現爲程序語言的時候
    我們可以寫一些檢查器
    來幫助我們判斷 某些式子是否是同一個東西的不同表達方式

    等式可以用來轉寫代數結構中的元素
    平凡的等式 和 平凡的等式經過移項變形而得到的等式
    所形成的轉寫都是平凡的
    這些轉寫不用記錄 直接讓機器處理就好

    - 也就是說我們可以自由的消去相鄰的互逆的元素
      但是這是不應該被允許的
      因爲 消去互逆的項與否 整個 chain 的邊界就改變了
      而 chain 要能被看作是 對邊界之成爲當前這樣的邊界 的忠實記錄
      邊界就是等式組 chain 是對等式組的變換的記錄

    - 但是如果這些平凡的轉寫不能讓機器自動處理
      那麼表達移項的語法可能就非常複雜了

    - 之所以這樣說是因爲
      把移項理解爲了 先在等式兩邊同時乘以某個元素
      然後再消去相鄰的項
      (a b = c)
      (a b -b = c -b)
      (a = c -b)
      只要拋棄這種觀點就行了

    - 核心的想法是
      chain 的語法是對等式組變換的忠實記錄
      即 所有關於變化的信息 都要被明顯的語法表達出來

    說這個代數結構是 free-groupoid
    說其 'free' 就在於除了這些利用 'refl' 生成的平凡等式之外
    沒有別的等式了

* 一維非自由代數結構  / 1 dimensional non-free algebraic structure

  - 添加一些別的等式 free-groupoid 就變成了 groupoid
    首先我們發現 (= (+ b0 b1) (+ b1 b0))
    是不能由平凡等式經過基本恆等變形來得到的
    我們可以把這個等式添加到我們的代數結構中來
    #+begin_src scheme
    (: c0 (= (+ b0 b1) (+ b1 b0)))
    #+end_src

    添加的時候給以了名字
    每次想要使用這個等式的時候
    我們就用這個名字做記錄

    我們還可以再添加一個
    #+begin_src scheme
    (: c1 (= (+ b0 b1) (+ b1 b0)))
    #+end_src
    雖然二者作爲等式是相同的
    但是在用於轉寫時
    二者的性質可能不同
    比如 二者消耗的能量可能不是一個數量級的
    或者 二者消耗的能源類型不同
    或者 二者消耗的時間不是一個數量級的

    比如我們還可以引入
    #+begin_src scheme
    (: c (= b0 b0))
    #+end_src
    雖然它的作用效果是平凡的
    但是它與平凡的等式 (refl b0) 是不同的

    我們假設每個這樣的引入
    所引入的都是與之前等式不同的新等式

    我們可以想象 (+ b0 b1) 是某個分子結構
    我們發現了一種物質 c0 利用這個物質 和某種處理方式
    我們能把 (+ b0 b1) 變成 (+ b1 b0)
    之後我們又發現了 另一種類似的物質 c1 也有類似的效果
    等等

    這樣等式對元素所做的變化 就能被實體化
    動詞的名詞化 就是爲了記錄
    爲了能夠把動詞所代表的變化當作名詞一樣來處理
    反向的等式就是反物質
    等等

    這些等式也可以用來轉寫一階代數結構中的元素
    這些等式也可以進行移項這種恆等變形
    如果只在乎把 (+ b0 b1) 變爲 (+ b1 b0)
    那麼使用 c0 和 c1 那個都無所謂

    並且我們可以把兩個等式融合來得到新的等式
    我們要設計語法來記錄等式的融合
    並且 融合兩個等式之後再作用 與 相繼的作用兩個等式 必須是等價的

* 類比化學語言

  - 我們可以把上面的類比加以系統發展
    用以理解高階代數中的現象

    物質
    物質之間的轉化
    轉化是利用高階的物質完成的
    反物質
    等等

* 二階空間

  - 我們發現
    1. 等式有逆元素
    2. 兩個等式如果有相同的元素
       就可以利用元素代入來將兩個等式融合爲一個
       這種融合就像是代數結構中的乘法

    這樣我們就有了一個二階的代數結構 稱其爲 2-complex
    我們可以把一階時候的術語統一一下
    稱之前的 free-groupoid 爲 1-complex
    這樣 1-complex 之 'free' 就在於 其中沒有非平凡二階元素

    就像一階情形一樣
    首先我們要找到 基本恆等變形
    這些恆等變形 當然就是 (refl c0) 之類的平凡等式 經過移項獲得的
    我們需要設計語法來描述這些信息

* ><><>< 選取例子以驗證語言的有效性

  - 邊數很少的 polygon
    面數很少的 polyhedron
    的所有可能
    然後以它們爲基礎看各種算法作用於它們的效果

  - 用正多面體來形成簡單的例子
    此時可以觀察對稱性

  - 那麼這首先將引出一個計數問題
    通過計數我們可以估計問題的複雜性
    首先我們要確定
    有多少由 n-gon 或 n-hedron 構造 manifold 的方式

* 二維空間的例子

*** mobius-band

    #+begin_src scheme
    (define mobius-band
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a0))
        (: b2 (= a0 a1))
        (: c0 (= (+ b0 b1) (+ b2 (- b0))))))

    (: c0                   (= (+ b0 b1) (+ b2 (- b0))))
    (: (+ c0 (=< b2))       (= (+ (- b2) b0 b1) (- b0)))
    (: (- c0)               (= (+ b2 (- b0)) (+ b0 b1)))
    (: (+ (- c0) (<= b2))   (= (- b0) (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          (- c0) (<= b2))
       (= (+ (- b2) b0 b1) (+ (- b2) b0 b1)))

    (: (refl c0)
       (= c0
          c0))

    (: [(refl c0) (=> c0)]
       (= (+ c0 (=< b2)
             (- c0) (<= b2))
          (+)))
    #+end_src

*** cylinder

    #+begin_src scheme
    (define cylinder
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a1))
        (: b2 (= a0 a0))
        (: c0 (= (+ b0 b1) (+ b2 b0)))))

    (: c0                   (= (+ b0 b1) (+ b2 b0)))
    (: (+ c0 (=< b2))       (= (+ (- b2) b0 b1) b0))
    (: (+ c0 (>= b1))       (= b0 (+ b2 b0 (- b1))))

    (: (- c0)               (= (+ b2 b0) (+ b0 b1)))
    (: (+ (- c0) (<= b2))   (= b0 (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          (- c0) (<= b2))
       (= (+ (- b2) b0 b1)  (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          c0 (>= b1))
       (= (+ (- b2) b0 b1) (+ b2 b0 (- b1))))
    #+end_src

*** sphere

    #+begin_src scheme
    (define sphere
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: c0 (= b0 b0))))

    (define sphere
      (type space
        (: a0 a1 a2 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a2))
        (: c0 (= (+ b0 b1) (+ b0 b1)))))
    #+end_src

*** solid-tetrahedron

    #+begin_src scheme
    (define solid-tetrahedron
      (type space
        (: a0 a1 a2 a3 <>)
        (: b01 (= a0 a1))
        (: b02 (= a0 a2))
        (: b03 (= a0 a3))
        (: b12 (= a1 a2))
        (: b13 (= a1 a3))
        (: b23 (= a2 a3))
        (: c012 (= (+ b01 b12) b02))
        (: c123 (= (+ b12 b23) b13))
        (: c013 (= (+ b01 b13) b03))
        (: c023 (= (+ b02 b23) b03))
        (: d1234
           (= (+ (- c012) (=< b01)
                 c123 (>= b23)
                 (<= (- b01))
                 (=> (- b23)))
              (+ (- c013)
                 c023 swap))
           (note
             (= (+ (- c012) (=< b01)
                   (:> (= (+ (- b01) b02) b12))
                   c123 (>= b23)
                   (:> (+ (= (+ (- b01) b02) b12)
                          (= b12 (+ b13 (- b23))))
                       (= (+ (- b01) b02) (+ b13 (- b23))))
                   (<= (- b01))
                   (=> (- b23))
                   (:> (= (+ b02 b23) (+ b01 b13))))
                (+ (- c013)
                   (:> (= b03 (+ b01 b13)))
                   c023 swap
                   (:> (+ (= (+ b02 b23) b03)
                          (= b03 (+ b01 b13)))
                       (= (+ b02 b23) (+ b01 b13)))))))))
    #+end_src

* 映射

  - 兩個空間 A B 之間的映射可以被理解爲
    B 中的一組 chain
    其中每個 chain 被 A 中的生成子命名
    並且生成子的邊界給 B 中的這一組 chain 的選取加以了限制

  - 也可以被理解 aristotle 對連續體的解釋

  - 映射的複合
    ><><><

* 二維空間之間的映射的例子

* 三維空間的例子

* 三維空間之間的映射

* >< 忘記高階代數結構中的某些信息就得到同調理論

*** 引

    - 如何解釋 S2 的三階同倫羣爲非平凡羣 ?
      一個非平凡羣的 abelianization 可以是平凡羣嗎 ?

    - 只能解釋爲 兩個平凡等式 可能不等價

*** 規則

    - 經過 abelianization 之後
      邊界爲 0 的 k 階生成子是 k 階同調羣的元素
      k+1 階生成子給出 k 階同調羣中元素之間的等式

* 獲得拓撲不變量

*** 引

    - 取閉合的鏈
      是否就能簡化代數結構而得到能力更強的拓撲不變量呢 ?

      我想問題應該劃歸爲
      當限制 代數中的元素爲 閉合的鏈時
      可否得到對這些元素的更高效的編碼 ?
      能否把這個代數結構化簡到正規形式 ?

      曲面的分類定理 可否被表達爲 對這個代數結構的化簡 ?
      一維的時候 我們可以把這個代數結構化簡成基本羣
      [我們要形成等價的定理 但是表達方式已經不一樣了]
      二維的時候 二階同倫羣是不夠的
      只考慮零虧格的曲面嵌入三維空間是不夠的
      還需要考慮高虧格的曲面嵌入三維空間
      三維空間中可能有高虧格的洞

*** 基本羣的另一種表示方式

    - 我們可以說兩個圈相加
      而不必說兩個圈相加而得到一個圈

*** 簡化代數結構的方法

    - 同倫的閉合鏈產生與對代數結構的過度細分
      找出同倫的鏈然後融合細分中的部分
      就能化簡代數結構

* >< 覆蓋空間 與 元素的等價問題

  - x -
    fundamental-group of surface =
    group of covering-transformation of universal-covering-space of surface
    這個等價如何推廣到高維代數 ?

  - k -
    首先我們看到推廣的可能的時候
    並不是從這個角度考慮的
    這在於 path 的邊界 形成一個點到點的[可逆]映射
    而 disk 的邊界 不能形成點到點的映射
    它所形成的是 很多邊之間的[可逆]關係

    我們想的其實還不是 點到點的可逆變換
    而是 給定 起點的時候 path 與終點對應 [降維]

  - x -
    groupoid 也可以 acting on covering-space
    只不過 covering-transformation 要加上類型

    branched-covering 使得 path lifting 不唯一

    帶有 一階洞 的 covering
    不同的 loop 經過 lifting
    可能給出 covering-space 中的同一個終點
    [因爲 covering-space 中可能有不可收縮的 loop]

    也就是說
    一個使得點變多
    一個使得點變少
    只有 universal-covering-space 的點是與 path 一一對應的

* >< 用沒有一階洞的一階無窮複形覆蓋一般一階複形
* >< 用沒有二階洞的二階無窮複形覆蓋一般二階複形

  - 此時有必要使用 branched-covering
    我們可以試試找一個 branched-covering of torus
    看看這個 branched-covering 能否解決 torus 的字問題

* >< 曲面分類定理的形式化
