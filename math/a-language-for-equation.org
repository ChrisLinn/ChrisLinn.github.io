- title :
  a language for equation
  a generalization of fundamental group

- author :
  XIE Yuheng

* todo

*** combinatorial topology

    - 我們需要更經濟的語言來描述空間之間因爲公共細分而形成的同胚等價
      而不能用兩個函數所給出的同倫等價

*** 编码问题

    - x -
      在考虑粘合 polyhedron 的時候
      可能就已經出現 編碼問題了
      因爲此時 邊和面太多了

*** 非交換的代數結構

    - x -
      whitehead 已經知道的那些空間的非交換的高階代數結構是什麼 ?
      [cross-module]

*** local-to-global

    - x -
      一個 local-to-global theorem 可以給我們靈活的計算方式
      是否可以對高階代數結構形成 local-to-global theorem ?

*** 語言的有效性

    - 語言的有效性 還需要檢驗
      1. 無窮空間
      2. 三階空間
         非自由二階代數結構
         和自由三階代數結構
      3. 要能夠表達二階曲面的分類定理
      4. 要能夠表達 product-space 的 boundary-rule

*** 一階的例子 與 covering-space

    - x -
      如果想給出非平凡的一階圖形的例子
      那就一定要考慮無窮圖
      此時無窮個點的生成子就類似於邊
      無窮個邊的生成子就類似於面 [但是可能是不可逆的]
      等等

    - k -
      我想對這些東西的表達很重要
      在考慮這些之前去實現語言
      就是 '過早優化' 了

    - x -
      還要考慮到 我們之前說過
      covering-space 的編碼 能夠解決代數結構中元素的等價問題

*** 之前的語言中對空間的同倫等價的證明

    - x -
      之前的設計中
      爲了證明一些 subdivision 之間的等價
      我們花費了很大篇幅的代碼
      現在我們知道
      這種等價關係也許不應該用空間之間的同倫等價的古典定義來處理

    - k -
      事實上 我們還是不知道應該如何處理空間之間的等價
      subdivision 可以有代數解釋
      它也可以看成是代數結構的細化

    - x -
      combinatorial topology 中用一些基本變換來定義空間之間的同倫等價
      我們是否也應該採取這種定義方式呢 ?

    - k -
      首先來看 subdivision
      我們知道
      用一對函數來定義的倫等價
      可以用來解釋 subdivision 所得到的空間之間的等價
      這甚至不是同倫而是同胚

    - x -
      既然 subdivision 有代數解釋
      函數所定義的等價 對 subdivision 的解釋
      是否也有代數解釋呢 ?
      即 用代數的觀點 來解釋之前的解釋

    ------

    - x -
      我們不能迴避古典的用兩個函數定義空間之間的等價的方法
      我們要試着給出解釋
      subdivision 所給出的 空間之間的兩個函數是特殊的
      其中一個函數是不降階的
      也許這正是區分 同倫 和 同胚 的關鍵

*** refl

    - x -
      我們還沒有考慮 (refl ...) 與一般元素的相乘問題

    - k -
      但是我們現在有了一個指導原則
      那就是 chain 的語法 == 等式組變換的忠實記錄
      在這個指導原則下
      語法的設計應該輕鬆多了
      在需要做決策的時候 我們可以使用這個原則

*** 現在的語法是否已經足夠描述 product-space 的 boundary rule 了 ?

    - fiber-space = dependent product-space

*** 從低維低組合數開始

    - 從低維低組合數開始
      列舉 complex 與 manifold

      給這些列舉以細分
      使得能夠得到 simplicial-complex 而計算 homology group

      對於 2-man 觀察 normalization
      對於 3-man 嘗試 normalization

      對於 2-man 觀察沒有 normalization 的條件下 獲得 universal-covering-space
      對於 3-man 嘗試獲得 universal-covering-space

*** 嘗試以形式化的方式描述 covering-space 與 universal-covering-space

* old

*** simple-space

    - In a language, we always have primitive elements,
      and many ways to compose elements to new compound element,
      also many ways to derive new element from old one.

    - Here, I describe a simple way to construct spaces,
      so constructed spaces will be called simple-spaces,
      which constitute the first kind of primitive space in my language.

      Before having other ways to construct spaces,
      I will simply call them 'space' instead of 'simple-space'.

      - In algebraic topology,
        our simple-space is called
        CW-complex, cell-complex or cellular polytopes.

    - A space is constructed part by part.

    - A part is of certain dimension.

      | dim | name     |
      |-----+----------|
      |   0 | point    |
      |   1 | interval |
      |   2 | disk     |
      |   3 | ball     |
      |   4 | 4-cell   |
      |   n | n-cell   |

    - The way to construct a space from parts,
      goes from low dimension to high dimension,
      by attaching the boundary of a n-cell,
      to a (n-1)-sphere in the space.

      Our principle here is 'construction by attaching boundary'.

    - As an example, let us construct a [solid] tetrahedron.

      - [advice for reader]
        Draw a picture by yourself, when trying to follow
        my formal description.

        And imagining how such picture can be dynamicly
        and automaticly drawn by a drawer that
        accompanies the main interpreter of the language.

      - In 0 dimension,

        we name all the points of the space.

        #+begin_src scheme
        (type space
          (: [a1, a2, a3, a4] (-1 <>)))
        #+end_src

      - In 1 dimension,

        we name all the intervals of the space,

        and for each interval,
        we attach its two end points to two points of the space
        [the two points of the space might be the same point],

        so that the boundary of the interval
        can be viewed as two points of the space.

        #+begin_src scheme
        (type space
          (: [a1, a2, a3, a4] (-1 <>))
          (: b12 (0 a1 a2))
          (: b13 (0 a1 a3))
          (: b14 (0 a1 a4))
          (: b23 (0 a2 a3))
          (: b24 (0 a2 a4))
          (: b34 (0 a3 a4)))
        #+end_src

        For example, the boundary of 'b12' are 'a1' and 'a2',
        the boundary of 'b13' are 'a1' and 'a3'.

        One can view 'b12' as a directed path pointing from 'a1' to 'a2',
        and 'b13' as a directed path pointing form 'a1' to 'a3'.

        We write the two points in the keyword '(0 ...)',
        and the order matters.

        Since, 'b12' and 'b13' have a common boundary -- 'a1',
        we view 'b12' and 'b13' as glued together by the common boundary.

        Our principle here is 'gluing by named common boundary'.

      - In 2 dimension,

        we name all the disk of the space,

        and for each disk,
        we attach its boundary circle to a circle in the space.

        #+begin_src scheme
        (type space
          (: [a1, a2, a3, a4] (-1 <>))
          (: b12 (0 a1 a2))
          (: b13 (0 a1 a3))
          (: b14 (0 a1 a4))
          (: b23 (0 a2 a3))
          (: b24 (0 a2 a4))
          (: b34 (0 a3 a4))
          (: c123 (1 b12 b23 b13 rev))
          (: c124 (1 b12 b24 b14 rev))
          (: c134 (1 b13 b34 b14 rev))
          (: c234 (1 b23 b34 b24 rev)))
        #+end_src

        I use the keyword '(1 ...)' to specify path in the space.

        For example, '(1 b12 b23)' denotes
        the path which goes through 'b12' forwardly and 'b23' forwardly.

        In the keyword '(1 ...)',
        the right end point of one interval must matches
        the left end point of the next interval.

        And '(1 b12 b23 b13 rev)' denotes the path which
        goes through 'b12' forwardly, 'b23' forwardly, and 'b13' backwardly.

        The boundary of 'c123' is attached to the circle '(1 b12 b23 b13 rev)'.

        We check whether a path is a circle,
        by checking whether the left end point of the first interval,
        is equal to the right end point of the last interval,
        i.e. whether the path is closed.

      - In 3 dimension,

        we name all the ball of the space,

        and for each ball,
        we attach its boundary sphere to a sphere in the space.

        #+begin_src scheme
        (type space
          (: [a1, a2, a3, a4] (-1 <>))
          (: b12 (0 a1 a2))
          (: b13 (0 a1 a3))
          (: b14 (0 a1 a4))
          (: b23 (0 a2 a3))
          (: b24 (0 a2 a4))
          (: b34 (0 a3 a4))
          (: c123 (1 b12 b23 b13 rev))
          (: c124 (1 b12 b24 b14 rev))
          (: c134 (1 b13 b34 b14 rev))
          (: c234 (1 b23 b34 b24 rev))
          (: d1234 (2 c123
                      c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary
                      c134 (1 b34 b24 rev b23) as-remained-boundary
                      c234 (1) as-remained-boundary)))
        #+end_src

        I use the keyword '(2 ...)' to specify polygons in the space.
        Note that, a polygon might be obtained by gluing many polygons together.

        For example :
        #+begin_src scheme
        (2 c123)
        ;; a polygon in a stack

        (2 c123
           c124)
        ;; two polygons in the stack

        (2 c123
           c124 (1 b14 b24 rev b23 b13 rev))
        ;; two polygons and a circle in the stack

        (2 c123
           c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary)
        ;; 'as-remained-boundary' is a function,
        ;;   which takes two polygons and a circle out from the stack,
        ;;   try cancel out part of the common boundary of 'c123' and 'c124',
        ;;   so that the remained boundary can be '(1 b14 b24 rev b23 b13 rev)'.
        ;; if there are no way or more then one way to do this,
        ;;   it reports to the user.
        ;; if there is only one way to do this,
        ;;   it puts a polygon back to the stack,
        ;;   whose boundary is '(1 b14 b24 rev b23 b13 rev)'.
        #+end_src

        The boundary of 'd1234' is attached to the sphere :
        #+begin_src scheme
        (2 c123
           c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary
           c134 (1 b34 b24 rev b23) as-remained-boundary
           c234 (1) as-remained-boundary)
        #+end_src

        We check whether a polygon is sphere [closed polygon],
        by checking whether the polygon is
        2-dimensional, closed, connected and orientable.

        Note that, we can implement more functions like 'as-remained-boundary',
        to help us get 2-dimensional polygons.

    - Note that, syntax in (0 ...) (1 ...) (2 ...) are different,
      but syntax in (2 ...) (3 ...) (4 ...) ... are similar.

      - (0 ...) is special, in the sense that,
        only two 0-dimensional points can occur in it.

      - (1 ...) is special, in the sense that,
        there is not explict functions, like 'as-remained-boundary' in it.

      - [hesitation about syntax]
        Should these three distinctions be unified ?
        If these distinctions are really meaningful,
        and ought not to be unified,
        Should we design distinct syntaxes for them,
        to maintain the distinctions,
        instead of using the seemingly unified syntax ?

    - Note that, 'as-remained-boundary' involves searching,
      which makes the specification of part of the space implict,
      such implicitness is need, for when the dimension gets higher,
      the detail of high dimension information might be too complex
      to use an explict method.

    - [hesitation about cobordism]
      Note that, not all closed spaces
      can be boundary of a 1-dim higher space.
      if two disjoint closed spaces, B1 and B2, are boundary of
      1-dim higher space C, then C is the cobordism of B1 and B2,
      classically expressed as (C; B1, B2),
      where B1 and B2 are called cobordant.

      Under what conditions, a closed space can be
      the boundary of a 1-dim higher space ?
      This question should be thoroughly understood,
      before developing the formal semantics of the language.

    - [summary of principles]
      - [principle 1] construction by attaching boundary
      - [principle 2] gluing by named common boundary

*** >< indexed-space

    - When defining a space, parts of it can be indexed
      by parts of another space.
      Such a named indexing of parts is called an index,
      which is also a subspace of the larger space.

    - Note that,
      if the indexing is to be viewed as a map,
      it would be a level-up map.

    - rule for indexed space [? cellular]

    - 'I' indexed by a space,
      is the suspension of the space.

    - While 'I' is 1-cell,
      how about 2-cell 3-cell and n-cell ?
      how about continuum other then n-cell ?
      note that, n-cell indexed by a space 'A',
      is specified by (-> A [n-cell boundary])

*** >< fiber-space

    - To view product-space as special fiber-space,
      for which a gluing pattern is given.

    - After a construction of a fiber-bundle,
      we can proof the total-space is equal to another space,
      and by doing so, we get a level-down map from the space to the base-space.

    - A level-down map can only be achieved by means of fiber-bundle.

*** >< lifting-problem

    - A lifting-problem is expressed for a [?] on a fiber-space.

    - [lifting-problem and cross-section-problem]
      cross-section-problem can be viewed as
      lifting a subspace [instead of function] of the base-space,
      or just lifting the base-space itself [i.e. global cross-section].

*** >< homotopy theory

    - x -
      homotopy group 被定義爲帶有代數結構的 mapping-space
      但是 對我們來說
      我們可以直接說它是 combinatorial group theory

    - k -
      也許 mapping-space 是必要的
      考慮高維的情形就知道了

    - x -
      不想用 mapping-space
      是因爲與 combinatorial theory 相比
      這種空間的生成元和關係不明顯

    - k -
      我們可以考慮 在低維的情形
      mapping-space 的代數結構如何獲得生成元與關係
      然後再推廣到高維

* note

*** intro

    - topology, or at least combinatorial topology,
      give raise to algebraic topology,
      the aim of which is to find
      algebraic structures as invariants of topology space.

      my argument is that combinatorial topology it self
      can be viewed as an higher algebraic structure,
      finding different algebraic invariants
      of a combinatorially defined topology space
      is to simplify the higher algebraic structure in different ways.

    - 組合羣論中說羣是由生成子和關係展示的
      其實這裏所說的關係都是特殊的關係 即 等式
      在我的語言中 我強調這一點
      並且給等式的方向以解釋

    - my aim is to provide a language in which
      all the phenomena of algebraic topology can be expressed and explained.

    - [並非劃歸 圖形是必要的]
      在觀察這些從圖形得到的代數結構時
      我們不能脫離對這些圖形的想象本身
      因爲不藉助這些圖形來處理
      等式的兩種恆等變形之間的等價
      是難以想象的

    - [recover geometry]
      am i to reduce topology to algebra ?
      by no means, since topology, as and reduction of geometry,
      relies on geometry;
      so will my higher algebraic structure relies on geometry.

*** 之前的錯誤在於沒有考慮定向 [現在知道定向就是等式的方向]

    - 一個 disk 或 ball 的邊界多種表示方式
      當圖形作爲代數結構中的元素而自乘時
      之前的想法是
      只要有公共公共邊界就可以相乘
      其中某種相乘 被認爲是 same-position-self-gluing
      這種相乘將消除一對元素

      現在知道必須把這些
      作爲 disk 或 ball 的邊界的 circle 或 sphere
      所形成的 close chain
      理解爲等式
      等式是有固定方向的
      這個方向對應於 disk 或 ball 的定向
      多種表示方式和相乘方式 = 等式的恆等變換
      允許 左右兩邊的移項 這種恆等變換
      但是 當改變等式的方向的時候 必須要給出明顯的記錄
      因此 same-position-self-gluing 不能理解爲簡單的自乘了
      而應該被理解爲取反向之後的相乘
      想要相消 必須是 (+ A -A) 而不能是 (+ A A)
      這樣 有關相消的信息就被明顯地表達出來了

*** 代數結構

    - [generator and chain]
      chain 是代數中的元素
      即 生成子的複合
      這裏所考慮的 chain 不是交換的

    - [boundary operator]
      組成 chain 的元素可能屬各個層次
      層次之間有 boundary 算子
      邊界爲空的 chain 是閉的

    - [adding generator as adding equation to free algebraic structure]
      disk 與 ball 是 chain 所形成的等式

    - [generator 的複合 就是 等式的融合]
      disk 與 ball 在 glue 下形成 二階或者三階 chain
      這種 glue 記錄了 一階或二階等式之間的融合 [或者形成等式組]

    - [語法難點]
      假設我們的語法是線性的
      - 一階代數中
        | 非閉合元素 | line segment | 有唯一的表達方式 |
        | 閉合元素   | circle       | 有很多表達方式   |
        | 等式       | circle       | 有很多表達方式   |
      - 二階代數中
        | 非閉合元素 | sphere with holes [disk = sphere with one hole] |
        | 閉合元素   | sphere                                          |
        | 等式       | sphere                                          |

    - [等式可以用來 rewrite chain]
      用一個等式去變換一個 chain
      利用等式來做 rewriting
      這種 rewriting 可以看成是函數的同倫
      因爲 空間 A 中的 chain 可以看成是某個空間 X 嵌入 A
      (: f (-> X A))

      如何區分 同倫變換 與 同痕變換 與 外在同痕變換

      如果這樣想
      我們就是在用高階代數中的元素[chain]來取代函數
      高階代數中的元素的性質 就反映了 空間 X 的性質
      二者之間應該有嚴格的對應

      有了函數之間的同倫等價
      那麼空間之間的同倫等價如何呢 ?
      [即 hauptvermutung 問題]

    - [同倫時維數變化的代數解釋]
      每個元素本身都蘊含着一個平凡的等式
      那就是 其與自身相等

*** 高階代數結構

    - x -
      不用過多地考慮古典的 hauptvermutung
      其實我們現在已經有了不錯的理解函數之間同倫的方式
      重要的是找到在我們的語言中解釋空間之間的等價的方式
      [其定義可能有別於 Hurewicz 的 homotopy-equivalence]
      我們要找在我們的語言中自然的等價關係
      然後看看這個等價關係在更古典的語言中的解釋

      函數空間 (-> A B) 就是 B 的具有特殊性質的 chain 的空間
      對於函數空間之間的等價
      我們也是不知道該如何定義的
      我們目前知道的只是
      元素之間的等價 和 函數之間的等價
      這二者都可以說是一階的等價

    - k -
      我想 對於空間之間的等價關係而言
      公共細分所定義的等價關係就已經夠了
      細分是有代數解釋的 [考慮 group 被細分爲 group]
      並且 把類型當作數據的時候
      細分也可以用函數來實現 [考慮二維流形的分類定理]

    - x -
      如果這樣說的話 我們其實是在用 hauptvermutung
      但是我們不知道古典意義上的 hauptvermutung 的意義是什麼
      我們不知道 爲什麼 hauptvermutung 是需要證明的
      低維時這個定理是如何被證明的 ?
      高維是這個定理爲什麼會被否定 ?
      四維時爲什麼還沒有結果 ?
      當證明 hauptvermutung 的時候 我們證明的是什麼 ?
      其構造性如何 ?
      - 既然在高維這個定理可以被否定
        那麼就是說 有另外一種定義空間之間的等價的方式
        並且在高維的時候
        這種定義 比 公共細分所做的定義 帶有的信息要多

    - k -
      但是我們也要明白
      如果採用這種方式的話
      我們就離開了同倫
      而回到了對同胚研究
      維數之間不能有變化了

    - x -
      首先 跨越維數的映射
      在我們的語言中本來就是不自然的
      其次 從等式的角度看 維數的變化也是可以解釋的
      因爲對等式的平凡的恆等變形也算是恆等變形

    - k -
      我們還需要考慮如何定義函數空間之間的等價關係

    - x -
      如果我能找到一個高階代數結構之間的等價關係
      使得它介於同倫與古典的同胚之間
      我就能證明高階同倫羣是不重要的了
      因爲同倫羣所帶有的信息
      就是同倫等價所需要的所有信息

    - k -
      首先我們已經有代數結構的細分了
      如果想要定義更強的等價
      就要允許更多的對代數結構的變換
      還有什麼可以允許的呢 ?

    - x -
      可能這種想法太刻意了
      不如想想能夠如何模仿 homology group
      來給我們的高階代數結構做去類型化與交換化
      我們可以試着找出同調羣無法區分的空間
      然後以新的方式弱化代數結構
      使得如此獲得的代數結構之間的同構問題可解
      並且能夠區分那些同調羣無法區分的空間

    - k -
      如果我們的理論與語言有效的話
      我們應該能自己構造出很多這種空間
      不用 knot 而用 polyhedron

*** 計數

    - x -
      語法和語義之間的關係在於
      多種語法可以描述同樣的數據

      [問題 1]
      當以一種語法描述出數據之後
      根據數據本身 可以生成出
      所有可能的描述這個數據的語法
      試着做一些窮舉
      然後看看有沒有正規形式

      [問題 2]
      如果要用有向圖來實現這些數據
      那麼如何判斷兩個數據是否相等呢 ?

    - k -
      我發現
      只要能想象出圖形
      就是能在程序語言中用數據結構實現它們
      因此 '語義' 一詞
      就機器實現而言
      也就人的想象而言

*** 等價

    - x -
      an equation is the boundary of a chain
      a chain is the record of the formation of an equation

      用等式進行 rewrite = chain 之間的同倫
      等式可能是 (refl ...) 經過移項得到的
      這樣
      這種等式稱作是非本質的 它們所給出的變換也稱作是非本質的

      一個 n+1 階 chain 是一個 n 階等式
      這個等式本身也可以給以移項變換

*** fiber

    - x -
      高於維數階的同倫羣
      也許只能被理解爲 fiber-space
      而不能被理解爲 chain group

*** function as chain group

    - x -
      此時 function 的同倫變換就按古典的定義
      (-> (* X I) Y)
      但是如何把它 與 chain 的同倫變換相容呢 ?
      後者是 用等式進行轉寫

*** 同倫類

    - x -
      mobius-band 與 cylinder 有相同的同倫類型
      但是 它們的二階代數結構不同

      mobius-band 的非平凡二階元素只有一個
      cylinder 的非平凡二階元素於整數對應

    - k -
      但是 我們如何定義代數結構之間的等價來形成空間的代數不變量呢 ?

    - x -
      對於上面兩個例子
      首先我們發現 相乘方式是固定的
      這就類似於古典的代數結構
      我們需要更多的例子

* 一維自由代數結構 / 1 dimensional free algebraic structure

  - 首先我們有很多點
    點之間有很多被標記以方向的邊 稱爲有向邊
    我們可以認爲這樣一個圖是一個代數結構 稱爲 free-groupoid
    有向邊爲生成子
    生成子相乘可以得到這個代數中的一般元素

    代數的元素之間有等式
    比如平凡的等式 (= a a)

    沿着一條有向邊走 過去又馬上走回來 就等同於留在原地
    這樣我們就得到了一個看似非平凡的等式 (= (+ a (- a)) (+))
    我們可以說這是一種消去
    當 (+ a (- a)) 出現時它們可以被消除

    但是我們發現 (= a a) 與 (= (+ a (- a)) (+)) 其實是同一個等式
    因爲經過移項 二者之間可以相互轉化
    這就是等式的恆等變形

    或者我們可以說
    對於代數中的每個元素
    我們都能形成平凡的等式
    #+begin_src scheme
    (: (refl a) (= a a))
    (: (refl (+ a b)) (= (+ a b) (+ a b)))
    #+end_src

    我們還可以利用移項來對這些等式進行恆等變形
    即 基本恆等變形
    #+begin_src scheme
    (: (refl a) (= a a))
    (: (+ (refl a) (=> a)) (= (+ a (- a)) (+)))
    (: (+ (refl a) (=< a)) (= (+ (- a) a) (+)))
    (: (+ (refl a) (>= a)) (= (+) (+ a (- a))))
    (: (+ (refl a) (<= a)) (= (+) (+ (- a) a)))
    #+end_src

    一般的規則如下
    #+begin_src scheme
    (: =< (-> [<::> = <::>] [(- <:) <::> = :>]))
    (: => (-> [<::> = <::>] [<::> (- :>) = <:]))
    (: <= (-> [<::> = <::>] [:> = (- <:) <::>]))
    (: >= (-> [<::> = <::>] [<: = <::> (- :>)]))

    (: =< (-> (= (+ <: :>)
                 (+ <: :>))
              (= (+ (- <:) <: :>)
                 (+ :>))))

    (: => (-> (= (+ <: :>)
                 (+ <: :>))
              (= (+ <: :> (- :>))
                 (+ <:))))

    (: <= (-> (= (+ <: :>)
                 (+ <: :>))
              (= (+ :>)
                 (+ (- <:)) <: :>)))

    (: >= (-> (= (+ <: :>)
                 (+ <: :>))
              (= (+ <:)
                 (+ <: :> (- :>)))))
    #+end_src

    我們可以說這些是同一個元素
    只不過我們用來表達這些元素的語言是線性的
    所以對同一個元素 產生了不同的表達方式
    當把形式語言實現爲程序語言的時候
    我們可以寫一些檢查器
    來幫助我們判斷 某些式子是否是同一個東西的不同表達方式

    等式可以用來轉寫代數結構中的元素
    平凡的等式 和 平凡的等式經過移項變形而得到的等式
    所形成的轉寫都是平凡的
    這些轉寫不用記錄 直接讓機器處理就好

    - 也就是說我們可以自由的消去相鄰的互逆的元素
      但是這是不應該被允許的
      因爲 消去互逆的項與否 整個 chain 的邊界就改變了
      而 chain 要能被看作是 對邊界之成爲當前這樣的邊界 的忠實記錄
      邊界就是等式組 chain 是對等式組的變換的記錄

    - 但是如果這些平凡的轉寫不能讓機器自動處理
      那麼表達移項的語法可能就非常複雜了

    - 之所以這樣說是因爲
      把移項理解爲了 先在等式兩邊同時乘以某個元素
      然後再消去相鄰的項
      (a b = c)
      (a b -b = c -b)
      (a = c -b)
      只要拋棄這種觀點就行了

    - 核心的想法是
      chain 的語法是對等式組變換的忠實記錄
      即 所有關於變化的信息 都要被明顯的語法表達出來

    說這個代數結構是 free-groupoid
    說其 'free' 就在於除了這些利用 'refl' 生成的平凡等式之外
    沒有別的等式了

* 一維非自由代數結構  / 1 dimensional non-free algebraic structure

  - 添加一些別的等式 free-groupoid 就變成了 groupoid
    首先我們發現 (= (+ b0 b1) (+ b1 b0))
    是不能由平凡等式經過基本恆等變形來得到的
    我們可以把這個等式添加到我們的代數結構中來
    #+begin_src scheme
    (: c0 (= (+ b0 b1) (+ b1 b0)))
    #+end_src

    添加的時候給以了名字
    每次想要使用這個等式的時候
    我們就用這個名字做記錄

    我們還可以再添加一個
    #+begin_src scheme
    (: c1 (= (+ b0 b1) (+ b1 b0)))
    #+end_src
    雖然二者作爲等式是相同的
    但是在用於轉寫時
    二者的性質可能不同
    比如 二者消耗的能量可能不是一個數量級的
    或者 二者消耗的能源類型不同
    或者 二者消耗的時間不是一個數量級的

    比如我們還可以引入
    #+begin_src scheme
    (: c (= b0 b0))
    #+end_src
    雖然它的作用效果是平凡的
    但是它與平凡的等式 (refl b0) 是不同的

    我們假設每個這樣的引入
    所引入的都是與之前等式不同的新等式

    我們可以想象 (+ b0 b1) 是某個分子結構
    我們發現了一種物質 c0 利用這個物質 和某種處理方式
    我們能把 (+ b0 b1) 變成 (+ b1 b0)
    之後我們又發現了 另一種類似的物質 c1 也有類似的效果
    等等

    這樣等式對元素所做的變化 就能被實體化
    動詞的名詞化 就是爲了記錄
    爲了能夠把動詞所代表的變化當作名詞一樣來處理
    反向的等式就是反物質
    等等

    這些等式也可以用來轉寫一階代數結構中的元素
    這些等式也可以進行移項這種恆等變形
    如果只在乎把 (+ b0 b1) 變爲 (+ b1 b0)
    那麼使用 c0 和 c1 那個都無所謂

    並且我們可以把兩個等式融合來得到新的等式
    我們要設計語法來記錄等式的融合
    並且 融合兩個等式之後再作用 與 相繼的作用兩個等式 必須是等價的

* 類比化學語言

  - 我們可以把上面的類比加以系統發展
    用以理解高階代數中的現象

    物質
    物質之間的轉化
    轉化是利用高階的物質完成的
    反物質
    等等

* 二階空間

  - 我們發現
    1. 等式有逆元素
    2. 兩個等式如果有相同的元素
       就可以利用元素代入來將兩個等式融合爲一個
       這種融合就像是代數結構中的乘法

    這樣我們就有了一個二階的代數結構 稱其爲 2-complex
    我們可以把一階時候的術語統一一下
    稱之前的 free-groupoid 爲 1-complex
    這樣 1-complex 之 'free' 就在於 其中沒有非平凡二階元素

    就像一階情形一樣
    首先我們要找到 基本恆等變形
    這些恆等變形 當然就是 (refl c0) 之類的平凡等式 經過移項獲得的
    我們需要設計語法來描述這些信息

* 選取例子以驗證語言的有效性

*** intro

    - 邊數很少的 polygon
      面數很少的 polyhedron
      的所有可能
      然後以它們爲基礎看各種算法作用於它們的效果

    - 用正多面體來形成簡單的例子
      對稱性越強的圖形
      編碼所用的信息就越少

    - 那麼這首先將引出一個計數問題
      通過計數我們可以估計問題的複雜性
      首先我們要確定
      有多少由 n-gon 或 n-hedron 構造 manifold 的方式

*** >< how to enumerate n-gon and n-hedron ?

    - ><

*** 2-complex formed by gluing the edges of one n-gon together

***** 2-gon

      #+begin_src scheme
      (type space
        (: a0 a1 <>)
        (: b0 b1 (= a0 a1))
        (: c0 (= b0 b1)))

      (note glue b1 to b0)

      (type space (note S2)
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: c0 (= b0 b0)))

      (note glue a1 to a0)

      (type space (note pseudo-manifold)
        (: a0 <>)
        (: b0 (= a0 a0))
        (: c0 (= b0 b0)))

      (note cut b0 to b0 and b1)

      (type space
        (: a0 <>)
        (: b0 b1 (= a0 a0))
        (: c0 (= b0 b1)))

      (note glue b1 to (- b0))

      (type space (note projective space)
        (: a0 <>)
        (: b0 (= a0 a0))
        (: c0 (= b0 (- b0))))
      #+end_src

***** cut 和 glue

      - x -
        施行上面這個 cut 和 glue 操作的條件是什麼 ?
        雖然這些操作是不同胚的
        但是也應該把它們加到語言中來

      - k -
        在窮舉 n-gon 所形成的 complex 的時候
        cut 與 glue 這兩個操作可以形成一個 complex 之間的有向圖

***** the neighborhood function

      #+begin_src scheme
      (define S2
        (type space
          (: a0 a1 <>)
          (: b0 (= a0 a1))
          (: c0 (= b0 b0))))

      (topological-equivalent
       (neighborhood S2/a0)
       (type neighborhood-space
         (: b0 <>)
         (: c0 (= b0 b0))))

      (define PS2
        (type space
          (: a0 <>)
          (: b0 (= a0 a0))
          (: c0 (= b0 b0))))

      (topological-equivalent
       (neighborhood PS2/a0)
       (type neighborhood-space
         (: b0 <>)
         (: (- b0) <>)
         (: c0 (= b0 b0))
         (: (+ c0 (=< b0) (>= b0)) (= (- b0) (- b0)))))
      #+end_src

***** >< 4-gon

      #+begin_src scheme

      #+end_src

*** 3-complex formed by gluing the faces of one n-hedron together

***** ><

      #+begin_src scheme
      (type space
        ()
        )
      #+end_src

* 二維空間的例子

*** mobius-band

    #+begin_src scheme
    (define mobius-band
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a0))
        (: b2 (= a0 a1))
        (: c0 (= (+ b0 b1) (+ b2 (- b0))))))

    (: c0                   (= (+ b0 b1) (+ b2 (- b0))))
    (: (+ c0 (=< b2))       (= (+ (- b2) b0 b1) (- b0)))
    (: (- c0)               (= (+ b2 (- b0)) (+ b0 b1)))
    (: (+ (- c0) (<= b2))   (= (- b0) (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          (- c0) (<= b2))
       (= (+ (- b2) b0 b1) (+ (- b2) b0 b1)))

    (: (refl c0)
       (= c0
          c0))

    (: [(refl c0) (=> c0)]
       (= (+ c0 (=< b2)
             (- c0) (<= b2))
          (+)))
    #+end_src

*** cylinder

    #+begin_src scheme
    (define cylinder
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a1))
        (: b2 (= a0 a0))
        (: c0 (= (+ b0 b1) (+ b2 b0)))))

    (: c0                   (= (+ b0 b1) (+ b2 b0)))
    (: (+ c0 (=< b2))       (= (+ (- b2) b0 b1) b0))
    (: (+ c0 (>= b1))       (= b0 (+ b2 b0 (- b1))))

    (: (- c0)               (= (+ b2 b0) (+ b0 b1)))
    (: (+ (- c0) (<= b2))   (= b0 (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          (- c0) (<= b2))
       (= (+ (- b2) b0 b1)  (+ (- b2) b0 b1)))

    (: (+ c0 (=< b2)
          c0 (>= b1))
       (= (+ (- b2) b0 b1) (+ b2 b0 (- b1))))

    (define dehn-twist
      (lambda (-> cylinder cylinder)
        (-> a0 a0)
        (-> a1 a1)
        (-> b1 b1)
        (-> b2 b2)
        (-> b0 (+ b0 b1))
        (-> c0 (:> (= (+ b0 b1) (+ b2 b0)))
            (+ (+ c0 (=< b2) (=< b0) (:> (= (+ (- b0) (- b2) b0 b1) (+)))
                  (refl b1) (>= b1) (:> (= (+) (+ b1 (- b1)))))
               (:> (= (+ (- b0) (- b2) b0 b1)
                      (+ b1 (- b1))))
               (<= (- b0)) (<= (- b2)) (=> (- b1))
               (:> (= (+ b0 b1 b1) (+ b2 b0 b1)))))))

    (define dehn-twist
      (lambda (-> cylinder cylinder)
        (-> a0 a0)
        (-> a1 a1)
        (-> b1 b1)
        (-> b2 b2)
        (-> b0 (+ b0 b1))
        (-> c0 (+ (+ c0 (=< b2) (=< b0) (refl b1) (>= b1))
                  (<= (- b0)) (<= (- b2)) (=> (- b1))))))

    (note 可以發現這種嚴格的移項語法太複雜了
          對於代入以融合等式而言
          我們只需要指出
          (1 就那個元素代入)
          (2 就那個位置代入))

    (note 但是我們至少有了一種有效的底層語法
          也許這些高層的語法可以被實現爲二元函數
          [移項都是一元函數])

    (note 我們是否已經得到了最細的底層語法 ?)

    (note (+ c0 (refl b1)) 與 c0 是否是相等的 ?
          我想應該是不相等的
          因爲它們是 2 階 chain
          而沒有三階 等式能夠把其中的一個轉化爲另一個
          因爲這裏有的只是三階的非本質等式
          比如 (: (refl (refl b1)) (= (refl b1) (refl b1)))
          它是不能消去 (refl b1) 的
          假設有消去 (refl b1) 的等式 x
          那麼它的就是 (: x (= (refl b1) (+)))

          沒有等式來轉寫它們
          它們就不同倫等價)
    #+end_src

*** sphere

    #+begin_src scheme
    (define sphere
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: c0 (= b0 b0))))

    (define sphere
      (type space
        (: a0 a1 a2 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a2))
        (: c0 (= (+ b0 b1) (+ b0 b1)))))
    #+end_src

*** solid-tetrahedron

    - the following description will break
      the beautiful symmetry of solid-tetrahedron,
      only by this way,
      can we express each symmetry by a homeomorphism
      from the solid-tetrahedron to itself.

    #+begin_src scheme
    (define solid-tetrahedron
      (type space
        (: a0 a1 a2 a3 <>)
        (: b01 (= a0 a1))
        (: b02 (= a0 a2))
        (: b03 (= a0 a3))
        (: b12 (= a1 a2))
        (: b13 (= a1 a3))
        (: b23 (= a2 a3))
        (: c012 (= (+ b01 b12) b02))
        (: c123 (= (+ b12 b23) b13))
        (: c013 (= (+ b01 b13) b03))
        (: c023 (= (+ b02 b23) b03))
        (: d1234
           (= (+ (- c012) (=< b01)
                 c123 (>= b23)
                 (<= (- b01))
                 (=> (- b23)))
              (+ (- c013)
                 c023 swap))
           (note
             (= (+ (- c012) (=< b01)
                   (:> (= (+ (- b01) b02) b12))
                   c123 (>= b23)
                   (:> (+ (= (+ (- b01) b02) b12)
                          (= b12 (+ b13 (- b23))))
                       (= (+ (- b01) b02) (+ b13 (- b23))))
                   (<= (- b01))
                   (=> (- b23))
                   (:> (= (+ b02 b23) (+ b01 b13))))
                (+ (- c013)
                   (:> (= b03 (+ b01 b13)))
                   c023 swap
                   (:> (+ (= (+ b02 b23) b03)
                          (= b03 (+ b01 b13)))
                       (= (+ b02 b23) (+ b01 b13)))))))))
    #+end_src

* ><><>< map, product-space, equivalent between maps

*** map and continuity-check

    - For level-same maps, the rule for continuity-check is simple.
      Suppose we have map (: f (-> A B)),
      and 'p' is a n-dim part of 'A'.

      continuity-check is simply
      #+begin_src scheme
      (= [p f boundary] [p boundary f])
      ;; or
      (: [p f] [p boundary f])
      #+end_src

      i.e. how the boundary of 'p' is mapped to 'B' by 'f',
      will constrain how 'p' can be mapped to 'B' by 'f'.

    - Since a map has many levels.

    - 兩個空間 A B 之間的映射可以被理解爲
      B 中的一組 chain
      其中每個 chain 被 A 中的生成子命名
      並且生成子的邊界給 B 中的這一組 chain 的選取加以了限制

    - 也可以被理解 aristotle 對連續體的解釋

    - 映射的複合
      ><><><

    - 映射是一个 limited chain
      映射之間的同倫是 等式對 limited chain 的轉寫

    - x -
      某個函數可以看成是
      限制對 chain 所施行的代數操作
      這類似於羣的同態定理

      考慮羣同態 (: f (-> G1 G2))
      (~~ (/ G1 (ker f)) (img f))

      考慮連續函數 (: f (-> A B))
      它被理解爲 B 中的 chain
      但是 A 的形式限制了 chain 的性質
      並且 (ker f) 是 A 中那些被放棄不用的 對 chain 的限制
      [有很多的限制方式 但是我放棄使用其中一些]

*** product-space

    #+begin_src scheme
    (note There can be many ways by which we can compose new spaces,
          each of such way must shows
          1. what are the parts of the space ?
          2. what are the boundarys of the parts ?)

    ;; the rule of product-space
    (: (* a b) (= (* a boundary b) (* a b boundary)))

    (define I
      (type space
        (: i0 i1 <>)
        (: i01 (= i0 i1))))

    (: (* i01 i0)
       (+ (* i01 boundary i0)
          (* i01 i0 boundary))
       (:>
        (+ (* (= i0 i1) i0))
        (+ (= (* i0 i0) (* i1 i0)))))

    (: (* i01 i01)
       (+ (* i01 boundary i01)
          (* i01 i01 boundary))
       (:>
        (+ (* (= i0 i1) i01)
           (* i01 (= i0 i1)))
        (+ (= (* i0 i01) (* i1 i01))
           (= (* i01 i0) (* i01 i1)))
        (= (+ (* i0 i01) (* i01 i1))
           (+ (* i01 i0) (* i1 i01)))))


    (: (* i01 i0) (= (* i0 i0) (* i1 i0)))
    (: (* i1 i01) (= (* i1 i0) (* i1 i1)))
    (: (* i01 i1) (= (* i0 i1) (* i1 i1)))
    (: (* i0 i01) (= (* i0 i0) (* i0 i1)))
    (: (* i01 i01) (= (+ (* i01 i0) (* i1 i01))
                      (+ (* i01 i1) (* i0 i01))))


    (note A function of type (-> (* I I) X)
          can be defined as follow)

    (define f
      (lambda (-> (* I I) X)
        (with (-> (* (-1 I) (-1 I)) (-1 X))
          (-> (* i0 i0) ...)
          (-> (* i0 i1) ...)
          (-> (* i1 i0) ...)
          (-> (* i1 i1) ...))
        (with (-> (* (0 i0 i1) (-1 I) %:i)
                  (0 (* i0 :i) <>
                     (* i1 :i) <>))
          (-> (* (1 i01) i0) ...)
          (-> (* (1 i01) i1) ...))
        (with (-> (* (-1 I) %:i (0 i0 i1))
                  (0 (* :i i0) <>
                     (* :i i1) <>))
          (-> (* i0 (1 i01)) ...)
          (-> (* i1 (1 i01)) ...))
        (with (-> (* (0 i0 i1) %:p0
                     (0 i0 i1) %:p1)
                  (1 (* (1 :p0) i0) <>
                     (* i1 (1 :p1)) <>
                     (* (1 :p0) i1) <> rev
                     (* i0 (1 :p1)) <> rev))
          (-> (* (1 i01) (1 i01)) ...))))

    (define f
      (lambda (-> (* I I) X)
        (with (-> (* (-1 I) (-1 I)) (-1 X))
          (-> (* i0 i0) ...)
          (-> (* i0 i1) ...)
          (-> (* i1 i0) ...)
          (-> (* i1 i1) ...))
        (with (-> (* (= i0 i1) (-1 I) %:i)
                  (= (+ (* i0 :i) <>)
                     (+ (* i1 :i) <>)))
          (-> (* i01 i0) ...)
          (-> (* i01 i1) ...))
        (with (-> (* (-1 I) %:i (= i0 i1))
                  (= (+ (* :i i0) <>)
                     (+ (* :i i1) <>)))
          (-> (* i0 i01) ...)
          (-> (* i1 i01) ...))
        (with (-> (* (= i0 i1) %:p0
                     (= i0 i1) %:p1)
                  (= (+ (* :p0 i0) <>
                        (* i1 :p1) <>)
                     (+ (* :p0 i1) <>
                        (* i0 :p1) <>)))
          (-> (* i01 i01) ...))))
    #+end_src

*** note

    - x -
      1. 元素和元素的乘積 記以 (* a b)
      2. 乘積的邊界公式爲 (+ (* [a boundary] b) (* a [b boundary]))
      3. [a boundary] 是一個等式 而 b 是一個 chain

      因此我們需要 等式 與 chain 相 product
      但是如果簡單地把 (* ...) 分配給等式的兩邊
      所得到的等式就不滿足等式的條件了

    - k -
      所以邊界公式是錯誤的
      正確的格式應該是 (: (* a b) (= (+ ...) (+ ...)))
      但是我們不能直接用 [a boundary]
      而應該有函數[或語法]來取 [a boundary] 的等式的左右兩邊

    - x -
      #+begin_src scheme
      (: (* a b) (= (+ (* (lhs a) b) (* a (rhs b)))
                    (+ (* a (lhs b)) (* (rhs a) b))))
      ;; thus
      (: (* i01 i01)
         (= (+ (* (lhs i01) i01) (* i01 (rhs i01)))
            (+ (* i01 (lhs i01)) (* (rhs i01) i01)))
         (= (+ (* i0 i01) (* i01 i1))
            (+ (* i01 i0) (* i1 i01))))
      #+end_src

      但是
      與其說這是一個一般的邊界公式
      不如說這是專門描述 (* i01 i01) 的邊界的

    - k -
      #+begin_src scheme
      (: (* (* i01 i01) i01)
         (= (+ (* (lhs (* i01 i01)) i01) (* (* i01 i01) (rhs i01)))
            (+ (* (* i01 i01) (lhs i01)) (* (rhs (* i01 i01)) i01)))
         (= (+ (* (+ (* i0 i01) (* i01 i1)) i01) (* (* i01 i01) i1))
            (+ (* (* i01 i01) i0) (* (+ (* i01 i0) (* i1 i01)) i01)))
         (= (+ (* i0 i01 i01) (* i01 i1 i01) (* i01 i01 i1))
            (+ (* i01 i01 i0) (* i01 i0 i01) (* i1 i01 i01))))

      (: (* i01 (* i01 i01))
         (= (+ (* (lhs i01) (* i01 i01)) (* i01 (rhs (* i01 i01))))
            (+ (* i01 (lhs (* i01 i01))) (* (rhs i01) (* i01 i01))))
         (= (+ (* i0 (* i01 i01)) (* i01 (+ (* i01 i0) (* i1 i01))))
            (+ (* i01 (+ (* i0 i01) (* i01 i1))) (* i1 (* i01 i01))))
         (= (+ (* i0 i01 i01) (* i01 i01 i0) (* i01 i1 i01))
            (+ (* i01 i0 i01) (* i01 i01 i1) (* i1 i01 i01)))
         ;; different from
         (= (+ (* i0 i01 i01) (* i01 i1 i01) (* i01 i01 i1))
            (+ (* i01 i01 i0) (* i01 i0 i01) (* i1 i01 i01))))
      ;; thus (* ...) is not associative
      #+end_src

    - x -
      我們需要仔細對比 (* (* I I) I) 與 (* I (* I I))
      因爲上面的二階 (+ ...) 中沒有二階元素相乘細節

      也許這種語法是不對的
      也許我的想法錯了

      但是
      想象一下這樣一個語言
      它可以用來描述拓撲空間
      可以把這些空間當成數據來處理
      可以把這些空間當成類型而取其中的元素
      等等
      我不可能放棄這樣一個語言

    - k -
      但是沒有 (+ ...) 的細節是不行的
      對於一階元素可以 但是對於二階元素不行
      想要得到一個一般的乘積元素的邊界規則
      我們就要生成 (+ ...) 的細節

*** extension-problem

    - An extension-problem is expressed for a partial-map on a subspace.

    - To solve an extension-problem
      is to extend a partial map to a total-map step by step,
      while maintain the continuity of the map.

    - A partial-map is a map defined on subspace of a space.

    - The subspace relation between spaces is encoded by parts.

    - Suppose 'A' is a subspace of 'X'
      the following is to extend a partial-map 'g'
      to a total-map 'f'
      #+begin_src scheme
      (let ([g (lambda (-> A Y) ...)])
        (define f
          (lambda (-> X Y)
            (extend-from g)
            ...)))
      #+end_src

*** equality

    - With product-space and extension-problem,
      we can define equality between two functions
      as the extension-problem for certain kind of product-space.

    - Suppose (: [f0, f1] (-> A B)),
      to proof (~ f0 f1),
      we need to extend a partial-map of type (-> (* A I) B)
      #+begin_src scheme
      (let ([f0 (lambda (-> A B) ...)]
            [f1 (lambda (-> A B) ...)])
        (lambda (-> (* A I) B)
          (extend-from
            (lambda (-> (* A (list i0 i1)) B)
              (-> (* :a i0) [:a f0])
              (-> (* :a i1) [:a f1])))
          ...))
      #+end_src

    - With the equality between functions,
      we can define the equality between space.

    - Suppose 'A' and 'B' are two spaces,
      to proof (~~ A B),
      is to find (: f (-> A B)) and (: g (-> B A))
      and to proof (~ [f g] [A id]) and (~ [g f] [B id])
      #+begin_src scheme
      (lambda (-> (* A I) A)
        (extend-from
          (lambda (-> (* A (list i0 i1)) A)
            (-> (* :a i0) [:a f g])
            (-> (* :a i1) :a)))
        ...)

      (lambda (-> (* B I) B)
        (extend-from
          (lambda (-> (* B (list i0 i1)) B)
            (-> (* :b i0) [:b g f])
            (-> (* :b i1) :b)))
        ...)
      #+end_src

* (old) 二維空間之間的映射的例子

*** (~~ bool-suspend sphere-1)

    #+begin_src scheme
    (define sphere-1
      (type space
        (: b (-1 <>))
        (: loop (0 b b))))

    (define bool
      (type space
        (: [#f, #t] (-1 <>))))

    (define bool-suspend
      (type space
        (: [n, s] (-1 <>))
        (: m (-> bool (0 n s)))))

    (define f
      (lambda (-> bool-suspend sphere-1)
        (with (-> (-1 bool-suspend) (-1 sphere-1))
          (-> n b)
          (-> s b))
        (with (-> (0 n s) (0 b b))
          (-> (1 #f m) (1 loop))
          (-> (1 #t m) (1 b refl)))))

    (define g
      (lambda (-> sphere-1 bool-suspend)
        (with (-> (-1 sphere-1) (-1 bool-suspend))
          (-> b n))
        (with (-> (0 b b) (0 n n))
          (-> (1 loop) (1 #f m #t m rev)))))

    (note
      [g f] is already id of sphere-1)

    (define [g f]
      (lambda (-> sphere-1 sphere-1)
        (with (-> (-1 sphere-1) (-1 sphere-1))
          (-> b b))
        (with (-> (0 b b) (0 b b))
          (-> (1 loop) (1 loop)))))

    (define [f g]
      (lambda (-> bool-suspend bool-suspend)
        (with (-> (-1 bool-suspend) (-1 bool-suspend))
          (-> n n)
          (-> s n))
        (with (-> (0 n s) (0 n n))
          (-> (1 #f m) (1 #f m #t m rev))
          (-> (1 #t m) (1 n refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend id]))

    (define h
      (lambda (-> (* bool-suspend I) bool-suspend)
        (extend-from
          (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
            (-> (* :x i0) [:x f g])
            (-> (* :x i1) :x)))
        (with (-> (* (-1 bool-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n (1 i01)) (1 n refl)
              (:> (0 n n)))
          (-> (* s (1 i01)) (1 #t m)
              (:> (0 n s))))
        (with (-> (* (0 n s) %:b (0 i0 i1) %:i)
                  (1 (* :b i0) <> (* s :i) <>
                     (* :b i1) <> rev (* n :i) <> rev))
          (-> (* (1 #f m) (1 i01)) (2)
              (:> (1 (1 #f m #t m rev) (1 #t m)
                     (1 #f m) rev (1 n refl) rev)))
          (-> (* (1 #t m) (1 i01)) (2)
              (:> (1 (1 n refl) (1 #t m)
                     (1 #t m) rev (1 n refl) rev))))))
    #+end_src

*** (~~ bool-suspend-suspend sphere-2)

    #+begin_src scheme
    (define sphere-2
      (type space
        (: b2 (-1 <>))
        (: surf (1 b2 refl))))

    (define bool-suspend-suspend
      (type space
        (: [n2, s2] (-1 <>))
        (: m2 (-> bool-suspend (0 n2 s2)))))

    (: [n m2] (0 n2 s2))
    (: [s m2] (0 n2 s2))
    (: [#f m m2] (1 n m2 s m2 rev))
    (: [#t m m2] (1 n m2 s m2 rev))

    (define f
      (lambda (-> bool-suspend-suspend sphere-2)
        (with (-> (-1 bool-suspend-suspend) (-1 sphere-2))
          (-> n2 b2)
          (-> s2 b2))
        (with (-> (0 n2 s2) (0 b2 b2))
          (-> (1 n m2) (1 b2 refl))
          (-> (1 s m2) (1 b2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 b2 refl))
          (-> (2 #f m m2) (2 surf))
          (-> (2 #t m m2) (2 b2 refl refl)))))

    (define g
      (lambda (-> sphere-2 bool-suspend-suspend)
        (with (-> (-1 sphere-2) (-1 bool-suspend-suspend))
          (-> b2 n2))
        (with (-> (1 b2 refl) (1 n2 refl))
          (-> (2 surf) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                          #t m m2 (1) as-remained-boundary)))))

    (define [g f]
      (lambda (-> sphere-2 sphere-2)
        (with (-> (-1 sphere-2) (-1 sphere-2))
          (-> b2 b2))
        (with (-> (1 b2 refl) (1 b2 refl))
          (-> (2 surf) (2 surf)))))

    (note
      (2 surf)
      g =>
      (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
         #t m m2 (1) as-remained-boundary)
      f =>
      (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev) as-remained-boundary
         (2 b2 refl refl) (1) as-remained-boundary)
      ==
      (2 surf))

    (define [f g]
      (lambda (-> bool-suspend-suspend bool-suspend-suspend)
        (with (-> (-1 bool-suspend-suspend) (-1 bool-suspend-suspend))
          (-> n2 n2)
          (-> s2 n2))
        (with (-> (0 n2 s2) (0 n2 n2))
          (-> (1 n m2) (1 n2 refl))
          (-> (1 s m2) (1 n2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 n2 refl))
          (-> (2 #f m m2) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                             #t m m2 (1) as-remained-boundary))
          (-> (2 #t m m2) (2 n2 refl refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend-suspend id]))

    (define h
      (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
        (extend-from
          (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
            (-> (* :x i0) (* [:x f g]))
            (-> (* :x i1) (* :x))))
        (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n2 (1 i01)) (1 n2 refl)
              (:> (0 n2 n2))
              (note
                an alternative might be :: (1 n m2 s m2 rev)))
          (-> (* s2 (1 i01)) (1 s m2)
              (:> (0 n2 s2))
              (note
                an alternative might be :: (1 n m2))))
        (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                  (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                     (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
          (-> (* (1 n m2) (1 i01)) (2 #t m m2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 n m2) rev (1 n2 refl) rev)
                  (1 (1 s m2) (1 n m2) rev)))
          (-> (* (1 s m2) (1 i01)) (2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 s m2) rev (1 n2 refl) rev)
                  (1 (1 s m2)
                     (1 s m2) rev)
                  (1)))      )
        (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                  (2 (* (1 n m2) (1 :i)) <>
                     (1 (* n2 (1 i01)) <>
                        (* (1 n m2) i1) <>
                        (* s2 (1 i01)) <> rev
                        (* (1 n m2) i0) <> rev)
                     as-remained-boundary
                     (* (1 s m2) (1 :i)) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 n m2) i0) <> rev
                        (* (1 s m2) i1) <> rev
                        (* (1 s m2) i0) <>)
                     as-remained-boundary
                     (* (2 :c) i0) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 s m2) i1) <> rev)
                     as-remained-boundary
                     (* (2 :c) i1) <>
                     (1) as-remained-boundary))
          (-> (* (2 #f m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (1 (1 n2 refl)
                        (1 n m2)
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2)
                     (1 (1 n m2)
                        (1 n2 refl) rev
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2 #f m m2 (1 n m2 s m2 rev)
                        #t m m2 (1))
                     (1 (1 n m2)
                        (1 s m2) rev)
                     as-remained-boundary
                     (2 #f m m2)
                     (1) as-remained-boundary)))
          (-> (* (2 #t m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (2)
                     (2 n2 refl refl)
                     (2 #t m m2)
                     (1) as-final-boundary))))))
    #+end_src

* 二維空間之間的映射的例子

*** (~~ bool-suspend sphere-1)

    #+begin_src scheme
    (define sphere-1
      (type space
        (: b <>)
        (: loop (= b b))))

    (define bool
      (type space
        (: #f #t <>)))

    (define bool-suspend
      (type space
        (: n s <>)
        (: m (-> bool (= n s)))))

    (define f
      (lambda (-> bool-suspend sphere-1)
        (with (-> (-1 bool-suspend) (-1 sphere-1))
          (-> n b)
          (-> s b))
        (with (-> (= n s) (= b b))
          (-> (+ #f m) loop)
          (-> (+ #t m) (+ b refl)))))

    (define g
      (lambda (-> sphere-1 bool-suspend)
        (with (-> (-1 sphere-1) (-1 bool-suspend))
          (-> b n))
        (with (-> (= b b) (= n n))
          (-> loop (+ #f m (- #t m))))))

    (note
      [g f] is already id of sphere-1)

    (define [g f]
      (lambda (-> sphere-1 sphere-1)
        (with (-> (-1 sphere-1) (-1 sphere-1))
          (-> b b))
        (with (-> (0 b b) (0 b b))
          (-> (1 loop) (1 loop)))))

    (define [f g]
      (lambda (-> bool-suspend bool-suspend)
        (with (-> (-1 bool-suspend) (-1 bool-suspend))
          (-> n n)
          (-> s n))
        (with (-> (0 n s) (0 n n))
          (-> (1 #f m) (1 #f m #t m rev))
          (-> (1 #t m) (1 n refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend id]))

    (define h
      (lambda (-> (* bool-suspend I) bool-suspend)
        (extend-from
          (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
            (-> (* :x i0) [:x f g])
            (-> (* :x i1) :x)))
        (with (-> (* (-1 bool-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n (1 i01)) (1 n refl)
              (:> (0 n n)))
          (-> (* s (1 i01)) (1 #t m)
              (:> (0 n s))))
        (with (-> (* (0 n s) %:b (0 i0 i1) %:i)
                  (1 (* :b i0) <> (* s :i) <>
                     (* :b i1) <> rev (* n :i) <> rev))
          (-> (* (1 #f m) (1 i01)) (2)
              (:> (1 (1 #f m #t m rev) (1 #t m)
                     (1 #f m) rev (1 n refl) rev)))
          (-> (* (1 #t m) (1 i01)) (2)
              (:> (1 (1 n refl) (1 #t m)
                     (1 #t m) rev (1 n refl) rev))))))
    #+end_src

*** (~~ bool-suspend-suspend sphere-2)

    #+begin_src scheme
    (define sphere-2
      (type space
        (: b2 (-1 <>))
        (: surf (1 b2 refl))))

    (define bool-suspend-suspend
      (type space
        (: [n2, s2] (-1 <>))
        (: m2 (-> bool-suspend (0 n2 s2)))))

    (: [n m2] (0 n2 s2))
    (: [s m2] (0 n2 s2))
    (: [#f m m2] (1 n m2 s m2 rev))
    (: [#t m m2] (1 n m2 s m2 rev))

    (define f
      (lambda (-> bool-suspend-suspend sphere-2)
        (with (-> (-1 bool-suspend-suspend) (-1 sphere-2))
          (-> n2 b2)
          (-> s2 b2))
        (with (-> (0 n2 s2) (0 b2 b2))
          (-> (1 n m2) (1 b2 refl))
          (-> (1 s m2) (1 b2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 b2 refl))
          (-> (2 #f m m2) (2 surf))
          (-> (2 #t m m2) (2 b2 refl refl)))))

    (define g
      (lambda (-> sphere-2 bool-suspend-suspend)
        (with (-> (-1 sphere-2) (-1 bool-suspend-suspend))
          (-> b2 n2))
        (with (-> (1 b2 refl) (1 n2 refl))
          (-> (2 surf) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                          #t m m2 (1) as-remained-boundary)))))

    (define [g f]
      (lambda (-> sphere-2 sphere-2)
        (with (-> (-1 sphere-2) (-1 sphere-2))
          (-> b2 b2))
        (with (-> (1 b2 refl) (1 b2 refl))
          (-> (2 surf) (2 surf)))))

    (note
      (2 surf)
      g =>
      (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
         #t m m2 (1) as-remained-boundary)
      f =>
      (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev) as-remained-boundary
         (2 b2 refl refl) (1) as-remained-boundary)
      ==
      (2 surf))

    (define [f g]
      (lambda (-> bool-suspend-suspend bool-suspend-suspend)
        (with (-> (-1 bool-suspend-suspend) (-1 bool-suspend-suspend))
          (-> n2 n2)
          (-> s2 n2))
        (with (-> (0 n2 s2) (0 n2 n2))
          (-> (1 n m2) (1 n2 refl))
          (-> (1 s m2) (1 n2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 n2 refl))
          (-> (2 #f m m2) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                             #t m m2 (1) as-remained-boundary))
          (-> (2 #t m m2) (2 n2 refl refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend-suspend id]))

    (define h
      (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
        (extend-from
          (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
            (-> (* :x i0) (* [:x f g]))
            (-> (* :x i1) (* :x))))
        (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n2 (1 i01)) (1 n2 refl)
              (:> (0 n2 n2))
              (note
                an alternative might be :: (1 n m2 s m2 rev)))
          (-> (* s2 (1 i01)) (1 s m2)
              (:> (0 n2 s2))
              (note
                an alternative might be :: (1 n m2))))
        (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                  (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                     (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
          (-> (* (1 n m2) (1 i01)) (2 #t m m2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 n m2) rev (1 n2 refl) rev)
                  (1 (1 s m2) (1 n m2) rev)))
          (-> (* (1 s m2) (1 i01)) (2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 s m2) rev (1 n2 refl) rev)
                  (1 (1 s m2)
                     (1 s m2) rev)
                  (1)))      )
        (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                  (2 (* (1 n m2) (1 :i)) <>
                     (1 (* n2 (1 i01)) <>
                        (* (1 n m2) i1) <>
                        (* s2 (1 i01)) <> rev
                        (* (1 n m2) i0) <> rev)
                     as-remained-boundary
                     (* (1 s m2) (1 :i)) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 n m2) i0) <> rev
                        (* (1 s m2) i1) <> rev
                        (* (1 s m2) i0) <>)
                     as-remained-boundary
                     (* (2 :c) i0) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 s m2) i1) <> rev)
                     as-remained-boundary
                     (* (2 :c) i1) <>
                     (1) as-remained-boundary))
          (-> (* (2 #f m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (1 (1 n2 refl)
                        (1 n m2)
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2)
                     (1 (1 n m2)
                        (1 n2 refl) rev
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2 #f m m2 (1 n m2 s m2 rev)
                        #t m m2 (1))
                     (1 (1 n m2)
                        (1 s m2) rev)
                     as-remained-boundary
                     (2 #f m m2)
                     (1) as-remained-boundary)))
          (-> (* (2 #t m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (2)
                     (2 n2 refl refl)
                     (2 #t m m2)
                     (1) as-final-boundary))))))
    #+end_src

* 三維空間的例子

* 三維空間之間的映射

* neighborhood 與 幾何 [recover geometry]

  - x -
    如果想要引入 neighborhood 的概念
    那麼是否也要同時引入 幾何 呢 ?
    如果要的話
    那麼所有的線都應該理解爲空間中的直線[測地線]
    而所有的面都應該理解爲空間中的什麼 ?

  - k -
    使用 neighborhood 的意義在於有限覆蓋定理
    但是我們所定義 neighborhood 的方式
    目前只是爲了把它聯繫於 用邊界所定義的連續性

  - x -
    我想我們必須引入幾何了

  - k -
    我想你之所以這樣說
    是因爲當考慮到有限覆蓋的時候
    就像是給了圖形以座標系

  ------

  - 假設使用降維的 neighborhood
    在取點的 neighborhood 的時候
    這一點在邊中的所有出現都將稱爲新的點

    具體的規則與語法是什麼 ?

* >< 忘記高階代數結構中的某些信息就得到同調理論

*** 引

    - 如何解釋 S2 的三階同倫羣爲非平凡羣 ?
      一個非平凡羣的 abelianization 可以是平凡羣嗎 ?

    - 只能解釋爲 兩個平凡等式 可能不等價

*** 規則

    - 說 homology group 是 高階代數的 abelianization
      首先要取 高階代數的 close chain

    - 經過 abelianization 之後
      邊界爲 0 的 k 階生成子是 k 階同調羣的元素
      k+1 階生成子給出 k 階同調羣中元素之間的等式

      - 只取生成子是不夠的
        因爲不閉的生成子 可能複合爲閉的元素

    - 高階代數中的 chain 經過 abelianization
      不能給出 homology theory 中的所有 chain

    - 也可以在簡化的時候不打散所有的碎片
      保持其中部分相連

*** 例子

    #+begin_src scheme
    (: abelianization (-> space homology-space))

    (note homology-space reuse syntax such as (: ...) and (+ ...))

    (define S2
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a0))
        (: c0 (= (+ b0 b1) (+ b0 b1)))))

    (homological-equivalent
     (abelianization S2)
     (type homology-space
       (: a0 a1 <>)
       (: b0 (+ a0 (- a1)))
       (: b1 (+ a1 (- a0)))
       (: c0 (+))))

    (note S2 :: Z 0 Z)

    (define P2
      (type space
        (: a0 a1 <>)
        (: b0 (= a0 a1))
        (: b1 (= a1 a0))
        (: c0 (= (+ b0 b1) (+ (- b1) (- b0))))))

    (homological-equivalent
     (abelianization P2)
     (type homology-space
       (: a0 a1 <>)
       (: b0 (+ a0 (- a1)))
       (: b1 (+ a1 (- a0)))
       (: c0 (+ b0 b1 b1 b0))))

    (note P2 :: Z Z/2 0)

    (define T2
      (type space
        (: a0 <>)
        (: b0 b1 (= a0 a0))
        (: c0 (= (+ b0 b1) (+ b1 b0)))))

    (homological-equivalent
     (abelianization T2)
     (type homology-space
       (: a0 <>)
       (: b0 b1 (+))
       (: c0 (+))))

    (note T2 :: Z Z+Z Z)

    (define K2
      (type space
        (: a0 <>)
        (: b0 b1 (= a0 a0))
        (: c0 (= (+ b0 b1) (+ b1 (- b0))))))

    (homological-equivalent
     (abelianization K2)
     (type homology-space
       (: a0 <>)
       (: b0 b1 (+))
       (: c0 (+ b0 b0))))

    (note K2 :: Z Z+Z/2 0)
    #+end_src

* 獲得拓撲不變量

*** 引

    - 取閉合的鏈
      是否就能簡化代數結構而得到能力更強的拓撲不變量呢 ?

      我想問題應該劃歸爲
      當限制 代數中的元素爲 閉合的鏈時
      可否得到對這些元素的更高效的編碼 ?
      能否把這個代數結構化簡到正規形式 ?

      曲面的分類定理 可否被表達爲 對這個代數結構的化簡 ?
      一維的時候 我們可以把這個代數結構化簡成基本羣
      [我們要形成等價的定理 但是表達方式已經不一樣了]
      二維的時候 二階同倫羣是不夠的
      只考慮零虧格的曲面嵌入三維空間是不夠的
      還需要考慮高虧格的曲面嵌入三維空間
      三維空間中可能有高虧格的洞

*** 基本羣的另一種表示方式

    - 我們可以說兩個圈相加
      而不必說兩個圈相加而得到一個圈

*** 簡化代數結構的方法

    - 同倫的閉合鏈產生與對代數結構的過度細分
      找出同倫的鏈然後融合細分中的部分
      就能化簡代數結構

* >< 覆蓋空間 與 元素的等價問題

  - x -
    fundamental-group of surface =
    group of covering-transformation of universal-covering-space of surface
    這個等價如何推廣到高維代數 ?

  - k -
    首先我們看到推廣的可能的時候
    並不是從這個角度考慮的
    這在於 path 的邊界 形成一個點到點的[可逆]映射
    而 disk 的邊界 不能形成點到點的映射
    它所形成的是 很多邊之間的[可逆]關係

    我們想的其實還不是 點到點的可逆變換
    而是 給定 起點的時候 path 與終點對應 [降維]

  - x -
    groupoid 也可以 acting on covering-space
    只不過 covering-transformation 要加上類型

    branched-covering 使得 path lifting 不唯一

    帶有 一階洞 的 covering
    不同的 loop 經過 lifting
    可能給出 covering-space 中的同一個終點
    [因爲 covering-space 中可能有不可收縮的 loop]

    也就是說
    一個使得點變多
    一個使得點變少
    只有 universal-covering-space 的點是與 path 一一對應的

* >< 用沒有一階洞的一階無窮複形覆蓋一般一階複形

* >< 用沒有二階洞的二階無窮複形覆蓋一般二階複形

  - 此時有必要使用 branched-covering
    我們可以試試找一個 branched-covering of torus
    看看這個 branched-covering 能否解決 torus 的字問題

* >< 曲面分類定理的形式化
