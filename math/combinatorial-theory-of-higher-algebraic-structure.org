#+title: combinatorial theory of higher algebraic structure

* note

*** critiques

***** a critique of eckmann-hilton argument

      - about interchange law.

      - x -
        所謂 eckmann-hilton argument
        與高階乘法的 '交換性'
        應該被視爲一個語言學現象

        首先
        古典理論中對高階乘法的交換性的證明
        用到了連續的 homotopy
        而只是在形式化的處理方式中才需要用到 eckmann-hilton argument

        eckmann-hilton argument 說
        利用如下的條件
        (A x B) o (C x D) = (A o C) * (B o D)
        [即 多種粘合次序能粘合出同一個幾何體]
        就能證明高階乘法的交換性

        但是 這個條件本質上是交換性的另一種表述方式
        考慮一階元素的兩種相乘方式 [>< 此處需要圖示]
        (p * q) 與 ((p rev) * (q rev))
        此時 eckmann-hilton 的條件就變成了
        ((a * b) rev) * ((c * d) rev) =
        ((a rev) * (c rev)) * ((b rev) * (d rev))
        即
        (b rev) * (a rev) * (d rev) * (c rev) =
        (a rev) * (c rev) * (b rev) * (d rev)
        另 c = d = 1 得
        b * a = a * b

        其實 正確的理解方式是
        兩種相乘方式之所以相等 (A x B) = (A o B)
        是因爲它只是就 a 與 b 的兩個不同的公共邊界來相乘
        所得到的將是對同一個幾何體的兩種邊界不同的表述
        這種不同的表示本質上代表相同的幾何體
        因爲兩種相乘方式是 '同位的'
        [比如 (p * p) 不等於 (p * (p rev)) 是因爲 用於相乘的公共邊界不是同位的]
        以這一階幾何體爲邊界的更高階幾何體 將表示這這一階幾何體之間的關係
        這些關係可以重載於這兩種不同的邊界表示方式之上

      - k -
        可以看出
        數學語言之缺陷在於
        它總是被侷限在語法上
        而沒有考慮語法與語義之間的關係

***** a critique of fibration in hott

      - x -
        hott 對乘法的處理方式與 AT 的直覺相左
        並且與對 fiber-space 的對稱處理相衝突

        對稱的處理方式在於
        同一個幾何體的不同邊界表示 本質上還要被認爲是同一個幾何體
        比如 (m : ((p1 * p2) = q)) 與 (m : (p2 = ((p1 rev) * q)))
        而 hott 中處理它們的方式 講給幾何體加上多餘的信息
        [考慮 一個邊在面中漸進到另一個邊]
        這種多餘的信息 將使兩者不能視爲本質等同

        所得到的 tp 將使得
        一個 m 在同一個 fiber 中有兩種不同的像
        同一個 m 沿着不同的推進方式 將被映爲同一個 fiber 中的兩個面
        [在只考慮 globe 的情形下 是體現不出來的]

      - x -
        [bridges 與 logic programming]
        在已有的形式處理中 不好的一點是 totel-space 是 fiber 的不交並
        因爲其不交 所以當要把一個 path lift 到 totel-space 中時
        f : ((x : A) -> x P)
        ~ : ((p : (x = y)) -> (x f = y f))
        而後面的這個 (x f = y f) 是不可能的
        即 兩個不同空間中的點沒有路

        已有的形式處理方式
        可以在 '不交並' 的前提下
        巧妙地給出這種 path 的定義

        而我想用 bridge 把 fiber 連起來
        這樣就不能說是 '不交並' 了

        可逆性可以用 logic language 來處理
        一個 path 引出兩個 fiber 之間的 等價
        可以試着使用一個 relation 來處理這個等價
        比如
        p(x, y) 用來 unify x, y 的同時 還能返回一個邊
        m(p1, p2, p3) 做 unify 的同時 也能返回一個面

*** mimicing

***** intro

      - x -
        when developing n-groupoid theory,
        we can mimic the development of group theory.
        then what is the development of group theory ?

      - k -
        先看表面的現象
        羣論有一個乘法
        而其公理中有
        (1) 封閉性
        (2) 單位元與可逆性
        (3) 結合性

      - x -
        (1) 封閉性
        我們考慮的是 生成子 加 關係 所定義的羣
        同樣 生成子 加 關係 也可以定義高維的代數結構
        此時封閉性是自然的
        (2) 單位元與可逆性
        單位元也是自然的
        可逆性需要考慮相乘的位置
        首先可以用 '相乘的位置'
        來解釋一般的羣論中的乘法與逆元
        爲不同位置的相乘
        然後再推廣到高維
        (3) 結合性
        相乘的結果最終
        與各種可能的相乘的方式無關

      - k -
        羣論本身可以用來描述空間的對稱性
        高維的代數可以用來描述什麼呢 ?

      - x -
        group 描述對稱性
        groupoid 可以看成是描述對稱性 但是加上了類型信息 和 類型檢查

      - [關於正規性]
        從一般的高維乘法看來
        羣論之所以可以被如此簡化
        是因爲線段是規則的圖形
        正如 cube 和 simplex 是 規則的圖形一樣

      - higher dim elements can be used
        to record the proofs of equality
        between elements of one dim lower.

      - x -
        the computation of product of higher algebra,
        is enabled by two kinds of rules,
        (1) same-position-self-gluing
        (2) one-dim higher elements as relations

***** generators and relations

      - x -
        adding types to the generators,
        we get a combinatorial 1-groupoid theory.

***** object group [subgroup structure] of 1-groupoid

      - x -
        about tree
        ><><><

***** 正規子羣與羣同態

      - x -
        在 combinatorial group theory 中
        通過增加 relation 可以得到已有的 g.r.group 的正規子羣
        正規子羣 與 羣同態 之間 有一一對應關係
        對於 combinatorial infi-groupoid theory
        我們可以形成類似的理論嗎 ?

      - k -
        這種現象稱爲 第一同態定理
        groupoid theory 並沒有這種現象
        把 groupoid theory 劃歸爲 group theory
        就能觀察到這個定理的缺失

***** fundamental theorem of finitely generated abelian groups

      - x -
        fundamental theorem of finitely generated abelian groups
        is just like the fundamental theorem of arithmetic.

*** phenomena

***** higher homotopy groups are always commutative

      - x -
        by the definition of homotopy group I showed in AT1,
        can I prove higher homotopy groups are always commutative ?

***** 高維代數結構中的乘法

      - 對於高維的乘法 (n ...)
        既然乘法是 '可交換的'
        爲什麼我們還需要相乘的序
        因爲 序 給出指明乘合體中位置的方式

***** interchange law

      - 2 homotopy group (Cech 1932) -> two group structure ->
        interchange law -> one group structure

      - 2 homotopy groupoid -> two groupoid structure ->
        interchange law -> more then one groupoid structure (more non abelian)

* intro

  - the simple idea is to study algebraic structures
    by their generators and relations.

* intro

  - I will show how to design and implement a language
    to formalize and machinalize
    a little part of algebraic topology.

  - I call this prototype 'at1',
    which is an abbreviation of 'algebraic-topology-1'.

  - [advice for reader]
    If you know how to implement an interpreter,
    try to imagine how you would implement this language
    by directed graph processing.

* group

  - in combinatorial group theory,
    generators is described by a list of generators,
    and relations are described by equivalent relations
    between two expressions formed by generators.

    draw each generator as a edge.

    draw relation as a face
    whose boundary is attached to the circle
    induced by the equivalent relation.

    we get a space whose fundamental group is the group.

    the cayley graph of this group
    is the covering space of the space.

  - classifying space
    ><><><

* groupoid

  - in combinatorial groupoid theory,
    we still can use generators and relations to study the algebraic structure.

    while, generators must be expressed by a graph,
    [instead of a list of elements, in the case of group]
    which includes the informations about the type of elements.

    relations -- faces.

    the groupoid is the fundamental groupoid of the space.

    if a graph has no faces, thus no relations,
    its fundamental groupoid is free generated groupoid of the graph.

  - examples
    free groupoid
    graph without faces
    ><><><

* higher algebraics structure

  - if the space have higher level elements,
    it can generate a graded algebraic structure,
    in which compositions are typed by boundary of elements.

  - we need a language to express
    how to compose higher level elements together.

  - 空間給出的高維代數結構
    包含了空間的所有拓撲信息
    [至少是同倫等價下的拓撲信息]
    代數拓撲的方法就是去找這個高維代數結構的子結構
    這些子結構可能容易計算一些
    因此就有 '實用的' 分類空間[否定空間相等]的工具了
    但是其實 這些子結構永遠都沒法包含原高維代數的所有信息

* 高階代數的表示論之語言的特點

  1. 需要設計新的語法來描述階元的乘法
     '乘號' 本身應該被高階生成元的邊界結構化

     - 可以用語言學來論述 '不存在良好的高維幾何[代數]語言'
       比如 在 CL 中消去 lambda
       所謂 '消去' 只是轉變了編碼方式
       而不能從本質上簡化語言

     - 幾何體的分類問題可以簡化描述的複雜度

  2. 相乘的條件是有公共邊界
     相乘後公共邊界被消除

     - thus 'boundary as type'
       which determines when and how
       two elements can be composed together.

  3. 高一階元素是低一階元素之間的關係[等式]

  4. 必須能描述一個元素的邊界的所有位置
     同一個元素就相同的位置自乘則相消

     - 描述粘合方式的語言必定是線性的
       線性的描述方式自然給出指明粘合體中所有位置的方法

* simple-space

  - In a language, we always have primitive elements,
    and many ways to compose elements to new compound element,
    also many ways to derive new element from old one.

  - Here, I describe a simple way to construct spaces,
    so constructed spaces will be called simple-spaces,
    which constitute the first kind of primitive space in my language.

    Before having other ways to construct spaces,
    I will simply call them 'space' instead of 'simple-space'.

    - In algebraic topology,
      our simple-space is called
      CW-complex, cell-complex or cellular polytopes.

  - A space is constructed part by part.

  - A part is of certain dimension.

    | dim | name     |
    |-----+----------|
    |   0 | point    |
    |   1 | interval |
    |   2 | disk     |
    |   3 | ball     |
    |   4 | 4-cell   |
    |   n | n-cell   |

  - The way to construct a space from parts,
    goes from low dimension to high dimension,
    by attaching the boundary of a n-cell,
    to a (n-1)-sphere in the space.

    Our principle here is 'construction by attaching boundary'.

  - As an example, let us construct a tetrahedron.

    - [advice for reader]
      Draw a picture by yourself, when trying to follow
      my formal description.

      And imagining how such picture can be dynamicly
      and automaticly drawn by a drawer that
      accompanies the main interpreter of the language.

    - In 0 dimension,

      we name all the points of the space.

      #+begin_src scheme
      (type space
        (: [a1, a2, a3, a4] (-1 <>)))
      #+end_src

    - In 1 dimension,

      we name all the intervals of the space,

      and for each interval,
      we attach its two end points to two points of the space
      [the two points of the space might be the same point],

      so that the boundary of the interval
      can be viewed as two points of the space.

      #+begin_src scheme
      (type space
        (: [a1, a2, a3, a4] (-1 <>))
        (: b12 (0 a1 a2))
        (: b13 (0 a1 a3))
        (: b14 (0 a1 a4))
        (: b23 (0 a2 a3))
        (: b24 (0 a2 a4))
        (: b34 (0 a3 a4)))
      #+end_src

      For example, the boundary of 'b12' are 'a1' and 'a2',
      the boundary of 'b13' are 'a1' and 'a3'.

      One can view 'b12' as a directed path pointing from 'a1' to 'a2',
      and 'b13' as a directed path pointing form 'a1' to 'a3'.

      We write the two points in the keyword '(0 ...)',
      and the order matters.

      Since, 'b12' and 'b13' have a common boundary -- 'a1',
      we view 'b12' and 'b13' as glued together by the common boundary.

      Our principle here is 'gluing by named common boundary'.

    - In 2 dimension,

      we name all the disk of the space,

      and for each disk,
      we attach its boundary circle to a circle in the space.

      #+begin_src scheme
      (type space
        (: [a1, a2, a3, a4] (-1 <>))
        (: b12 (0 a1 a2))
        (: b13 (0 a1 a3))
        (: b14 (0 a1 a4))
        (: b23 (0 a2 a3))
        (: b24 (0 a2 a4))
        (: b34 (0 a3 a4))
        (: c123 (1 b12 b23 b13 rev))
        (: c124 (1 b12 b24 b14 rev))
        (: c134 (1 b13 b34 b14 rev))
        (: c234 (1 b23 b34 b24 rev)))
      #+end_src

      I use the keyword '(1 ...)' to specify path in the space.

      For example, '(1 b12 b23)' denotes
      the path which goes through 'b12' forwardly and 'b23' forwardly.

      In the keyword '(1 ...)',
      the right end point of one interval must matches
      the left end point of the next interval.

      And '(1 b12 b23 b13 rev)' denotes the path which
      goes through 'b12' forwardly, 'b23' forwardly, and 'b13' backwardly.

      The boundary of 'c123' is attached to the circle '(1 b12 b23 b13 rev)'.

      We check whether a path is a circle,
      by checking whether the left end point of the first interval,
      is equal to the right end point of the last interval,
      i.e. whether the path is closed.

    - In 3 dimension,

      we name all the ball of the space,

      and for each ball,
      we attach its boundary sphere to a sphere in the space.

      #+begin_src scheme
      (type space
        (: [a1, a2, a3, a4] (-1 <>))
        (: b12 (0 a1 a2))
        (: b13 (0 a1 a3))
        (: b14 (0 a1 a4))
        (: b23 (0 a2 a3))
        (: b24 (0 a2 a4))
        (: b34 (0 a3 a4))
        (: c123 (1 b12 b23 b13 rev))
        (: c124 (1 b12 b24 b14 rev))
        (: c134 (1 b13 b34 b14 rev))
        (: c234 (1 b23 b34 b24 rev))
        (: d1234 (2 c123
                    c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary
                    c134 (1 b34 b24 rev b23) as-remained-boundary
                    c234 (1) as-remained-boundary)))
      #+end_src

      I use the keyword '(2 ...)' to specify polygons in the space.
      Note that, a polygon might be obtained by gluing many polygons together.

      For example :
      #+begin_src scheme
      (2 c123)
      ;; a polygon in a stack

      (2 c123
         c124)
      ;; two polygons in the stack

      (2 c123
         c124 (1 b14 b24 rev b23 b13 rev))
      ;; two polygons and a circle in the stack

      (2 c123
         c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary)
      ;; 'as-remained-boundary' is a function,
      ;;   which takes two polygons and a circle out from the stack,
      ;;   try cancel out part of the common boundary of 'c123' and 'c124',
      ;;   so that the remained boundary can be '(1 b14 b24 rev b23 b13 rev)'.
      ;; if there are no way or more then one way to do this,
      ;;   it reports to the user.
      ;; if there is only one way to do this,
      ;;   it puts a polygon back to the stack,
      ;;   whose boundary is '(1 b14 b24 rev b23 b13 rev)'.
      #+end_src

      The boundary of 'd1234' is attached to the sphere :
      #+begin_src scheme
      (2 c123
         c124 (1 b14 b24 rev b23 b13 rev) as-remained-boundary
         c134 (1 b34 b24 rev b23) as-remained-boundary
         c234 (1) as-remained-boundary)
      #+end_src

      We check whether a polygon is sphere [closed polygon],
      by checking whether the polygon is
      2-dimensional, closed, connected and orientable.

      Note that, we can implement more functions like 'as-remained-boundary',
      to help us get 2-dimensional polygons.

  - Note that, syntax in (0 ...) (1 ...) (2 ...) are different,
    but syntax in (2 ...) (3 ...) (4 ...) ... are similar.

    - (0 ...) is special, in the sense that,
      only two 0-dimensional points can occur in it.

    - (1 ...) is special, in the sense that,
      there is not explict functions, like 'as-remained-boundary' in it.

    - [hesitation about syntax]
      Should these three distinctions be unified ?
      If these distinctions are really meaningful,
      and ought not to be unified,
      Should we design distinct syntaxes for them,
      to maintain the distinctions,
      instead of using the seemingly unified syntax ?

  - Note that, 'as-remained-boundary' involves searching,
    which makes the specification of part of the space implict,
    such implicitness is need, for when the dimension gets higher,
    the detail of high dimension information might be too complex
    to use an explict method.

  - [hesitation about cobordism]
    Note that, not all closed spaces
    can be boundary of a 1-dim higher space.
    if two disjoint closed spaces, B1 and B2, are boundary of
    1-dim higher space C, then C is the cobordism of B1 and B2,
    classically expressed as (C; B1, B2),
    where B1 and B2 are called cobordant.

    Under what conditions, a closed space can be
    the boundary of a 1-dim higher space ?
    This question should be thoroughly understood,
    before developing the formal semantics of the language.

  - [summary of principles]
    - [principle 1] construction by attaching boundary
    - [principle 2] gluing by named common boundary

* map and continuity-check

  - A map between space 'A' and 'B', is of type '(-> A B)'.
    The simplest kind of map,
    will map n-dim parts of 'A' to n-dim parts of 'B',
    I call this kind of map 'level-same' map.

  - Thus, we must distinguish following different kinds of maps :
    - level-same
    - level-diff
      - level-up
      - level-down

  - I do not know what rules should be established
    to handle level-diff map properly yet.

  - For level-same maps, the rule for continuity-check is simple.
    Suppose we have map (: f (-> A B)),
    and 'p' is a n-dim part of 'A'.

    continuity-check is simply
    #+begin_src scheme
    (= [p f boundary] [p boundary f])
    ;; or
    (: [p f] [p boundary f])
    #+end_src

    i.e. how the boundary of 'p' is mapped to 'B' by 'f',
    will constrain how 'p' can be mapped to 'B' by 'f'.

  - Since a map has many levels.

* product-space

  - The first kind of primitive space is simple-space defined above,
    while the first kind of compound space is product-space.

  - There can be many ways by which we can compose new spaces,
    each of such way must shows
    1. what are the parts of the space ?
    2. what are the boundarys of the parts ?

  - The rule of product-space
    #+begin_src scheme
    (= [(* a b) boundary] (+ (* a boundary b) (* a b boundary)))
    ;; or
    (: (* a b) (+ (* a boundary b) (* a b boundary)))
    #+end_src

  - Note that, in the rule above,
    (+ ...) is implicit about how to view the resulting shape.
    I do not know the general explict rule yet.

  - The interval is defined as follow
    #+begin_src scheme
    (define I
      (type space
        (: [i0, i1] (-1 <>))
        (: i01 (0 i0 i1))))
    #+end_src

    Taking the interval as an example,
    the rule for construction are
    #+begin_src scheme
    (: (* i01 i0) (0 (* i0 i0) (* i1 i0)))
    (: (* i1 i01) (0 (* i1 i0) (* i1 i1)))
    (: (* i01 i1) (0 (* i0 i1) (* i1 i1)))
    (: (* i0 i01) (0 (* i0 i0) (* i0 i1)))
    (: (* i01 i01) (1 (* i01 i0) (* i1 i01)
                      (* i01 i1) rev  (* i0 i01) rev))
    #+end_src

  - A function of type (-> (* I I) X)
    can be defined as follow
    #+begin_src scheme
    (define f
      (lambda (-> (* I I) X)
        (with (-> (* (-1 I) (-1 I)) (-1 X))
          (-> (* i0 i0) ...)
          (-> (* i0 i1) ...)
          (-> (* i1 i0) ...)
          (-> (* i1 i1) ...))
        (with (-> (* (0 i0 i1) (-1 I) %:i)
                  (0 (* i0 :i) <>
                     (* i1 :i) <>))
          (-> (* (1 i01) i0) ...)
          (-> (* (1 i01) i1) ...))
        (with (-> (* (-1 I) %:i (0 i0 i1))
                  (0 (* :i i0) <>
                     (* :i i1) <>))
          (-> (* i0 (1 i01)) ...)
          (-> (* i1 (1 i01)) ...))
        (with (-> (* (0 i0 i1) %:p0
                     (0 i0 i1) %:p1)
                  (1 (* (1 :p0) i0) <>
                     (* i1 (1 :p1)) <>
                     (* (1 :p0) i1) <> rev
                     (* i0 (1 :p1)) <> rev))
          (-> (* (1 i01) (1 i01)) ...))))
    #+end_src

* extension-problem

  - An extension-problem is expressed for a partial-map on a subspace.

  - To solve an extension-problem
    is to extend a partial map to a total-map step by step,
    while maintain the continuity of the map.

  - A partial-map is a map defined on subspace of a space.

  - The subspace relation between spaces is encoded by parts.

  - Suppose 'A' is a subspace of 'X'
    the following is to extend a partial-map 'g'
    to a total-map 'f'
    #+begin_src scheme
    (let ([g (lambda (-> A Y) ...)])
      (define f
        (lambda (-> X Y)
          (extend-from g)
          ...)))
    #+end_src

* equality

  - With product-space and extension-problem,
    we can define equality between two functions
    as the extension-problem for certain kind of product-space.

  - Suppose (: [f0, f1] (-> A B)),
    to proof (~ f0 f1),
    we need to extend a partial-map of type (-> (* A I) B)
    #+begin_src scheme
    (let ([f0 (lambda (-> A B) ...)]
          [f1 (lambda (-> A B) ...)])
      (lambda (-> (* A I) B)
        (extend-from
          (lambda (-> (* A (list i0 i1)) B)
            (-> (* :a i0) [:a f0])
            (-> (* :a i1) [:a f1])))
        ...))
    #+end_src

  - With the equality between functions,
    we can define the equality between space.

  - Suppose 'A' and 'B' are two spaces,
    to proof (~~ A B),
    is to find (: f (-> A B)) and (: g (-> B A))
    and to proof (~ [f g] [A id]) and (~ [g f] [B id])
    #+begin_src scheme
    (lambda (-> (* A I) A)
      (extend-from
        (lambda (-> (* A (list i0 i1)) A)
          (-> (* :a i0) [:a f g])
          (-> (* :a i1) :a)))
      ...)

    (lambda (-> (* B I) B)
      (extend-from
        (lambda (-> (* B (list i0 i1)) B)
          (-> (* :b i0) [:b g f])
          (-> (* :b i1) :b)))
      ...)
    #+end_src

* >< indexed-space

  - When defining a space, parts of it can be indexed
    by parts of another space.
    Such a named indexing of parts is called an index,
    which is also a subspace of the larger space.

  - Note that,
    if the indexing is to be viewed as a map,
    it would be a level-up map.

  - rule for indexed space [? cellular]

  - 'I' indexed by a space,
    is the suspension of the space.

  - While 'I' is 1-cell,
    how about 2-cell 3-cell and n-cell ?
    how about continuum other then n-cell ?
    note that, n-cell indexed by a space 'A',
    is specified by (-> A [n-cell boundary])

* examples

*** (~~ bool-suspend sphere-1)

    #+begin_src scheme
    (define sphere-1
      (type space
        (: b (-1 <>))
        (: loop (0 b b))))

    (define bool
      (type space
        (: [#f, #t] (-1 <>))))

    (define bool-suspend
      (type space
        (: [n, s] (-1 <>))
        (: m (-> bool (0 n s)))))

    (define f
      (lambda (-> bool-suspend sphere-1)
        (with (-> (-1 bool-suspend) (-1 sphere-1))
          (-> n b)
          (-> s b))
        (with (-> (0 n s) (0 b b))
          (-> (1 #f m) (1 loop))
          (-> (1 #t m) (1 b refl)))))

    (define g
      (lambda (-> sphere-1 bool-suspend)
        (with (-> (-1 sphere-1) (-1 bool-suspend))
          (-> b n))
        (with (-> (0 b b) (0 n n))
          (-> (1 loop) (1 #f m #t m rev)))))

    (note
      [g f] is already id of sphere-1)

    (define [g f]
      (lambda (-> sphere-1 sphere-1)
        (with (-> (-1 sphere-1) (-1 sphere-1))
          (-> b b))
        (with (-> (0 b b) (0 b b))
          (-> (1 loop) (1 loop)))))

    (define [f g]
      (lambda (-> bool-suspend bool-suspend)
        (with (-> (-1 bool-suspend) (-1 bool-suspend))
          (-> n n)
          (-> s n))
        (with (-> (0 n s) (0 n n))
          (-> (1 #f m) (1 #f m #t m rev))
          (-> (1 #t m) (1 n refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend id]))

    (define h
      (lambda (-> (* bool-suspend I) bool-suspend)
        (extend-from
          (lambda  (-> (* bool-suspend (-1 I)) bool-suspend)
            (-> (* :x i0) [:x f g])
            (-> (* :x i1) :x)))
        (with (-> (* (-1 bool-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n (1 i01)) (1 n refl)
              (:> (0 n n)))
          (-> (* s (1 i01)) (1 #t m)
              (:> (0 n s))))
        (with (-> (* (0 n s) %:b (0 i0 i1) %:i)
                  (1 (* :b i0) <> (* s :i) <>
                     (* :b i1) <> rev (* n :i) <> rev))
          (-> (* (1 #f m) (1 i01)) (2)
              (:> (1 (1 #f m #t m rev) (1 #t m)
                     (1 #f m) rev (1 n refl) rev)))
          (-> (* (1 #t m) (1 i01)) (2)
              (:> (1 (1 n refl) (1 #t m)
                     (1 #t m) rev (1 n refl) rev))))))
    #+end_src

*** (~~ bool-suspend-suspend sphere-2)

    #+begin_src scheme
    (define sphere-2
      (type space
        (: b2 (-1 <>))
        (: surf (1 b2 refl))))

    (define bool-suspend-suspend
      (type space
        (: [n2, s2] (-1 <>))
        (: m2 (-> bool-suspend (0 n2 s2)))))

    (: [n m2] (0 n2 s2))
    (: [s m2] (0 n2 s2))
    (: [#f m m2] (1 n m2 s m2 rev))
    (: [#t m m2] (1 n m2 s m2 rev))

    (define f
      (lambda (-> bool-suspend-suspend sphere-2)
        (with (-> (-1 bool-suspend-suspend) (-1 sphere-2))
          (-> n2 b2)
          (-> s2 b2))
        (with (-> (0 n2 s2) (0 b2 b2))
          (-> (1 n m2) (1 b2 refl))
          (-> (1 s m2) (1 b2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 b2 refl))
          (-> (2 #f m m2) (2 surf))
          (-> (2 #t m m2) (2 b2 refl refl)))))

    (define g
      (lambda (-> sphere-2 bool-suspend-suspend)
        (with (-> (-1 sphere-2) (-1 bool-suspend-suspend))
          (-> b2 n2))
        (with (-> (1 b2 refl) (1 n2 refl))
          (-> (2 surf) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                          #t m m2 (1) as-remained-boundary)))))

    (define [g f]
      (lambda (-> sphere-2 sphere-2)
        (with (-> (-1 sphere-2) (-1 sphere-2))
          (-> b2 b2))
        (with (-> (1 b2 refl) (1 b2 refl))
          (-> (2 surf) (2 surf)))))

    (note
      (2 surf)
      g =>
      (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
         #t m m2 (1) as-remained-boundary)
      f =>
      (2 (2 surf) (1 (1 b2 refl) (1 b2 refl) rev) as-remained-boundary
         (2 b2 refl refl) (1) as-remained-boundary)
      ==
      (2 surf))

    (define [f g]
      (lambda (-> bool-suspend-suspend bool-suspend-suspend)
        (with (-> (-1 bool-suspend-suspend) (-1 bool-suspend-suspend))
          (-> n2 n2)
          (-> s2 n2))
        (with (-> (0 n2 s2) (0 n2 n2))
          (-> (1 n m2) (1 n2 refl))
          (-> (1 s m2) (1 n2 refl)))
        (with (-> (1 n m2 s m2 rev) (1 n2 refl))
          (-> (2 #f m m2) (2 #f m m2 (1 n m2 s m2 rev) as-remained-boundary
                             #t m m2 (1) as-remained-boundary))
          (-> (2 #t m m2) (2 n2 refl refl)))))

    (note
      'h' is to proof (~ [f g] [bool-suspend-suspend id]))

    (define h
      (lambda (-> (* bool-suspend-suspend I) bool-suspend-suspend)
        (extend-from
          (lambda (-> (* bool-suspend-suspend (-1 I)) bool-suspend-suspend)
            (-> (* :x i0) (* [:x f g]))
            (-> (* :x i1) (* :x))))
        (with (-> (* (-1 bool-suspend-suspend) %:a (0 i0 i1))
                  (0 (* :a i0) <> (* :a i1) <>))
          (-> (* n2 (1 i01)) (1 n2 refl)
              (:> (0 n2 n2))
              (note
                an alternative might be :: (1 n m2 s m2 rev)))
          (-> (* s2 (1 i01)) (1 s m2)
              (:> (0 n2 s2))
              (note
                an alternative might be :: (1 n m2))))
        (with (-> (* (0 n2 s2) %:b (0 i0 i1) %:i)
                  (1 (* (1 :b) i0) <> (* s2 (1 :i)) <>
                     (* (1 :b) i1) <> rev (* n2 (1 :i)) <> rev))
          (-> (* (1 n m2) (1 i01)) (2 #t m m2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 n m2) rev (1 n2 refl) rev)
                  (1 (1 s m2) (1 n m2) rev)))
          (-> (* (1 s m2) (1 i01)) (2)
              (:> (1 (1 n2 refl) (1 s m2)
                     (1 s m2) rev (1 n2 refl) rev)
                  (1 (1 s m2)
                     (1 s m2) rev)
                  (1)))      )
        (with (-> (* (1 n m2 s m2 rev) %:c (0 i0 i1) %:i)
                  (2 (* (1 n m2) (1 :i)) <>
                     (1 (* n2 (1 i01)) <>
                        (* (1 n m2) i1) <>
                        (* s2 (1 i01)) <> rev
                        (* (1 n m2) i0) <> rev)
                     as-remained-boundary
                     (* (1 s m2) (1 :i)) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 n m2) i0) <> rev
                        (* (1 s m2) i1) <> rev
                        (* (1 s m2) i0) <>)
                     as-remained-boundary
                     (* (2 :c) i0) <>
                     (1 (* (1 n m2) i1) <>
                        (* (1 s m2) i1) <> rev)
                     as-remained-boundary
                     (* (2 :c) i1) <>
                     (1) as-remained-boundary))
          (-> (* (2 #f m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (1 (1 n2 refl)
                        (1 n m2)
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2)
                     (1 (1 n m2)
                        (1 n2 refl) rev
                        (1 s m2) rev
                        (1 n2 refl) rev)
                     as-remained-boundary
                     (2 #f m m2 (1 n m2 s m2 rev)
                        #t m m2 (1))
                     (1 (1 n m2)
                        (1 s m2) rev)
                     as-remained-boundary
                     (2 #f m m2)
                     (1) as-remained-boundary)))
          (-> (* (2 #t m m2) (1 i01)) (3)
              (:> (2 (2 #t m m2)
                     (2)
                     (2 n2 refl refl)
                     (2 #t m m2)
                     (1) as-final-boundary))))))
    #+end_src

* >< mapping-class-group

  #+begin_src scheme
  (define cylinder
    (type space
      (: [a0, a1] (-1 <>))
      (: b0 (0 a0 a0))
      (: b1 (0 a1 a1))
      (: h  (0 a0 a1))
      (: c0 (1 h b1 h rev b0 rev))))

  (define twist
    (lambda (-> cylinder cylinder)
      (extend-from
        (identity-map-of (list b0 b1)))
      (with (-> (0 a0 a1) (0 a0 a1))
        (-> (1 h) (1 h b1)))
      (with (-> (1 h b1
                   h rev b0 rev)
                (1 h b1
                   b1 b1 rev
                   h rev b0 rev))
        (-> (2 c0)
            (2 c0 b1 refl
               (1 h b1
                  b1 b1 rev
                  h rev b0 rev)
               as-remained-boundary)))))
  #+end_src

* >< fiber-space

  - To view product-space as special fiber-space,
    for which a gluing pattern is given.

  - After a construction of a fiber-bundle,
    we can proof the total-space is equal to another space,
    and by doing so, we get a level-down map from the space to the base-space.

  - A level-down map can only be achieved by means of fiber-bundle.

* >< lifting-problem

  - A lifting-problem is expressed for a [?] on a fiber-space.

  - [lifting-problem and cross-section-problem]
    cross-section-problem can be viewed as
    lifting a subspace [instead of function] of the base-space,
    or just lifting the base-space itself [i.e. global cross-section].

* >< homotopy theory

*** note

    - x -
      homotopy group 被定義爲帶有代數結構的 mapping-space
      但是 對我們來說
      我們可以直接說它是 combinatorial group theory

    - k -
      也許 mapping-space 是必要的
      考慮高維的情形就知道了

    - x -
      不想用 mapping-space
      是因爲與 combinatorial theory 相比
      這種空間的生成元和關係不明顯

    - k -
      我們可以考慮 在低維的情形
      mapping-space 的代數結構如何獲得生成元與關係
      然後再推廣到高維

* >< homology theory

* ><

  - x -
    seifert–van kampen theorem
    太平凡了在 AT1 中
    這就是平凡的一句話
    高維情形也是如此

    在一個 groupoid 的表示中
    找一個支撐樹
    把它收縮成一點
    就得到了 fundamental group 的表示

    高維的情形可能是這樣的
    (1) 把空間化爲一種有特殊性質的標準空間
    (2) 在這個空間中尋找代數結構作爲不變量

* ><

  - x -
    如何檢查一個組合是否爲 Sn ?
    [因而可以成爲某個高階生成子的邊界]
